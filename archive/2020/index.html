
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/archive/2020/">
      
      
        <link rel="prev" href="../2021/">
      
      
        <link rel="next" href="../2019/">
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>2020 - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#2020" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2020
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Welcome

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../2025/" class="md-tabs__link">
          
  
  
    
  
  归档

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tags
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    归档
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2021/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    
      
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#docker-overlay-filesystem" class="md-nav__link">
    <span class="md-ellipsis">
      docker overlay filesystem
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect-raspberry-and-arduino-via-i2c" class="md-nav__link">
    <span class="md-ellipsis">
      connect raspberry and arduino via i2c
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      C的宏定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    <span class="md-ellipsis">
      python 包的管理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system-calls-method" class="md-nav__link">
    <span class="md-ellipsis">
      system calls method
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#huawei-unlock-bootloader" class="md-nav__link">
    <span class="md-ellipsis">
      huawei unlock bootloader
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#install-kvm-on-debian-of-aarch64-architecture" class="md-nav__link">
    <span class="md-ellipsis">
      Install KVM on Debian of aarch64 architecture
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lvm" class="md-nav__link">
    <span class="md-ellipsis">
      LVM 功能介绍
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 中断请求
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2019
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#docker-overlay-filesystem" class="md-nav__link">
    <span class="md-ellipsis">
      docker overlay filesystem
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect-raspberry-and-arduino-via-i2c" class="md-nav__link">
    <span class="md-ellipsis">
      connect raspberry and arduino via i2c
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      C的宏定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    <span class="md-ellipsis">
      python 包的管理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system-calls-method" class="md-nav__link">
    <span class="md-ellipsis">
      system calls method
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#huawei-unlock-bootloader" class="md-nav__link">
    <span class="md-ellipsis">
      huawei unlock bootloader
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#install-kvm-on-debian-of-aarch64-architecture" class="md-nav__link">
    <span class="md-ellipsis">
      Install KVM on Debian of aarch64 architecture
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lvm" class="md-nav__link">
    <span class="md-ellipsis">
      LVM 功能介绍
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 中断请求
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="2020">2020<a class="headerlink" href="#2020" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-18 00:00:00+00:00">2020年11月18日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/">二叉树遍历</a></h2>
<h3 id="_2"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_2">二叉树定义</a></h3>
<p>二叉树的父节点最多有2个子节点，如果二叉树的所有父节点没有节点或者有2个节点，那么叫完全二叉树</p>
<h3 id="_3"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_3">二叉树的遍历方式</a></h3>
<p>二叉树有4中遍历方式： 前序遍历， 中序， 后序， 以及层序  </p>
<p>前三种可以对比着看，区别在于父节点先被访问的顺序，这里的先后都是相对于同一个树而言。 这里的访问意思是访问其值， 例如打印节点的数据：<br />
  * 前序遍历， 先父节点，再左子节点，最后是右子节点 
  * 中序遍历， 先左子节点， 再父节点， 最后是右子节点
  * 中序遍历， 先左子节点， 再右子节点 ，最后父节点</p>
<p>可见，都是先左子节点后右子节点  </p>
<p>而层序遍历是从上往下，广度优先</p>
<h3 id="_4"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_4">效果</a></h3>
<p>若有以下二叉树，则遍历结果
<pre class="mermaid"><code>graph BT
    A[1] --&gt; B[0]
    C[2] --&gt; B
    D[3] --&gt; A
    E[4] --&gt; A
    F[5] --&gt; C
    G[6] --&gt; C
    H[7] --&gt; D
    I[8] --&gt; D
    J[9] --&gt; E</code></pre></p>
<p>层序: 0 1 2 3 4 5 6 7 8 9</p>
<p>先序: <u>0</u> 1 <u>3</u> 7 8 4 9 2 5 <u>6</u><br />
中序: 7 <u>3</u> 8 1 9 4 <u>0</u> 5 2 <u>6</u><br />
后序: 7 8 <u>3</u> 9 4 1 5 <u>6</u> 2 <u>0</u>  </p>
<p>注意下划线，即036组成的一个树， 可以证实上面的总结  </p>
<h3 id="_5"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_5">代码实现</a></h3>
<p>实现前三种遍历都有2种方式， 递归和使用stack</p>
<p>节点数据结构
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">Node</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lchild</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<h4 id="_6"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_6">递归实现</a></h4>
<p>前序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<p>中序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<p>后序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
</code></pre></div></p>
<h4 id="stack"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#stack">stack实现</a></h4>
<p>前序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Front_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Node</span> <span class="o">=</span> <span class="n">root</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">Node</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">Node</span><span class="p">:</span>
            <span class="c1"># 访问和入栈的顺序顺序是先父节点后左节点</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
            <span class="c1"># 父节点入栈</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="c1"># 深度优先，找最左节点，下个循环就是先访问父节点后左子节点</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>
        <span class="c1"># 这里需要好好体会，父节点和左子节点已经访问过，只剩下右节点</span>
        <span class="c1"># 所以就是先左后右</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<p>中序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Node</span> <span class="o">=</span> <span class="n">root</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">Node</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">Node</span><span class="p">:</span>
            <span class="c1"># 父节点入栈</span>
            <span class="c1"># 左子节点入栈</span>
            <span class="c1"># 但都不访问，因为压栈顺序是先父后左子，到出栈的时候再访问</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>

        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># 找到最左子节点了，开始出栈，所以肯定是先出左节点， 然后再出栈之后就是父节点</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># 最后就是右节点， 回到第一个while 继续找右子树的最左节点</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<p>后序的stack比较复杂</p>
<p>还有一个比较简单的先序stack
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Front_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># stack 先进后出，所以先压右节点</span>
        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
</code></pre></div></p>
<p>层序遍历,是广度优先的一种方式，所以使用到queue
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Layer_queue</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># 取前面的</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<h4 id="_7"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_7">后序栈遍历</a></h4>
<p>后序遍历的顺序是先左子后右子，最后才是父节点</p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">1. 同样先找到最左边的节点，父节点和左子节点入栈</span>
<span class="sd">2. 找到最后一个左子节点之后，判断栈顶的节点，出栈顺序是先左子后父节点，所以只需要判断右子节点的情况：</span>
<span class="sd">   如果栈顶节点的右子节点为空，直接打印栈顶节点。 如果栈顶节点的右子节点是上一个出栈的节点，那么说明已经访问到了右子节点，可以继续打印父节点  </span>
<span class="sd">   如果栈顶的右子节点不为空也不是上一个访问的节点，所以要先去访问右子树， 将右子节点入栈，退出循环，执行第一步</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">back_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Tag</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Tag</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">or</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
                <span class="n">Tag</span> <span class="o">=</span> <span class="n">Node</span>
            <span class="k">elif</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
                <span class="k">break</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-18 00:00:00+00:00">2020年11月18日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="docker-overlay-filesystem"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/">docker overlay filesystem</a></h2>
<p>overlay 是docker使用的文件系统，具有分层的特点, docker使用的文件系统经过很多变化，而且各发行版可能不同。<br />
执行<code>docker info</code> 查看当前使用的是overlay2</p>
<div class="highlight"><pre><span></span><code>sudo docker info | grep -i storage                                                                                                                                              
 Storage Driver: overlay2
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_1">历史</a></h3>
<p>除了 overlay，类似有rootfs， aufs （ubuntu）， devicemapper（centos），不够成熟的btrfs</p>
<p>他们都有2个目的：<br />
1. 提供不含内核的文件系统（rootfs）即容器, 在内核之上。这是docker 最有价值的地方，就是无论在那里运行docker， 容器里的环境都是一致的
2. 提供分层</p>
<h3 id="overlay"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay">overlay的优势</a></h3>
<ol>
<li>page caching， 可以在多个不同实例之间共享</li>
<li>写时复制， 只有执行write操作时， 会将lower layer 的文件复制到container层</li>
<li>不同层之间，相同文件使用硬连接， 节省inode 和 大小</li>
</ol>
<p>写时复制 copy-up 会导致第一次写时造成延迟，特别是大文件，拷贝起来费时。 但第二次就不会延时， 而且overlay2 有caching， 相比其它文件系统，更减少延时</p>
<h3 id="overlay_1"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay_1">overlay的问题</a></h3>
<ol>
<li>实现不够完全， 例如没有实现uname </li>
<li>先只读打开一个文件 open（read）， 再读写打开相同文件open（write）， 两个fd 会对应2个不同文件， 第一个对应的lower的文件，第二个造成写时复制，对应容器里的文件。 </li>
<li>规避方法是先执行touch 操作。 现实的例子是 yum 需要安装yum-plugin-ovl。 但这个只有7.2才支持， 之前的话就需要先<code>touch /var/lib/rpm/*</code></li>
</ol>
<h3 id="_2"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_2">最佳实践</a></h3>
<ol>
<li>使用ssd </li>
<li>对于写操作比较多的目录， 使用映射文件。这样跳过了overlay的复杂操作，直接使用主机的文件系统。</li>
</ol>
<h3 id="_3"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_3">分层介绍</a></h3>
<p>我理解就是将分离的多个目录挂载到一起的技术。
例如对docker 容器的文件进行增删改后，再commit， 会多一层layer。 
再当docker 容器启动时，会自动挂载多层layer。 
<strong><em>组织</em></strong>： overlay对运行的实例通过元数据组织文件， 是否是link文件 </p>
<div class="highlight"><pre><span></span><code>ls 04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/
diff  link  lower  merged  work
</code></pre></div>
<h4 id="mount"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#mount">手动mount的例子</a></h4>
<ol>
<li>原本目录，文件都分散在不同目录ABC
<div class="highlight"><pre><span></span><code>.
├── A
│   ├── aa
│   └── a.txt
├── B
│   ├── a.txt
│   └── b.txt
├── C
│   └── c.txt
└── worker
    └── work [error opening dir]
</code></pre></div></li>
<li>overlay 挂载到/tmp/test目录 <code>sudo mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /tmp/test/</code></li>
<li>查看test目录 
<div class="highlight"><pre><span></span><code>/tmp/test/
├── aa
├── a.txt
├── b.txt
└── c.txt
</code></pre></div>
<div class="highlight"><pre><span></span><code>mount  | grep &#39;overlay&#39;
overlay on /tmp/test type overlay (rw,relatime,lowerdir=A:B,upperdir=C,workdir=worker)
</code></pre></div></li>
</ol>
<h4 id="overlay_2"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay_2">overlay的增删改</a></h4>
<p>当运行docker容器时查看挂载</p>
<p><div class="highlight"><pre><span></span><code>overlay on /var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/merged type overlay 
(rw,relatime,
    lowerdir=/var/lib/docker/overlay2/l/B74PWZCBMRCWXFH5UL2ZXB5WEU:/var/lib/docker/overlay2/l/WNHICVPVSDNUGSCZW435TPSMOK,
    upperdir=/var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/diff,
    workdir=/var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/work
)
</code></pre></div>
docker 将镜像的文件挂载为只读， 将容器层挂载为可读可写。 文件系统可以分为2部分
upper（容器层） + lower （镜像层）</p>
<ul>
<li>当在容器里执行写时， 如果文件不存在， 会依次遍历lower。如果都不存在就会在upper层创建文件</li>
<li>读也相同</li>
<li>删除时会创建一个without 来隐藏， 这是为什么即使删除容器里的文件， 镜像还是会增大。 </li>
<li>删除目录情况也差不多</li>
</ul>
<p>似乎很奇怪，为什么多了一个workdir,  据说这个目录总是空的，为了实现原子操作添加和删除文件</p>
<h4 id="_4"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_4">特殊情况</a></h4>
<p>在修改容器后， 容器系统会多一层， 里面包含了修改的文件，以及删除后生成的without文件， 然后生成镜像</p>
<p>但对于以下特殊目录文件不会提交， 因为这些文件是运行时docker 要根据用户配置进行修改的。  </p>
<ol>
<li>/etc/hostname </li>
<li>/etc/hosts </li>
<li>/etc/resov.conf</li>
</ol>
<p>例如docker 的link选项，会在容器的hosts 文件里定义对应的容器名-&gt;容器ip</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-12 00:00:00+00:00">2020年11月12日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="connect-raspberry-and-arduino-via-i2c"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/">connect raspberry and arduino via i2c</a></h2>
<h3 id="_1"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#_1">准备</a></h3>
<p>先接线，然后启动 arduino, 最后在树莓派中验证和读写。</p>
<h4 id="gnd-sda-scl"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#gnd-sda-scl">连接两个设备的GND SDA SCL</a></h4>
<p>树莓派的SDA连arduino的SDA，SCL接SCL，这跟串口的接线不一样（RX接TX,TX接RX）。</p>
<p><img alt="alt text" src="../../img/arduino_nano_sda_scl_pins.png" /></p>
<p><img alt="alt text" src="../../img/raspberry_pi_zerow_sda_scl_pins.png" /></p>
<h4 id="arduino"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#arduino">启动arduino</a></h4>
<p>arduino 从端代码，注册了i2c的地址为0x08</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Wire.h&gt;</span>
<span class="cp">#define SLAVE_ADDRESS 0x08</span>
<span class="n">byte</span><span class="w"> </span><span class="n">data_to_echo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">SLAVE_ADDRESS</span><span class="p">);</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="n">receiveData</span><span class="p">);</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">onRequest</span><span class="p">(</span><span class="n">sendData</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">receiveData</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bytecount</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bytecount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data_to_echo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sendData</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data_to_echo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="i2c"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#i2c">树莓派开启i2c</a></h4>
<p>进入树莓派终端执行<code>raspi-config</code> 开启I2c功能，重启后执行命令<code>i2cdetect -y 1</code>，可以看到bus上的设备。</p>
<h4 id="master"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#master">树莓派的master端读写操作代码</a></h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/i2c-dev.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;i2c/smbus.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span>

<span class="cp">#define DEVICE_ID 0x08</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Setup I2C communication</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/i2c-1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to init I2C communication.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ioctl</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">I2C_SLAVE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE_ID</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I2C communication successfully setup.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Send data to arduino</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span>
<span class="w">    </span><span class="n">i2c_smbus_write_byte</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Read data from arduino</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">received_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_read_byte</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">received_data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Success!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-10 00:00:00+00:00">2020年11月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="c"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/">C的宏定义</a></h2>
<p>宏定义是在c/c++里特有的方式， 像变量一样， 又像模板编程一样， 但最常见的用法还是做头文件的唯一性保证  </p>
<p>在每一个头文件都套用这种格式，就可以避免多次引入头文件而导致的重复定义报错</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef FILE_NAME</span>
<span class="cp">#def FILE_NAME</span>

<span class="c1">// 代码</span>

<span class="cp">#endif FILE_NAME</span>
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_1">原理</a></h3>
<p>宏定义与变量、模板的最大区别在与处理的时期， 宏定义在预编译时处理， 而变量和模板函数则是在编译期处理。
查看预编译后的代码可以使用命令<code>gcc -E</code> 或者 <code>cpp</code>， 实际上是前者是调用了后者</p>
<div class="highlight"><pre><span></span><code>NAME
       cpp - The C Preprocessor
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_2">用法</a></h3>
<p>除了<code>#ifdef</code> 的用法，宏定义可以分两种类型，变量型和函数型</p>
<h4 id="_3"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_3">变量型</a></h4>
<p>这个最简单，就像使用变量一样，先define 然后再使用</p>
<p><div class="highlight"><pre><span></span><code><span class="cp"># marco.c</span>
<span class="cp">#define BUFFER_SIZE 1024</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="w"> </span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
执行 <code>gcc -E marco.c</code> 得到
<div class="highlight"><pre><span></span><code><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</code></pre></div></p>
<p>多行使用 '\' 来连接
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#define GREETING_STR \</span>
<span class="cp">  &quot;hello \</span>
<span class="cp">world&quot;</span>
</code></pre></div></p>
<ul>
<li>注意, 宏定义的定义不分前后， 也不像变量那样先定义再使用， 宏定义可以先使用后定义  </li>
</ul>
<p>以下两种方式的效果相同</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define GREETING_NAME &quot;wayou&quot;</span>

<span class="cp">#define GREETING &quot;hello,&quot; GREETING_NAME</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="n">printf</span><span class="p">(</span><span class="n">GREETING</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="gi">+#define GREETING &quot;hello,&quot; GREETING_NAME</span>

#define GREETING_NAME &quot;wayou&quot;

<span class="gd">-#define GREETING &quot;hello,&quot; GREETING_NAME</span>

int main() {
printf(GREETING);
return 0;
}
</code></pre></div>
<h4 id="_4"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_4">函数型</a></h4>
<p>函数类型的宏，可以像正常函数一样指定入参，入参需为逗号分隔合法的 C 字面量。
宏的参数必须要用括号包起来，否则当参数为表达式时，会出错</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">          </span><span class="err">→</span><span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">          </span><span class="err">→</span><span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w">    </span><span class="err">→</span><span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>
<span class="w"> </span><span class="err">```</span>

<span class="cp">### 宏定义字符串化</span>

<span class="n">当宏定义的参数被引号包起来时</span><span class="err">，</span><span class="w"> </span><span class="n">不会进行替换</span><span class="err">，</span><span class="n">如下</span>
<span class="err">```</span><span class="n">c</span>
<span class="cp">#define foo(x) x, &quot;x&quot;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w">        </span><span class="err">→</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span>
</code></pre></div>
<p>加入需要将参数替换到字符串里， 可以使用'#'  </p>
<div class="highlight"><pre><span></span><code><span class="cp">#define WARN_IF(EXP) \</span>
<span class="cp">do { if (EXP) \</span>
<span class="cp">        fprintf (stderr, &quot;Warning: &quot; #EXP &quot;\n&quot;); } \</span>
<span class="cp">while (0)</span>
<span class="n">WARN_IF</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">     </span><span class="err">→</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">           </span><span class="n">fprintf</span><span class="w"> </span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Warning: &quot;</span><span class="w"> </span><span class="s">&quot;x == 0&quot;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>而当 这里的x 也是宏定义时， 只有if里的x会替换， 字符串里的x则不会替换  </p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#define X ( 1 - 1 )</span>
<span class="n">WARN_IF</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
会被替换为  </p>
<div class="highlight"><pre><span></span><code><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">fprintf</span><span class="w"> </span><span class="p">(</span>
<span class="n">stderr</span>
<span class="p">,</span><span class="w"> </span><span class="s">&quot;Warning: &quot;</span><span class="w"> </span><span class="s">&quot;X == 0&quot;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<h4 id="_5"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_5">拼接</a></h4>
<p>通过 ## 可将两个宏展开成一个，即将两者进行了拼接，宏拼接一般用在需要拼接的宏是来自宏参数的情况，<br />
其他情况，大可直接将两个宏写在一起即可</p>
<p>当有以下情况时非常有用
<div class="highlight"><pre><span></span><code>struct command
{
  char *name;
  void (*function) (void);
};

struct command commands[] =
{
{ &quot;quit&quot;, quit_command },
{ &quot;help&quot;, help_command },
…
};
</code></pre></div></p>
<p>可以使用如下：
<div class="highlight"><pre><span></span><code><span class="cp">#define COMMAND(NAME)  { #NAME, NAME ## _command }</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">command</span><span class="w"> </span><span class="n">commands</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span>
<span class="p">{</span>
<span class="n">COMMAND</span><span class="w"> </span><span class="p">(</span><span class="n">quit</span><span class="p">),</span>
<span class="n">COMMAND</span><span class="w"> </span><span class="p">(</span><span class="n">help</span><span class="p">),</span>
<span class="err">…</span>
<span class="p">};</span>
</code></pre></div></p>
<h4 id="_6"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_6">不定参数和混合参数</a></h4>
<p>宏定义也可以使用不定参数
<div class="highlight"><pre><span></span><code><span class="cp">#define eprintf(args…) fprintf (stderr, args)</span>
<span class="c1">// or</span>
<span class="cp">#define eprintf(…) fprintf (stderr, __VA_ARGS__)</span>
</code></pre></div></p>
<p>也可以使用混合参数
<div class="highlight"><pre><span></span><code><span class="cp">#define eprintf(format, args...) fprintf (stderr, format, args)</span>
</code></pre></div>
这个可以常在格式化打印时用到， 例如 <code>spdlog</code> 库  </p>
<div class="highlight"><pre><span></span><code><span class="cp">#define SPDLOG_LOGGER_CALL(logger, level, ...)                                                                                             \</span>
<span class="cp">    if (logger-&gt;should_log(level))                                                                                                         \</span>
<span class="cp">    logger-&gt;log(spdlog::source_loc{SPDLOG_FILE_BASENAME(__FILE__), __LINE__, SPDLOG_FUNCTION}, level, __VA_ARGS__)</span>

<span class="cp">#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_TRACE</span>
<span class="cp">#define SPDLOG_LOGGER_TRACE(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::trace, __VA_ARGS__)</span>
<span class="cp">#define SPDLOG_TRACE(...) SPDLOG_LOGGER_TRACE(spdlog::default_logger_raw(), __VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define SPDLOG_LOGGER_TRACE(logger, ...) (void)0</span>
<span class="cp">#define SPDLOG_TRACE(...) (void)0</span>
<span class="cp">#endif</span>

<span class="cp">#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_DEBUG</span>
<span class="cp">#define SPDLOG_LOGGER_DEBUG(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::debug, __VA_ARGS__)</span>
<span class="cp">#define SPDLOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define SPDLOG_LOGGER_DEBUG(logger, ...) (void)0</span>
<span class="cp">#define SPDLOG_DEBUG(...) (void)0</span>
<span class="cp">#endif</span>
</code></pre></div>
<h3 id="_7"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_7">重复和覆盖</a></h3>
<p>这些是相似的：
<div class="highlight"><pre><span></span><code><span class="cp">#define FOUR (2 + 2)</span>
<span class="cp">#define FOUR         (2    +    2)</span>
<span class="cp">#define FOUR (2 </span><span class="cm">/* two */</span><span class="cp"> + 2)</span>
</code></pre></div></p>
<p>以下都是不同的宏
<div class="highlight"><pre><span></span><code><span class="cp">#define FOUR (2 + 2)</span>
<span class="cp">#define FOUR ( 2+2 ) </span><span class="c1">// 空白位置不一样 </span>
<span class="cp">#define FOUR (2 * 2) </span><span class="c1">// 宏的内容不一样</span>
<span class="cp">#define FOUR(score,and,seven,years,ago) (2 + 2) </span><span class="c1">// 入参不一样</span>
</code></pre></div></p>
<p>对于使用了 <code>#undef</code> 注销过的宏，再次定义同名的宏时，要求新定义的宏不与老的相似。</p>
<p>而如果说一个已经存在的宏，并没有注销，重复定义时，如果相似，则新的定义会忽略，如果不相似，编译器会报警告同时使用新定义的宏。这允许在多个文件中定义同一个宏。</p>
<h3 id="_8"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_8">最后</a></h3>
<p>可以查看更多<a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros">内置宏定义</a></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-10 00:00:00+00:00">2020年11月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="python"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/">python 包的管理</a></h2>
<p>python 有 sdist 和 wheel 两种方式管理包：</p>
<p>sdist 是在 <code>python setup.py sdist</code>时产生的包，是一个源码压缩包，在安装时需要编译，所以环境依赖make和gcc<br />
wheel 是在<code>python setup.py  bdist_wheel</code>是产生的whl 格式包</p>
<p>从命令都可以看出来sdist即source源码包， bdist 即binary二进制包  </p>
<p>sdist 由distutils、setuptools 定义和依赖的编译系统， 可以运行任意的代码<br />
wheel 包为编译和安装时提供了简单的接口，里面包含了二进制的包，可以让安装者不需要知道编译体系,依赖wheel
<div class="highlight"><pre><span></span><code>pip install wheel
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/#_1">两种包的打包命令</a></h3>
<p>前提是环境安装了setuptools和wheel, 且编写了setup.py文件如  </p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># setup.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">setuptools</span><span class="w"> </span><span class="kn">import</span> <span class="n">setup</span><span class="p">,</span><span class="n">find_namespace_packages</span>
<span class="c1">#import pathlib</span>
<span class="c1">#import pkg_resources</span>
<span class="c1">#import os</span>
<span class="c1">#import sys</span>

<span class="c1">#sys.path.insert(0, os.path.join(</span>
<span class="c1">#    os.path.dirname(os.path.abspath(__file__)), &#39;src&#39;))</span>

<span class="c1"># 解析文本文件</span>
<span class="c1">#with pathlib.Path(&#39;requirements.txt&#39;).open() as requirements_txt:</span>
<span class="c1">#    install_requires = [str(requirement) for requirement in pkg_resources.parse_requirements(requirements_txt) ]</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;myflask&#39;</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.3&#39;</span><span class="p">,</span>
      <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
            <span class="s1">&#39;Bootstrap-Flask==1.4&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Flask==1.1.2&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Flask-Login==0.5.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;SQLAlchemy==1.3.18&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Werkzeug==1.0.1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;WTForms==2.3.1&#39;</span>
          <span class="p">],</span>
      <span class="n">entry_points</span><span class="o">=</span><span class="p">{</span>
             <span class="s1">&#39;console_scripts&#39;</span><span class="p">:[</span>
                   <span class="s1">&#39;myflask=wsgi:main&#39;</span>
                   <span class="p">]</span>
            <span class="p">},</span>
      <span class="n">package_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.html&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.css&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.js&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;static/*&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;templates/*&#39;</span><span class="p">],</span>
      <span class="p">},</span>
      <span class="n">py_modules</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;myflask&#39;</span><span class="p">],</span>
      <span class="n">packages</span><span class="o">=</span><span class="n">find_namespace_packages</span><span class="p">(),</span>
      <span class="n">zip_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
      <span class="n">include_package_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
      <span class="p">)</span>
</code></pre></div>
我这里定义了安装模块，myflask,可以被uwsgi 文件引入，方便管理， 同时也加入了很多html的静态文件， 是一个完整的网站  </p>
<ol>
<li>
<p>生成sdist包， 在项目目录执行<code>python setup.py sdist</code>，可以在sdit目录看到tar包
<div class="highlight"><pre><span></span><code><span class="c1"># myflask &gt; ls dist                                                                                                                                                                                                      </span>
myflask-1.3.tar.gz
</code></pre></div></p>
</li>
<li>
<p>生成wheel包，在项目目录执行<code>python setup.py bdist_wheel</code>，可以在sdit目录看到whl包
<div class="highlight"><pre><span></span><code># myflask &gt; ls dist
myflask-1.3-py3-none-any.whl  myflask-1.3.tar.gz
</code></pre></div></p>
</li>
</ol>
<h3 id="_2"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/#_2">安装</a></h3>
<p>安装命令相同，<code>pip install myflask-1.3.tar.gz</code> <code>pip instal myflask-1.3-py3-none-any.whl</code>。但过程不同</p>
<p>举例安装yarl 的源码包, 源码包需要编译，如果环境没有gcc,就会安装失败
<div class="highlight"><pre><span></span><code>Collecting yarl&lt;2.0,&gt;=1.0 (from aiohttp==3.6.2)
  Downloading yarl-1.6.2.tar.gz (177kB)
  Installing build dependencies: started
  Installing build dependencies: finished with status &#39;done&#39;
  Getting requirements to build wheel: started
  Getting requirements to build wheel: finished with status &#39;done&#39;
    Preparing wheel metadata: started
    Preparing wheel metadata: finished with status &#39;done&#39;
...

  gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/opt/ha/include/python3.8 -c yarl/_quoting_c.c -o build/temp.linux-x86_64-3.8/yarl/_quoting_c.o
  error: command &#39;gcc&#39; failed with exit status 1
  ----------------------------------------
  ERROR: Failed building wheel for yarl
  Running setup.py clean for yarl
Failed to build yarl
</code></pre></div></p>
<p>此时，如果使用wheel包就不会出问题，但如果wheel包里面依赖了二进制文件，则需要区分cpu架构和系统了<br />
我的myflask不依赖任何二进制文件，所以是none, 所有cpu和系统都可以安装<br />
<div class="highlight"><pre><span></span><code>myflask-1.3-py3-none-any.whl 
</code></pre></div>
对于yarl不同， 在pypi.org 下载时，需要选择正确的包。或者选择源码包<code>yarl-1.6.2.tar.gz</code>来安装编译  </p>
<p>当然如果让pip选择在线安装就不需要考虑， 他会自动帮你寻找对应你系统的版本</p>
<div class="highlight"><pre><span></span><code>Download files

Download the file for your platform. If you&#39;re not sure which to choose, learn more about installing packages.
Files for yarl, version 1.6.2
Filename, size  File type   Python version  Upload date     Hashes
yarl-1.6.2-cp36-cp36m-macosx_10_14_x86_64.whl (128.3 kB)    Wheel   cp36    Oct 13, 2020    View
yarl-1.6.2-cp36-cp36m-manylinux1_i686.whl (293.5 kB)    Wheel   cp36    Oct 13, 2020    View
yarl-1.6.2-cp36-cp36m-manylinux2014_aarch64.whl (294.5 kB)  Wheel   cp36    Oct 13, 2020    View

...

yarl-1.6.2.tar.gz (177.5 kB)    Source  None    Oct 13, 2020    View 
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-09 00:00:00+00:00">2020年11月9日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="system-calls-method"><a class="toclink" href="../../2020/11/09/system-calls-method/">system calls method</a></h2>
<p>之前学汇编发现教材和实际的有出入， 书上写的int, 但是汇编不通过，而gcc 反汇编的结果是调用syscall。<br />
原来这是两种方式调用方式即： int  0x80 和 syscall  </p>
<p>除此之外还有一个名词是vdso,  很多elf文件会链接这个vdso库</p>
<div class="highlight"><pre><span></span><code>ldd a.out                                                                                                                                                                                                                   √ 19:03:30 
    linux-vdso.so.1 (0x00007fffb3de0000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f5b48d4a000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5b48f36000)
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/09/system-calls-method/#_1">词汇说明</a></h3>
<p><code>int 0x80</code> 即80中断， 是最老的系统函数调用方式
<code>syscall/sysret</code> 是amd64 制定的标准， 也是目前的x86 64位的标准，即<code>amd64</code>
<code>sysenter/syssysexit</code> 是inter制定的x86 64位标准， 目前已被放弃
<code>vdso</code> 是linux内核虚拟出的so, 实现了int 80 和 syscall，调用方式为 <code>vsyscall</code></p>
<h3 id="_2"><a class="toclink" href="../../2020/11/09/system-calls-method/#_2">系统函数调用路径</a></h3>
<p>系统调用多被封装成库函数提供给应用程序调用，应用程序调用库函数后，由 glibc 库负责进入内核调用系统调用函数。
即<code>用户函数-&gt; glibc -&gt; 系统调用</code></p>
<h3 id="int-0x80"><a class="toclink" href="../../2020/11/09/system-calls-method/#int-0x80">int 0x80</a></h3>
<p>int 即是interrupt 中断， 0x80是IDT上注册的中断向量， 每个编号对应一个处理函数handle， linux的0x80的handle即是内核，即系统调用。
所以不同的系统设置的0x80的handle可能不同</p>
<p>调用方式：首先是将参数复制到寄存器， 参数包括系统调用编号和传入参数，然后执行 init  0x80 
例如，以下的进程退出的系统调用
<div class="highlight"><pre><span></span><code>.data
    s:
        .ascii &quot;hello world\n&quot;
        len = . - s
.text
    .global _start
    _start:

        movl $4, %eax   /* write system call number */
        movl $1, %ebx   /* stdout */
        movl $s, %ecx   /* the data to print */
        movl $len, %edx /* length of the buffer */
        int $0x80

        movl $1, %eax   /* 退出的系统调用编号 */
        movl $0, %ebx   /* exit status */
        int $0x80
</code></pre></div></p>
<h3 id="vdos"><a class="toclink" href="../../2020/11/09/system-calls-method/#vdos">vdos</a></h3>
<p>vdos即 linux-vdso.so.1， 几乎很多elf 都会链接这个库，但其实他并不是真实存在的so文件，<br />
而是由内核虚拟的文件，再映射到用户的进程来调用。</p>
<p>vdos  是对以下几个函数的实现，称作快速调用</p>
<div class="highlight"><pre><span></span><code>#define __NR_gettimeofday 96 //0x60
#define __NR_time 201 //0xc9
#define __NR_clock_gettime 228 //0xE4
#define __NR_getcpu 309 //0x135
</code></pre></div>
<h3 id="_3"><a class="toclink" href="../../2020/11/09/system-calls-method/#_3">对比</a></h3>
<p>所以以上总结其实就3种方式， int ，syscall/sysret ， vdso</p>
<p>int 0x80 方式很慢，所以出现了syscall 即快速调用</p>
<p>执行区别
<div class="highlight"><pre><span></span><code>在 x86 保护模式中，处理 INT 中断指令时，CPU 首先从中断描述表 IDT 取出对应的门描述符，判断门描述符的种类，然后检查门描述符的级别 DPL 和 INT 指令调用者的级别 CPL，当 CPL&lt;=DPL 也就是说 INT 调用者级别高于描述符指定级别时，才能成功调用，最后再根据描述符的内容，进行压栈、跳转、权限级别提升。内核代码执行完毕之后，调用 IRET 指令返回，IRET 指令恢复用户栈，并跳转会低级别的代码。

其实，在发生系统调用，由 Ring3 进入 Ring0 的这个过程浪费了不少的 CPU 周期，例如，系统调用必然需要由 Ring3 进入 Ring0（由内核调用 INT 指令的方式除外，这多半属于 Hacker 的内核模块所为），权限提升之前和之后的级别是固定的，CPL 肯定是 3，而 INT 80 的 DPL 肯定也是 3，这样 CPU 检查门描述符的 DPL 和调用者的 CPL 就是完全没必要。正是由于如此，Intel x86 CPU 从 PII 300（Family 6，Model 3，Stepping 3）之后，开始支持新的系统调用指令 sysenter/sysexit。sysenter 指令用于由 Ring3 进入 Ring0，SYSEXIT 指令用于由 Ring0 返回 Ring3。由于没有特权级别检查的处理，也没有压栈的操作，所以执行速度比 INT n/IRET 快了不少。
</code></pre></div></p>
<p>返回的区别
<div class="highlight"><pre><span></span><code>在 Intel 的手册中，还提到了 sysenter/sysexit 和 int n/iret 指令的一个区别，那就是 sysenter/sysexit 指令并不成对，sysenter 指令并不会把 SYSEXIT 所需的返回地址压栈，sysexit 返回的地址并不一定是 sysenter 指令的下一个指令地址。调用 sysenter/sysexit 指令地址的跳转是通过设置一组特殊寄存器实现的。
</code></pre></div></p>
<p>vdos的局限（syscall）
<div class="highlight"><pre><span></span><code>而&quot;快速系统调用指令&quot;比起中断方式的系统调用方式，还存在一定局限，例如无法在一个系统调用处理过程中再通过&quot;快速系统调用指令&quot;调用别的系统调用。因此，并不一定每个系统调用都需要通过&quot;快速系统调用指令&quot;来实现。比如，对于复杂的系统调用例如 fork，两种系统调用方式的时间差和系统调用本身运行消耗的时间来比，可以忽略不计，此处采取&quot;快速系统调用指令&quot;方式没有什么必要。而真正应该使用&quot;快速系统调用指令&quot;方式的，是那些本身运行时间很短，对时间精确性要求高的系统调用，例如 getuid、gettimeofday 等等。
</code></pre></div></p>
<h3 id="_4"><a class="toclink" href="../../2020/11/09/system-calls-method/#_4">最后总结</a></h3>
<p>int 是最老的方式，目前用amd64的 syscall 方式， 而vdso是基于syscall实现的快速调用。<br />
只有在调用clock_gettime、gettimeofday、getcpu、time这些系统调用时，才会使用vdso，其他系统调用是通过syscall实现的</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-05 00:00:00+00:00">2020年11月5日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="huawei-unlock-bootloader"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/">huawei unlock bootloader</a></h2>
<p>解锁华为平板M3的BL锁，以及获取root权限</p>
<h2 id="_1"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_1">背景</a></h2>
<p>我有一个华为平板M3，WIFI版, 型号BTV-W09，系统是emui5， 买来没什么用，最大的功能就是看视频。 偶尔发现一个app，LinuxDeploy, 可以在安卓上安装完整的Linux系统，而不是内置的阉割版， 前提是获得root权限。</p>
<h2 id="_2"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_2">步骤</a></h2>
<p>全部步骤分4个： <br />
1. 解BL
2. 刷入recovery 也就是RTWP
3. 将root压缩包复制到平板，在RTWP下安装
4. 安装supersu 的apk
5. 可选刷入xposed框架，并安装xposed manager，步骤参考3,4</p>
<h3 id="_3"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_3">解锁</a></h3>
<p>因为华为官方停止申请解锁BL的服务， 所以需要上淘宝找人帮你搞定。 解锁BL之后， 在关机状态按住电源和音量减，进入fastboot模式时，有红字提示unlocked</p>
<h3 id="rec"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#rec">刷入rec</a></h3>
<p>找到与设备型号对应的rec非常重要，因为型号不对会刷不进去，我尝试了很多个版本，最终在华为论坛找到了。 
有了rec后， 让手机处于fastboot状态， 连接手机到电脑，使用 <code>fastboot flash recovery rec</code> 来刷入 ，提书刷入成功之后，可能自动重启，如果没有重启，长按电源键强制关机。 <br />
关机状态下， 按住电源键和音量+，进入recovery ， 能看到RTWP的界面说明输入成功，如果没有看到RTWP,而是进入华为官方的eRecovery 表示失败，又可能是被华为覆盖了。
一旦能进入RTWP, 那么RTWP会自动安装，以后就不用担心被覆盖的问题。</p>
<h3 id="root"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#root">刷入root工具</a></h3>
<p>将root.zip 拷贝到平板的储存卡目录，进入RTWP，点INSTALL,  然后选择root.zip 就会开始安装了， 安装后再安装supersu 的应用</p>
<p>这样就root成功了， 所以步骤很简单，找到对应机型的rec 很关键。 </p>
<h3 id="xposed"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#xposed">刷入xposed</a></h3>
<p>xposed 很强大，但是xposed只是个框架，需要安装包来实现对app的hack。但是我安装完，没发现什么很强大包，感觉也没什么用。 </p>
<h3 id="_4"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_4">更新</a></h3>
<p>平板一直都在吃灰，最近发现访问网站都报证书错误，可能是系统旧了(后面发现是电池馈电太久，时间不同步)，所以决定升级系统。这次完整贴出命令，因为发现我之前写的难以参考。在XDA网站发现有新的lineage17适合btv-w09,于是按照帖子里面的方法做：
1. 下载TWRP 3.3.1-1，lineage 17 系统压缩包， boot 镜像，我的是wifi-only版本。
2. 在平板关闭状态下，按住电源+音量减，振动的时候释放电源键，然后就进入fastboot状态，显示<code>phone unlock</code>
3. 刷入twrp <code>fastboot flash recovery twrp-xxx.img</code>
4. 刷入boot <code>fastboot flash boot boot-xxx.img</code>
5. 进入twrp，这里有点迷惑，网上说（包括我之前说的）按住电源+音量加总是无法进入twrp而是进入了华为的eRecovery,使用<code>adb boot-recovery</code>则进入了正常系统。最后发现在开发者模式下开启<code>高级重启</code>功能，重启的时候选择重启到<code>recovery</code>则能正常进入Twrp界面。可能是平板接着USB线。
6. 帖子上说了，升级lineage需要Wipe，彻底初始化但保留系统，执行后连sdcard目录也会格式化，剩几个标准目录。
7. 用adb push 将系统安装压缩包发送到平板的存储空间，<code>adb push Lineage-xxx.zip /sdcard</code>，然后在TWRP中选择 Install，选择这个zip 进行安装。 不过发现这个zip文件校验失败，不管他了。</p>
<p>然后就重启进入新版本的Lineage 17(android 10)，可惜的是没有相机功能。</p>
<h3 id="2025lineageos20"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#2025lineageos20">2025年重新刷lineageos20</a></h3>
<p>同样问题又出现了</p>
<ol>
<li>进入 fastboot 模式 <code>adb reboot bootloader</code>， 如今没有adb reboot fastboot命令了， fastboot模式和bootloader模式应该是一样的</li>
<li>刷入新的recovery <code>fastboot flash recovery ~/Downloads/recovery.img</code></li>
<li>进入recovery，格式化data分区</li>
<li>在recovery中点击Apply Update， 再点击Apply from ADB， 执行线刷</li>
<li>在电脑输入<code>adb sideload ~/Downloads/lineage-20.0-20250102-RELEASE-btvw09.zip</code></li>
</ol>
<p>但是第5步出现错误
<div class="highlight"><pre><span></span><code>adb sideload ~/Downloads/lineage-20.0-20250102-RELEASE-btvw09.zipmain  
adb: sideload connection failed: insufficient permissions for device: missing udev rules? user is in the plugdev group
See [http://developer.android.com/tools/device.html] for more information
adb: trying pre-KitKat sideload method...
adb: pre-KitKat sideload connection failed: insufficient permissions for device: missing udev rules? user is in the plugdev group
See [http://developer.android.com/tools/device.html] for more information 
</code></pre></div></p>
<p>查看设备情况提示
<div class="highlight"><pre><span></span><code>adb devices
List of devices attached
SLYDU17401001667        no permissions (missing udev rules? user is in the plugdev group); see [http://developer.android.com/tools/device.html]
</code></pre></div></p>
<p>网上查找解决办法，尝试了好几个，最终通过
<div class="highlight"><pre><span></span><code><span class="c1"># 添加udev规则</span>
cat<span class="w"> </span>/etc/udev/rules.d/51-android.rules
<span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;usb&quot;</span>,<span class="w"> </span>ATTR<span class="o">{</span>idVendor<span class="o">}==</span><span class="s2">&quot;id_you_copied&quot;</span>,<span class="w"> </span><span class="nv">MODE</span><span class="o">=</span><span class="s2">&quot;0666&quot;</span>,<span class="w"> </span><span class="nv">GROUP</span><span class="o">=</span><span class="s2">&quot;plugdev&quot;</span>

sudo<span class="w"> </span>chmod<span class="w"> </span>a+r<span class="w"> </span>/etc/udev/rules.d/51-android.rules
sudo<span class="w"> </span>udevadm<span class="w"> </span>control<span class="w"> </span>--reload-rules
sudo<span class="w"> </span>udevadm<span class="w"> </span>trigger
</code></pre></div></p>
<p>上面还是不行，最后拔掉usb线又重新插入就正常了</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-10-30 00:00:00+00:00">2020年10月30日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="install-kvm-on-debian-of-aarch64-architecture"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/">Install KVM on Debian of aarch64 architecture</a></h2>
<p>公司有台arm64位的设备，安装的银河麒麟系统，经验证就是debian 9。<br />
现在需要运行更多arm64虚拟机。</p>
<h2 id="_1"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#_1">安装步骤</a></h2>
<h3 id="sudoer"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#sudoer">配置免密sudoer</a></h3>
<p>这里记一个坑， 第一次配置时拼写错误，导致sudo 命令执行失败。需要重置密码，所以很麻烦。 <br />
然后推荐使用 <code>sudo visudo</code> 命令来修改sudoer配置文件，这个命令在编辑结束后校验配置文件，避免出现编辑错误导致无法使用sudo的情况。  </p>
<div class="highlight"><pre><span></span><code>kylin@Kylin:~$ cat /etc/sudoers.d/kylin 
kylin   ALL=(ALL:ALL) NOPASSWD:ALL
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#_2">配置软件源</a></h3>
<p>第一个是本地iso, 下面的是中科大的镜像源。 每个都设置了trust免校验gpg</p>
<div class="highlight"><pre><span></span><code>deb [trusted=yes] file:///mnt/iso/ juniper main multiverse restricted universe
deb [trusted=yes] http://ftp.cn.debian.org/debian/ stretch main contrib non-free
deb [trusted=yes] http://ftp.cn.debian.org/debian/ stretch-updates main contrib non-free
deb [trusted=yes] http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free
deb [trusted=yes] http://ftp.cn.debian.org/debian/ stretch-backports main contrib non-free 
</code></pre></div>
<h3 id="_3"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#_3">安装虚拟工具</a></h3>
<p>安装 qemu, libvirt, virt-manager</p>
<div class="highlight"><pre><span></span><code>sudo apt install  qemu  libvirt virt-manager
</code></pre></div>
<h3 id="libvirt"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#libvirt">libvirt 没有网络</a></h3>
<p>执行<code>virsh net-list -all</code> 发现default 网络处于未激活状态， 于是执行 <code>systemctl status libvirtd</code> 发现</p>
<p><div class="highlight"><pre><span></span><code>10月 30 15:46:27 Kylin libvirtd[16741]: 2020-10-30 07:46:27.262+0000: 16764: error : virFileReadAll:1420 : 打开文件 &#39;/sys/class/net/virbr0-nic/operstate&#39; 失败: 没有那个文件或目录
10月 30 15:46:27 Kylin libvirtd[16741]: 2020-10-30 07:46:27.262+0000: 16764: error : virNetDevGetLinkInfo:2530 : unable to read: /sys/class/net/virbr0-nic/operstate: 没有那个文件或目录
10月 30 15:46:54 Kylin libvirtd[16741]: 2020-10-30 07:46:54.710+0000: 16745: error : virFirewallApply:916 : 内部错误：Failed to initialize a valid firewall backend
</code></pre></div>
需要安装以下组件，然后重启libvirtd，这是因为libvirt的网络依赖这几个组件来创建nat 网络</p>
<div class="highlight"><pre><span></span><code>sudo apt install ebtables iptables dnsmasq
systemctl restart libvirtd
</code></pre></div>
<h3 id="virt-manager-aarch64-uefi"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#virt-manager-aarch64-uefi">virt-manager 提示aarch64 安装 uefi 错误</a></h3>
<p>直接安装 qemu-efi
<div class="highlight"><pre><span></span><code>apt install qemu-efi
</code></pre></div></p>
<h3 id="virt-manager-root"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#virt-manager-root">virt-manager 允许非root用户访问</a></h3>
<p>因为当以普通用户运行 virt-manager 时，qemu的连接指向非qemu:///system， 这时看到的虚拟机和root看到的不一样，所以必须使用sudo运行。
通过修改配置来启用普通用户也访问<code>qemu:///system</code>， 将uri_defualt 的注释去掉。</p>
<div class="highlight"><pre><span></span><code>vim /etc/libvirt/libvirt.conf 

#
# These can be used in cases when no URI is supplied by the application
# (@uri_default also prevents probing of the hypervisor driver).
#
uri_default = &quot;qemu:///system&quot;
</code></pre></div>
<h2 id="virt-managerx86"><a class="toclink" href="../../2020/10/30/install-kvm-on-debian-of-aarch64-architecture/#virt-managerx86">这样就可以使用virt-manager来创建虚拟机了，跟x86的使用一样。</a></h2>
<p>顺便记一下vnc的配置， 因为机器在机房里， 通过tigervnc来使用桌面。<br />
另外提示一下，virt-manager 配置好后，可以直接连接远程的virt-manager,非常方便。</p>
<p>使用tigervnc 连接需要在远程主机安装 tigervnc-server 和 tigervnc-password。
使用普通用户执行 <code>tigervnc-password</code> 设置访问密码，然后直接执行<code>tigervnc-server</code>。</p>
<p>这时候vnc只接受本地连接， 如果远程访问，要使用ssh 本地转发来实现。 这也是vnc推荐的方式。</p>
<p>现在本地允许本地转发命令， 监听本地端口 9302, 转发到远程的 9300
<div class="highlight"><pre><span></span><code>ssh -L 9302:localhost:9300   -N -f  ssh-kylin
</code></pre></div></p>
<p>然后执行 <code>vncviewer  127.0.0.1:9302</code> ，输入密码就能打开远程桌面了。</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-10-22 00:00:00+00:00">2020年10月22日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="lvm"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/">LVM 功能介绍</a></h2>
<p>LVM 是在硬件和系统之间多加了一层，可以很方便地修改分区和扩容。 从效率上看肯定有所损失的，但是对于企业而言，灵活性也很重要<br />
LVM具有在线扩容和快照的重要功能</p>
<h3 id="_1"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_1">在线扩容</a></h3>
<p>当磁盘容量不够或者需要替换磁盘时，就需要扩容, 如果是替换磁盘就再需要换出旧硬盘</p>
<h4 id="_2"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_2">扩容步骤</a></h4>
<p>使用lvm中的pvmove 命令假如原来是使用pv 为/dev/sda1, 新的硬盘为/dev/sdb1<br />
1. 新建pv: # pvcreate /dev/sdb1 
2. 扩容vg：# vgextend vg1 /dev/sdb1 
3. 如果要调整分区大小，使用lvresize -r -S 新大小。 不带-r的话需要重新mount才能生效， -S 是表示最终大小，-s +/- 是调整大小</p>
<h4 id="_3"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_3">换出步骤</a></h4>
<p>vgreduce 是将pv踢出vg, pvremove是删除pv标记</p>
<ol>
<li>把sda1 上数据迁移到sdb1上： # pvmove  /dev/sda1  /dev/sdb1 </li>
<li>vgreduce 从vg1踢出sda1盘 # vgreduce vg1 /dev/sda1  </li>
<li>pvremove 删除磁盘分区的pv 标记 # pvremove /dev/sda1 </li>
</ol>
<h4 id="_4"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_4">磁盘换出是否需要停业务</a></h4>
<p>LVM的在线扩容是不需要停止业务的，但是应该在业务闲的时候做。LVM在做pvmove的时候，会冻结旧分区，新的操作就需要做备份。 
pvmove有时候很慢，但是不能中断，否则出现很多遗留的分区。 </p>
<p>与pvmove类似的功能的还有磁盘镜像， 磁盘镜像的好处很明显，即使复制失败了，原数据依然存在。</p>
<p>但两个技术都要求能够“原子化”，所以不得不对业务有所影响，而且影响的是磁盘IO， 无法通过降低业务的NICE值来减弱这种影响</p>
<h3 id="lvm_1"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#lvm_1">LVM 快照功能</a></h3>
<p>当系统是安装在LVM文件系统之上，那么当需要进行高危操作的时候，可以先对分区进行快照备份，避免操作失败又无法恢复。
公司有一台centos7的自用系统， 需要升级到Centos8 以支持 Docker buildx。
虽然因操作到无法运行yum,dnf 时宣布失败，但好在有snapshot备份， 恢复后完好如初，太好用。</p>
<h4 id="_5"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_5">步骤</a></h4>
<ol>
<li>挂载如下</li>
</ol>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>lsblk<span class="w"> </span>
NAME<span class="w">                  </span>MAJ:MIN<span class="w"> </span>RM<span class="w">   </span>SIZE<span class="w"> </span>RO<span class="w"> </span>TYPE<span class="w">  </span>MOUNTPOINT
sda<span class="w">                     </span><span class="m">8</span>:0<span class="w">    </span><span class="m">0</span><span class="w">   </span>477G<span class="w">  </span><span class="m">0</span><span class="w"> </span>disk<span class="w">  </span>
├─sda1<span class="w">                  </span><span class="m">8</span>:1<span class="w">    </span><span class="m">0</span><span class="w">   </span>200M<span class="w">  </span><span class="m">0</span><span class="w"> </span>part<span class="w">  </span>/boot/efi
├─sda2<span class="w">                  </span><span class="m">8</span>:2<span class="w">    </span><span class="m">0</span><span class="w">     </span>1G<span class="w">  </span><span class="m">0</span><span class="w"> </span>part<span class="w">  </span>/boot
└─sda3<span class="w">                  </span><span class="m">8</span>:3<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">475</span>.8G<span class="w">  </span><span class="m">0</span><span class="w"> </span>part<span class="w">  </span>
<span class="w">  </span>├─centos-root<span class="w">       </span><span class="m">253</span>:2<span class="w">    </span><span class="m">0</span><span class="w">    </span>50G<span class="w">  </span><span class="m">0</span><span class="w"> </span>lvm<span class="w">   </span>/
<span class="w">  </span>├─centos-swap<span class="w">       </span><span class="m">253</span>:4<span class="w">    </span><span class="m">0</span><span class="w">  </span><span class="m">15</span>.7G<span class="w">  </span><span class="m">0</span><span class="w"> </span>lvm<span class="w">   </span><span class="o">[</span>SWAP<span class="o">]</span>
<span class="w">  </span>├─centos-docker<span class="w">     </span><span class="m">253</span>:18<span class="w">   </span><span class="m">0</span><span class="w">   </span>150G<span class="w">  </span><span class="m">0</span><span class="w"> </span>lvm<span class="w">   </span>/var/lib/docker
</code></pre></div>
<p>根分区为50G, 而卷组还剩余160G,完全足够生成一个镜像，50G并未完全使用。
<div class="highlight"><pre><span></span><code>$ sudo vgs
  VG     #PV #LV #SN Attr   VSize   VFree   
  centos   1   4   0 wz--n- 475.74g  160.05g
  data     1  13   0 wz--n-  &lt;7.28t &lt;721.91g
</code></pre></div></p>
<ol>
<li>
<p>先对根分区进行快照，注意是<code>根分区</code>
<div class="highlight"><pre><span></span><code># lvcreate -s -n &lt;snapshot_name&gt; -L &lt;size&gt; &lt;logical_volume&gt;

$ lvcreate -s -n backup -L 50G  /dev/centos/root
</code></pre></div>
这里指定了快照的大小为50G, 理论上是要比源分区大， 这里也可以直接设置100G, 系统会自动调整大小到合适。</p>
</li>
<li>
<p>进行一顿操作后， 进行恢复, 提示根分区正在使用， 重启后生效。</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>$ lvconvert --mergesnapshot /dev/centos/backup 
  Delaying merge since origin is open.
  Merging of snapshot centos/backup will occur on next activation of centos/root.
</code></pre></div>
<h4 id="_6"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_6">保存</a></h4>
<p>如果需要对快照进行备份到其他位置， 可以直接将快照分区挂载，然后通过tarball 来压缩。</p>
<div class="highlight"><pre><span></span><code>tar -cvzf backup.tar.gz /mnt/lv_snapshot
</code></pre></div>
<p>还可以直接通过rsync 将挂载的snapshort 传输到其他服务器上</p>
<div class="highlight"><pre><span></span><code>rsync -aPh /mnt/lv_snapshot  &lt;remote_user&gt;@&lt;destination_server&gt;:&lt;remote_destination&gt;
</code></pre></div>
<h4 id="_7"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_7">快照回滚</a></h4>
<p>lvm的snapshort 也是写时复制的（copy on write），所以创建快照操作非常快， 
当分区进行删除和修改操作的时候， lvm文件系统会拷贝文件到其他地方保存。</p>
<h4 id="_8"><a class="toclink" href="../../2020/10/22/lvm-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/#_8">问题</a></h4>
<p>lvm快照不等于备份， 仅有快照是不能恢复的</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-10-19 00:00:00+00:00">2020年10月19日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="linux"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/">Linux 中断请求</a></h2>
<p>中断请求的英文是IRQ（Interrupt Request）,是用来驱动CPU正常工作的重要机制。 中断根据源头分类成：
由外设发出的硬件中断，软件发出的软中断，以及异常组成。</p>
<p>以前，每个外设都连接一根线到PIC(programmable Interrupt circuit)芯片，有PIC芯片来发生数据到CPU,并将CPU的INTR引脚置位。
现在，CPU集成了PIC成为APIC(Advanced PIC)。</p>
<h3 id="_1"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_1">中断分类</a></h3>
<p>中断分为3类型</p>
<h4 id="_2"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_2">硬件中断</a></h4>
<p>鼠标和键盘，还有IO设备都会发出硬件中断，例如网卡的数据到了，就会出发中断请求（IRQ），
这个请求会触发CPU去执行ISR, 而这个ISR需要在系统启动的时候注册的。一个Vector表。</p>
<h3 id="_3"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_3">软件中断</a></h3>
<p>当播放电影的时候，声音和画面的同步非常重要，这是由系统的定时器<a href="https://elinux.org/Kernel_Timer_Systems">jiffies</a>来不停地调度声音播放器来准确播放对应的声音。
软中断在实时操作系统的作用也非常重要。</p>
<h4 id="_4"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_4">异常中断</a></h4>
<p>异常中断又分为3类： 缺页异常(Faults)，陷入异常(Traps)，异常退出(Aborts)</p>
<p>例如当程序的内存被swap到硬盘了或者一段动态链接库还没有载入到内存里来，在程序走到这个位置之前，
程序就会提前发出缺页异常，当系统检查了权限和地址有效后（地址有效表示在逻辑地址范围内），
CPU开始为程序执行加载需要的数据，并清除这个异常。 所以这个异常是可以修正的，这个请求必须提前发出。</p>
<p>当GDB调试的时，设置断点会插入一条特殊的指令到程序里，当执行到断点位置就会出发Traps请求，软件的主导权由CPU交给GDB。</p>
<p>当程序触发一个异常例如0/0时，会出发退出异常，由cpu来清理堆栈。</p>
<h3 id="_5"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_5">请求的可阻塞性</a></h3>
<p>对于硬件中断请求，CPU的决策是立即执行，对于软中断和异常，CPU采用尽量延后的策略。</p>
<h3 id="_6"><a class="toclink" href="../../2020/10/19/linux-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82/#_6">查看系统的中断</a></h3>
<p>在中断执行 <code>watch -n1 "cat /proc/interrupts"</code>可以定时更新中断的次数</p>
<p>列的含义从左至右以此为：
<div class="highlight"><pre><span></span><code> IRQ vector, interrupt count per CPU (0 .. n), the hardware source, the hardware source&#39;s channel information, and the name of the device that caused the IRQ.
</code></pre></div></p>
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <span class="md-pagination__current">1</span> <a class="md-pagination__link" href="page/2/">2</a> <a class="md-pagination__link" href="page/3/">3</a>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../2021/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 2021">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                2021
              </div>
            </div>
          </a>
        
        
          
          <a href="../2019/" class="md-footer__link md-footer__link--next" aria-label="下一页: 2019">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                2019
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.tabs.sticky", "navigation.instant", "navigation.instant.progress", "navigation.footer", "toc.follow", "content.code.copy", "content.action.view"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../js/tex-mml-chtml.js"></script>
      
        <script src="../../js/mermaid.min.js"></script>
      
    
  </body>
</html>