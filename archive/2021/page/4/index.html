
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/archive/2021/page/4/">
      
      
        <link rel="prev" href="../../../2022/">
      
      
        <link rel="next" href="../../../2020/">
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>2021 - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#2021" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2021
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../.." class="md-tabs__link">
        
  
  
    
  
  Welcome

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../../2025/" class="md-tabs__link">
          
  
  
    
  
  归档

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tags
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    归档
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
      
    
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="../../" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模板编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      右值, 临时变量与引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      子串查找算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#systemd" class="md-nav__link">
    <span class="md-ellipsis">
      创建 systemd 服务
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhel" class="md-nav__link">
    <span class="md-ellipsis">
      rhel系列修改密码
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weechat" class="md-nav__link">
    <span class="md-ellipsis">
      weechat 使用方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#udp" class="md-nav__link">
    <span class="md-ellipsis">
      udp 的端口复用实现负载均衡
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dns" class="md-nav__link">
    <span class="md-ellipsis">
      阿里云动态设置 dns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2020/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2019
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模板编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      右值, 临时变量与引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      子串查找算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#systemd" class="md-nav__link">
    <span class="md-ellipsis">
      创建 systemd 服务
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhel" class="md-nav__link">
    <span class="md-ellipsis">
      rhel系列修改密码
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weechat" class="md-nav__link">
    <span class="md-ellipsis">
      weechat 使用方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#udp" class="md-nav__link">
    <span class="md-ellipsis">
      udp 的端口复用实现负载均衡
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dns" class="md-nav__link">
    <span class="md-ellipsis">
      阿里云动态设置 dns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="2021">2021<a class="headerlink" href="#2021" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-04 00:00:00+00:00">2021年3月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 5 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/">模板编程</a></h2>
<p>模板编程是其它高级语言没有的技术, 也称为范型编程，元编程(meta programing), stl的基石。这种对类型的泛化相当于在编程之上编程</p>
<h3 id="_2"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_2">概述</a></h3>
<p>模板可以作用于函数和类，即能泛化<code>类型</code>，也可以泛化<code>大小</code>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="p">};</span>

<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// array of two int</span>
<span class="w">    </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// class has a array of two int </span>
<span class="w">    </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">F</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
</code></pre></div></p>
<h3 id="_3"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_3">模板的特化</a></h3>
<p>跟泛化相反的方向，叫特化，编译器会优先使用特化的版本, 而特化有2个方向，<code>类型特化</code>和<code>范围特化</code>  </p>
<h4 id="_4"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_4">类型特化</a></h4>
<p>对于特化类型个数的不同，分为偏特化和全特化，全特化即为所有类型都指定，特化类型越多匹配优先级越高 
注意：模板函数不能偏特化</p>
<div class="highlight"><pre><span></span><code>template&lt;typename T1, typename T2&gt; struct Foo{};
template&lt;typename T2&gt; struct Foo&lt;int, T2&gt; {};
// 全特化
template&lt;&gt; struct Foo&lt;int,int&gt;{};
</code></pre></div>
<p>例如`Foo<int, int> foo'，编译器会使用第三个版本</p>
<h4 id="_5"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_5">范围特化</a></h4>
<p>比如常见的指针和引用，这和int, float, class 都是无关的，属于另个维度，也可以说是范围, 在stl为兼容指针做大量的工作  </p>
<p><div class="highlight"><pre><span></span><code>template &lt;typename T, typename N&gt; struct Foo&lt;T *, N&gt; {};
</code></pre></div>
这样'Foo<int *, int> foo'会使用这个版本</p>
<p>还例如指定对大小的特例化
<div class="highlight"><pre><span></span><code>//模板
template&lt;int n&gt; foo(){}

//值特例化
template&lt;&gt; foo&lt;10&gt; foo(){}
</code></pre></div>
那么如果调用<code>foo&lt;10&gt;();</code>时，优先匹配特例化版本</p>
<h4 id="_6"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_6">函数匹配优先级</a></h4>
<p>在函数调用时，普通函数的匹配优先级高于模板函数
<div class="highlight"><pre><span></span><code>template &lt;typename T&gt; void f(T) { std::cout &lt;&lt; &quot;temp\n&quot;; }
void f(int d) { std::cout &lt;&lt; &quot;temp1\n&quot;; }
template &lt;&gt; void f(int d) { std::cout &lt;&lt; &quot;temp2\n&quot;; }

f(1); // temp1
</code></pre></div></p>
<h4 id="_7"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_7">自定义类型的范围特化</a></h4>
<p>上面讲的是指针类型和引用类型两种，但如果是自定义类型，那就无穷无尽了，所以模板编程也是'图灵完备'的</p>
<p>例如以下，创建了一个自定义的类型来包装基本类型(int,float)，这样可以有自定义类型的特化版本
<div class="highlight"><pre><span></span><code>  template &lt;typename T&gt; struct Decor { using type = T; };
  template &lt;typename T&gt; struct Strip { using type = T; };
  template &lt;typename T&gt; struct Strip&lt;Decor&lt;T&gt;&gt; { using type = T; };
  template &lt;typename T&gt; using StripDecor = typename Strip&lt;T&gt;::type;

  template &lt;typename T&gt; class Row {};

  int main() {
    using nodecor = Row&lt;int&gt;;
    using decor = Decor&lt;Row&lt;int&gt;&gt;;
    // 虽底层同为int, 但nodecor 类型不同于decor类型
    static_assert(std::is_same&lt;col&gt;, nocol&gt;::value);
    // 通过Strip取出其底层类型
    static_assert(std::is_same&lt;StripDecor&lt;col&gt;, nocol&gt;::value);
    return 0;
  }
</code></pre></div></p>
<h4 id="_8"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_8">模板的声明定义分离</a></h4>
<ol>
<li>由于template用来生成函数和类，所以编译器需要同时知道template的类型和其细节，所以模板函数不支持将定义放到源文件中</li>
<li>而且编译器通常是以cpp为编译单元，当编译模板cpp时不知道调用cpp, 编译调用cpp时，不知道模板cpp。所以模板函数不支持将定义放到源文件中</li>
<li>对于模板类可以将成员函数的定义放到源文件，但要为每个成员函数都添加'template'限定, <strong><em>而且要为实例添加特例化</em></strong>。</li>
<li>显式特例化支持只声明不定义，而在源文件中为每种所需的类型都特例化，即与3相同。其实显示特例化是不需要特例化而强制特例化。 </li>
</ol>
<p>如下，模板类的定义放到cpp中，这样会报错，因为在编译call_foo.cpp时不知到模板定义, 因为没有生成过int版本的Foo。<br />
为此，必须在foo.cpp里添加<code>template class Foo&lt;int&gt;</code>, 如同4，实在吃力不讨好。
<div class="highlight"><pre><span></span><code><span class="c1">// foo.h</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">class</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span>
<span class="w">      </span><span class="n">Foo</span><span class="p">();</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="nf">someMethod</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">private</span><span class="o">:</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="c1">// foo.cpp</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">someMethod</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="c1">// call_foo.cpp</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">blah_blah_blah</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">      </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">      </span><span class="n">f</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div></p>
<p>当然把模板的定义放到头文件中会增加可执行文件的体积。</p>
<h5 id="_9"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_9">实际运用</a></h5>
<p>grpc 能以流和非流方式传输，而grpc参数protobuf消息类型是另一个范围。那么要封装grpc方法, 需要封装流+类型</p>
<p>举例protobuf的消息类型有string, fixed32
- string
- fixed32
- Stream<fixed32>
- Stream<string></p>
<p>通过上面的偏特化可以即能区分流和非流又能区分类型</p>
<h4 id="_10"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_10">赘述一下模板的类型</a></h4>
<p>上面的模板类型T都是实际编程时定义的类型，但作为图灵完备的模板编程，未决的template类型也可以作为template类型</p>
<p>如下是一个模板用另一个模板来特例化
<div class="highlight"><pre><span></span><code>template &lt;typename T&gt; struct Upper {};
template &lt;template &lt;typename&gt; class T&gt; struct Lower {};

template&lt;typename T&gt;
Lower&lt;Upper&lt;T&gt;&gt; l;
</code></pre></div></p>
<h3 id="variadic-templates"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#variadic-templates">可变模版variadic templates</a></h3>
<p>c中有可变参数<code>...</code>和gcc内置<code>__VA_ARGS__</code>宏定义, 实现不同个数的变量打印。这是由编译期实现的，会将format的格式符替换成参数
<div class="highlight"><pre><span></span><code>int printf ( const char * format, ... );
</code></pre></div></p>
<p>c++有模版，而且在c++11之后引入了动态参数模版，即模版函数或类可以使用动态参数</p>
<h4 id="1"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#1">实际运用1</a></h4>
<p>在实际项目中手动跑单元测试用例的时候，不希望再去看日志文件，而是想日志直接输出到终端, 有以下办法</p>
<h5 id="c11"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c11">c++11及以上标准</a></h5>
<p>可以使用动态参数模版替换原本的日志打印函数
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Rest</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">rest</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 这时日志就直接输出到终端了, 这里使用了fmt库</span>
<span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;aasdas{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bbbb&quot;</span><span class="p">);</span>
</code></pre></div></p>
<p>也可简单写成
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">...)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>如果不使用fmt格式化，还可以用
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>
<span class="c1">// 定义一个空函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">log_debug</span><span class="p">(){}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Rest</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">First</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Arg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">arg</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="n">log_debug</span><span class="p">(</span><span class="n">arg</span><span class="p">...);</span>
<span class="p">}</span>
</code></pre></div>
需要解释一下，函数<code>log_debug()</code>必须要先声明，因为模版实例化的的最终要调用这个无参的函数<br />
模拟一下堆栈, 因为参数在每次递归时减少一个，所以最终是0个参数
<div class="highlight"><pre><span></span><code>log_debug(1, 0.2, &quot;aaa&quot;);
log_debug(0.2, &quot;aaa&quot;);
log_debug(&quot;aaa&quot;);
log_debug();
</code></pre></div></p>
<h5 id="c11_1"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c11_1">c++11以前的标准</a></h5>
<p>可以使用宏定义来替换了, 然后需要重载<code>,</code>方法
<div class="highlight"><pre><span></span><code><span class="cp">#define log_debug(...) std::cout , __VA_ARGS__ , std::endl</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">,(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//overloaded version to handle all those special std::endl and others...</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">,(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h5 id="c"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c">直接用c的方式</a></h5>
<p>因为printf是支持varidic的
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>

<span class="cp">#define log_debug(...) printf(__VA_ARGS__), printf(&quot;\n&quot;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;example&quot;</span><span class="p">,</span><span class="s">&quot;output&quot;</span><span class="p">,</span><span class="s">&quot;filler&quot;</span><span class="p">,</span><span class="s">&quot;text&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h5 id="c17-fold-expression"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c17-fold-expression">c++17 引入了<code>fold expression</code></a></h5>
<p>可以改写为
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">Args</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>动态参数模版除了以上的用法，还有更多用处, 例如<code>std::tupe</code>的实现</p>
<h4 id="2"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#2">实际运用2</a></h4>
<h5 id="_11"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_11">使用模板生成并发代码</a></h5>
<p>以下代码实现复制二维数组，
<div class="highlight"><pre><span></span><code>for( size_t ch=0 ; ch&lt;channelNum ; ++ch ) {
    for( size_t i=0; i&lt;length ; ++i ) {
        out[ch][i]=in[ch][i];
    }
}
</code></pre></div></p>
<p>但以下理论更快，没有两层for，前提是知道channel大小
<div class="highlight"><pre><span></span><code>for(size_t i=0;i&lt;length;++i) {
    out[0][i]=in[0][i];
    out[1][i]=in[1][i];
    out[2][i]=in[2][i];
    out[3][i]=in[3][i];
}
</code></pre></div></p>
<p>但如果用模板，就不需要知道channel大小，自动生成上面的代码</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Copy</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Copy</span><span class="o">&lt;</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">go</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">out</span><span class="p">[</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Copy</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">channelNum</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">parall_copy</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Copy</span><span class="o">&lt;</span><span class="n">channelNum</span><span class="o">&gt;::</span><span class="n">go</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>需要提醒的，如同打印日志的，0的特例化不能省，否则编译出错</p>
<h4 id="3"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#3">实际运用3 工厂模式</a></h4>
<p>在使用spdlog时发现有使用到template未决名, 用来实现两个维度的工厂模式。</p>
<p>第一层提供两种sink的工厂，而其factory是未决名，所以要加上<code>Factory::template</code>消歧义，不然<code>&lt;</code>会当成小于号  </p>
<div class="highlight"><pre><span></span><code><span class="c1">//</span>
<span class="c1">// factory functions</span>
<span class="c1">//</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_factory</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basic_logger_mt</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">filename_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Factory</span><span class="o">::</span><span class="n">template</span><span class="w"> </span><span class="n">create</span><span class="o">&lt;</span><span class="n">sinks</span><span class="o">::</span><span class="n">basic_file_sink_mt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">truncate</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_factory</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basic_logger_st</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">filename_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Factory</span><span class="o">::</span><span class="n">template</span><span class="w"> </span><span class="n">create</span><span class="o">&lt;</span><span class="n">sinks</span><span class="o">::</span><span class="n">basic_file_sink_st</span><span class="o">&gt;</span><span class="p">(</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">truncate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>此时factory可以是<code>synchronous_factory</code>, 也可以是异步版本，但这需要用户自己实现。
<div class="highlight"><pre><span></span><code><span class="c1">// Default logger factory-  creates synchronous loggers</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">synchronous_factory</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Sink</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="p">...</span><span class="w"> </span><span class="n">SinkArgs</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">spdlog</span><span class="o">::</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">SinkArgs</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">sink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">SinkArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">new_logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">logger_name</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">));</span>
<span class="w">        </span><span class="n">details</span><span class="o">::</span><span class="n">registry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">initialize_logger</span><span class="p">(</span><span class="n">new_logger</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">new_logger</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">using</span><span class="w"> </span><span class="n">default_factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">synchronous_factory</span><span class="p">;</span>
</code></pre></div></p>
<p>简化为下面的demo，固然可以直接使用call_dd的方式，但维度只有一个。而call_dd2则有2个维度了<br />
但必须使用<code>T::template</code>消歧义, 因为此时的foo未决名, 不知道是那个类里面的foo。
<div class="highlight"><pre><span></span><code>  struct AA {
    template &lt;typename cc&gt; static void foo() { std::cout &lt;&lt; &quot;dd::foo\n&quot;; };
  };

  struct BB {
    template &lt;typename cc&gt; static void foo() { std::cout &lt;&lt; &quot;dd::foo\n&quot;; };
  };

  template &lt;typename T&gt; void call_dd() { AA::foo&lt;T&gt;(); }
  template &lt;typename T, typename K&gt; void call_dd2() { T::template foo&lt;K&gt;(); }

  int main() {
    call_dd&lt;void&gt;();
    call_dd2&lt;AA&gt;();
    call_dd2&lt;AA, int&gt;();
    call_dd2&lt;BB, long&gt;();
  }
</code></pre></div></p>
<h3 id="_12"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_12">模版与宏定义、虚函数的区别</a></h3>
<ol>
<li>宏定义在预处理期执行，模板在编译期执行，而虚函数也称动态绑定在运行时执行</li>
<li>宏和模板都将运行时的工作提前了，用编译时间换取运行效率</li>
<li>宏定义没有类型检查，这点模板比较好</li>
<li>模板虽然会延长编译时间，但当编译期实例化类型后，查找模板函数和查找普通函数的速度几乎相同</li>
</ol>
<h3 id="dependent-name"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#dependent-name">待决名dependent name</a></h3>
<ol>
<li>待决名的意思是在定义的地方，类型还不能决断，需要延后到实例化确定时。而非待决名指类型在定义的地方已经确定。  </li>
<li>延后将导致此时无法在定义点进行错误检查，以及消除<code>typename</code>和<code>template</code>歧义，这导致需要在调用点加上template</li>
</ol>
<p>待决名如:
<div class="highlight"><pre><span></span><code>template&lt;typename T&gt;
struct X : B&lt;T&gt; // &quot;B&lt;T&gt;&quot; 取决于 T
{
    typename T::A* pa; // &quot;T::A&quot; 取决于 T
                       // （此 &quot;typename&quot; 的使用的目的见下文）
    void f(B&lt;T&gt;* pb)
    {
        static int i = B&lt;T&gt;::i; // &quot;B&lt;T&gt;::i&quot; 取决于 T
        pb-&gt;j++; // &quot;pb-&gt;j&quot; 取决于 T
    }
};
</code></pre></div></p>
<p>让人吃惊的例子, 这就是非待决名的情况下，立即绑定
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;g(double)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;g&quot; 是非待决名，现在绑定</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;g(int)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 调用 g(int)</span>

<span class="w">    </span><span class="n">S</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// 调用 g(double)</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="typename"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#typename">typename消歧义</a></h4>
<p>在模板（包括别名模版）的声明或定义中，不是当前实例化的成员且取决于某个模板形参的名字不会被认为是类型，<br />
除非使用关键词 typename 或它已经被设立为类型名（例如用 typedef 声明或通过用作基类名）。 </p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// std::vector&lt;T&gt;::const_iterator 是待决名，</span>
<span class="w">    </span><span class="n">typename</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 下列内容因为没有 &#39;typename&#39; 而会被解析成</span>
<span class="w">    </span><span class="c1">// 类型待决的成员变量 &#39;const_iterator&#39; 和某变量 &#39;p&#39; 的乘法。</span>
<span class="w">    </span><span class="c1">// 因为在此处有一个可见的全局 &#39;p&#39;，所以此模板定义能编译。</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">iter_t</span><span class="p">;</span>
<span class="w">    </span><span class="n">iter_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// iter_t 是待决名，但已知它是类型名</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value_t</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前实例化的成员</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value_t</span><span class="w"> </span><span class="n">n</span><span class="p">{};</span><span class="w"> </span><span class="c1">// S&lt;T&gt; 待决，但不需要 &#39;typename&#39;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模板实例化失败：类型 std::vector&lt;int&gt; 中没有</span>
<span class="w">            </span><span class="c1">// 名字是 &#39;const_iterator&#39; 的成员变量</span>
<span class="w">    </span><span class="n">S</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">().</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="template"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#template">template消歧义</a></h4>
<p>与此相似，模板定义中不是当前实例化的成员的待决名同样不被认为是模板名，除非使用消歧义关键词 template，或它已被设立为模板名： </p>
<p><div class="highlight"><pre><span></span><code>template&lt;typename T&gt;
struct S
{
    template&lt;typename U&gt; void foo() {}
};

template&lt;typename T&gt;
void bar()
{
    S&lt;T&gt; s;
    s.foo&lt;T&gt;();          // 错误：&lt; 被解析为小于运算符
    s.template foo&lt;T&gt;(); // OK
}
</code></pre></div>
template 消歧义可以使用
<div class="highlight"><pre><span></span><code>T::template
s.template
this-&gt;template
</code></pre></div></p>
<h3 id="stdforward"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#stdforward">std::forward 转发在模版的使用</a></h3>
<p>为什么完美转发的对象必须是右值引用？</p>
<h4 id="_13"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_13">说明一下右值引用</a></h4>
<div class="highlight"><pre><span></span><code> 引用类型   可以引用的值类型    使用场景
非常量左值   常量左值    非常量右值   常量右值
非常量左值引用     Y   N   N   N   无
常量左值引用  Y   Y   Y   Y   常用于类中构建拷贝构造函数
非常量右值引用     N   N   Y   N   移动语义、完美转发
常量右值引用  N   N   Y   Y   无实际用途
</code></pre></div>
<h3 id="_14"><a class="toclink" href="../../../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_14">参考</a></h3>
<p>https://en.cppreference.com/w/cpp/language/parameter_pack
https://en.cppreference.com/w/cpp/language/fold
https://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-02 00:00:00+00:00">2021年3月2日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/">右值, 临时变量与引用</a></h2>
<p>我们说的临时变量通常是指在语句块里定义的短暂生命周期的局部变量, 其存储周期为'auto'，但这里讨论的是c++中'temporary object', 是在老版本c++中
而语句块里定义的变量以及非引用类型参数，并不属于这里的临时变量  </p>
<p>c++中的临时变量出现情况：
* litteral常量, 如1
* 类型转换   // 赋值语句结束后，自动销毁
* 函数返回值 // 赋值语句结束后，自动销毁
* 表达式的值 </p>
<p>而临时变量的定义就是<code>编译器自动创建和销毁的没有名字的变量</code>, 也无法取地址。并且规定：<br />
- 常量类型的引用（<code>reference to const</code>）可以绑定到临时变量
- 非常量类型的引用（<code>reference to non-const</code>）类型不能绑定到临时变量</p>
<p>这个规定的原因是： 因为上面说的<code>编译器自动创建和销毁</code>，所以去修改一个会销毁变量是<code>没有意义的</code></p>
<h3 id="_2"><a class="toclink" href="../../../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/#_2">什么时候编译器要需要创建临时变量</a></h3>
<table>
<thead>
<tr>
<th>创建原因</th>
<th>销毁时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>Result of expression evaluation</td>
<td>All temporaries created as a result of expression evaluation are destroyed at the end of the expression statement (that is, at the semicolon), or at the end of the controlling expressions for for, if, while, do, and switch statements.</td>
</tr>
<tr>
<td>Initializing const references</td>
<td>If an initializer is not an l-value of the same type as the reference being initialized, a temporary of the underlying object type is created and initialized with the initialization expression. This temporary object is destroyed immediately after the reference object to which it is bound is destroyed.</td>
</tr>
</tbody>
</table>
<p>主要是以下两个地方会需要临时变量：
* 函数接受引用类型参数的时候
* 函数返回的时候
* 类型转换的时候</p>
<p>举例：</p>
<p>函数参数
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 此时创建了临时变量，可以想象成&#39;foo(int _tmp(i));&#39; 而且这个_tmp 不能被修改</span>
</code></pre></div></p>
<p>函数返回值
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(){</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// 此时创建了临时变量， int _tmp = foo(); int i = _tmp;</span>
</code></pre></div></p>
<p>类型转换
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// double _tmp = i; double d = _tmp;</span>
</code></pre></div></p>
<h3 id="_3"><a class="toclink" href="../../../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/#_3">单独讨论这些似乎意义不大， 但是在实际编写代码的时候，可能会有疑惑</a></h3>
<p>例如如何解释
<div class="highlight"><pre><span></span><code>const int&amp; cr = 1; // ok
int &amp;r = 1; // ng
</code></pre></div>
这里赋值和函数传参一样， 因为1是常数，这里为常量<code>1</code>创建临时变量， 而只有<code>reference to const</code> 才能绑定到临时变量上</p>
<p>还有解释一个经常被引用的例子
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"> </span><span class="c1">// ng</span>
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
</code></pre></div>
这里虽然i和d都不是常量（不会创建临时变量）， 但是因为类型不同， 发生了类型转换，创建了临时变量。同样地，只有<code>reference to const</code> 才能绑定到临时变量上</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-02-05 00:00:00+00:00">2021年2月5日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">子串查找算法</a></h2>
<p>leetcode的<a href="https://leetcode-cn.com/problems/implement-strstr/">题目</a>, 实现strstr,即查找子字符串</p>
<h3 id="_2"><a class="toclink" href="../../../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#_2">最简单的算法</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">strStr</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">){</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">needle</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="kmp"><a class="toclink" href="../../../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#kmp">kmp 算法</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++ program for implementation of KMP pattern searching </span>
<span class="c1">// algorithm </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="c1"> </span>

<span class="kt">void</span><span class="w"> </span><span class="nf">computeLPSArray</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">lps</span><span class="p">);</span><span class="w"> </span>

<span class="c1">// Prints occurrences of txt[] in pat[] </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">KMPSearch</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">txt</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">txt</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// create lps[] that will hold the longest prefix suffix </span>
<span class="w">    </span><span class="c1">// values for pattern </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">M</span><span class="p">];</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Preprocess the pattern (calculate lps[] array) </span>
<span class="w">    </span><span class="n">computeLPSArray</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">lps</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// index for txt[] </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// index for pat[] </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Found pattern at index %d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"> </span>
<span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>

<span class="w">        </span><span class="c1">// mismatch after j matches </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="c1">// Do not match lps[0..lps[j-1]] characters, </span>
<span class="w">            </span><span class="c1">// they will match anyway </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">                </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>

<span class="c1">// Fills lps[] for given patttern pat[0..M-1] </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">computeLPSArray</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">lps</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// length of the previous longest prefix suffix </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// lps[0] is always 0 </span>

<span class="w">    </span><span class="c1">// the loop calculates lps[i] for i = 1 to M-1 </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pat</span><span class="p">[</span><span class="n">len</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">len</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="c1">// (pat[i] != pat[len]) </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="c1">// This is tricky. Consider the example. </span>
<span class="w">            </span><span class="c1">// AAACAAAA and i = 7. The idea is similar </span>
<span class="w">            </span><span class="c1">// to search step. </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>

<span class="w">                </span><span class="c1">// Also, note that we do not increment </span>
<span class="w">                </span><span class="c1">// i here </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="c1">// if (len == 0) </span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="w">                </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>

<span class="c1">// Driver program to test above function </span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">txt</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABABDABACDABABCABAB&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">pat</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABABCABAB&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">KMPSearch</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="n">txt</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<h3 id="strstr"><a class="toclink" href="../../../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#strstr">使用哈希查找和strstr速度比较</a></h3>
<p>hash在查找字符串时，每次偏移1个字节，并计算hash, 为了不重复计算重叠部分，有个算法'Karp-Rabin with Rolling Hash'。 但是速度都不如glibc的 strstr， 因为这里的hash函数没有用到硬件加速，但是strstr用了。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define BASE 256         </span><span class="c1">// Alphabet size (ASCII)</span>
<span class="cp">#define MOD 101          </span><span class="c1">// A prime number to avoid overflow</span>

<span class="c1">// Rolling hash version of strstr()</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">rabin_karp_strstr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">hash_needle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Hash for needle</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Hash for current window in haystack</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The value of h is BASE^(m-1) % MOD</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BASE</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate the hash value of needle and first window</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hash_needle</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash_needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">        </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash_window</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Slide the pattern over text</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hash_needle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_window</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Verify characters to avoid false positive</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Calculate hash for next window</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">hash_window</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hash_window</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">hash_window</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ensure non-negative</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-28 00:00:00+00:00">2021年1月28日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="systemd"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/">创建 systemd 服务</a></h2>
<p>说一个老话， 现在systemd作为linux的启动管理和服务管理已经越来越重要了， 上周考试也遇到用systemd 来管理容器，这里记录一下如何编写systemd服务</p>
<h3 id="systemd_1"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#systemd_1">关于systemd</a></h3>
<p>systemd是只能运行在Linux上的init, 也就是启动后看到的1号进程。 除了启动， systemd还管理着很多东西，例如网络（systemd-networkd）， 域名解析（systemd-resolved），为服务创建socket(systemd.socket) 文件系统挂载，还有系统和用户的服务<br />
systemd太大，说不完，需要查看各种文档</p>
<h3 id="systemd_2"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#systemd_2">systemd 的两种使用模式</a></h3>
<p>systemd 分为system级别和user级别， 对应的unit文件分别在/etc/systemd/ 和 ～/.config/systemd/下， 前者是系统级别，后者是用户级别。 用户只能运行自己设置的服务</p>
<p><div class="highlight"><pre><span></span><code>systemctl start system_service.service
</code></pre></div>
而普通用户只能执行
<div class="highlight"><pre><span></span><code>systemctl --user user_service.service
</code></pre></div></p>
<p>这个name就是文件名称，例如必须'/etc/systemd/system/'下存在'system_service.service'文件，在能执行第一条的命令、 必须在 '~/.config/systemd/user/'下存在'user_service.service'在能执行第二条命令</p>
<h4 id="_1"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#_1">系统服务以其他用户运行服务</a></h4>
<p>系统级别的服务默认会以root来运行服务，但是也可以设置以其他用户来运行来最小化权限，例如音视频服务。也可以以某个用户来执行，那么service unit 文件就变为'system_service@user.service'</p>
<div class="highlight"><pre><span></span><code># system_service@user.service
[Unit]
Description=Watchman for user %i
After=remote-fs.target
Conflicts=shutdown.target

[Service]
ExecStart=/usr/local/bin/watchman --foreground --inetd
ExecStop=pkill -u %i -x watchman
Restart=on-failure
User=%i
Group=users
StandardInput=socket
StandardOutput=syslog
SyslogIdentifier=watchman-%i

[Install]
WantedBy=multi-user.target
</code></pre></div>
<p>上面的服务以下面的socket 单元启动， 前提要这个服务实现接收socket,通过<code>sd_listen_fds(3)</code>
<div class="highlight"><pre><span></span><code># system_service@user.socket

[Unit]
Description=Watchman socket for user %i

[Socket]
ListenStream=/var/facebook/watchman/%i-state/sock
Accept=false
SocketMode=0664
SocketUser=%i
SocketGroup=othergroup

[Install]
WantedBy=sockets.target
</code></pre></div></p>
<h4 id="_2"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#_2">普通用户运行服务</a></h4>
<p>注意， 普通用户因为只会以自己的身份启动，所以不能想系统服务那样指定'User/Group'
<div class="highlight"><pre><span></span><code>[Unit]
Description=tun2socks for vpn
#Requires=ssh_to_alpha.service

[Service]
Type=simple
ExecStart=/usr/bin/badvpn-tun2socks 

[Install]
WantedBy=default.target
</code></pre></div></p>
<p>若希望这个用户自定义服务能自启动， WantedBy需要设置成'default.target'</p>
<h3 id="unit-file"><a class="toclink" href="../../../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#unit-file">自动创建unit-file</a></h3>
<p>以下命令可以自动在对应目录创建*.service文件
<div class="highlight"><pre><span></span><code>systemctl --user --force --full edit test.service 
</code></pre></div></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-21 00:00:00+00:00">2021年1月21日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="rhel"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/">rhel系列修改密码</a></h2>
<p>考rhce8 栽在改密码了， 现在彻底弄明白</p>
<h3 id="selinux"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#selinux">关于selinux</a></h3>
<p>这是rhel和其他发行版的最大区别，也是我忽略的点。启用selinux 时，改密码后，额外要执行<code>touch /.autorelabel</code>， 新密码才能生效，而平时我使用centos一直是禁用selinux的。</p>
<h3 id="selinux_1"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#selinux_1">启用selinux</a></h3>
<p>selinux 默认状态是enforcing, 禁用时为disable, 通过<code>sestate</code> 查看状态。</p>
<h4 id="etcselinuxconfig"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#etcselinuxconfig">编译'/etc/selinux/config'</a></h4>
<p>修改selinux配置，从disable 到enforcing</p>
<h4 id="_1"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_1">执行两次下面动作</a></h4>
<p>创建这个文件的意义是重新label selinux, 不仅是当修改selinux配置需要做，在重置root密码时也是需要
<div class="highlight"><pre><span></span><code>touch /.autorelabel
reboot
</code></pre></div></p>
<h3 id="_2"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_2">叙说改密</a></h3>
<p>rhel5~8有两种方式重置密码，老版本为给linux启动参数加上'init=/bin/sh', 新版本为加<code>rd.break</code><br />
老版本适用于centos8（已测）, 而新版本应该不支持rhel5，6（未测），下面是完整步骤</p>
<h4 id="_3"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_3">老版本</a></h4>
<ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加'init=/bin/sh'</li>
<li>按ctrl+x继续，系统自动进入内存文件系统的根目录</li>
<li>执行<code>/sbin/load_policy -i</code>来初始化selinux</li>
<li>此时系统处于ro模式，执行<code>mount -oremount,rw /</code> 重新挂载根分区，使系统可写</li>
<li><code>passwd</code> 设置root密码</li>
<li>如果启用了selinux, 额外要执行<code>touch /.autorelabel</code></li>
<li>最后执行<code>exit</code>或者 <code>exec /sbin/reboot</code> 或者<code>exec /sbin/init</code></li>
</ol>
<h4 id="_4"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_4">新版本</a></h4>
<ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加'rd.break'</li>
<li>按ctrl+x继续，系统自动进入root系统，此时真正的文件系统以ro挂载在/sysroot</li>
<li>执行<code>mount -oremount,rw /sysrot</code> 重新挂载</li>
<li>执行<code>chroot /sysroot</code> 进入系统</li>
<li>执行<code>passwd</code>设置root密码</li>
<li>如果启用了selinux, 需要额外创建文件<code>touch /.autorelabel</code></li>
<li>执行<code>exit</code> 退出，然后执行 <code>umount /sysroot</code> 来确保写入</li>
<li>reboot 来重新进入</li>
</ol>
<h3 id="rescue"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#rescue">通过rescue模式改密码</a></h3>
<p>任何发行版都可以通过光盘引导来改密。如果熟悉archlinux安装的方式，就知道进入live os之后可以挂载原系统的磁盘<br />
然后chroot成为root用户，就能直接执行<code>passwd</code>来修改密码</p>
<h3 id="_5"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_5">通过修改镜像改密码</a></h3>
<p>最暴力的方式就是用guestfish工具, 一条命令改密。当然得先获取镜像文件<br />
先切换到root用户，使用guestmount命令挂载分区，-i表示自动挂载
<div class="highlight"><pre><span></span><code>guestmount --add base.raw  -i /tmp/hm
</code></pre></div>
然后chroot到挂载点
<div class="highlight"><pre><span></span><code>chroot /tmp/hm
</code></pre></div>
然后改密
<div class="highlight"><pre><span></span><code>passwd
</code></pre></div></p>
<p>virt提供了简化版本，一条命令就能改密码
<div class="highlight"><pre><span></span><code>virt-customize -a centos8.qcow2 --root-password password:123456
</code></pre></div></p>
<p>可见镜像文件有多么不安全</p>
<h3 id="vmwarekvm"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#vmwarekvm">最后记录一下vmware虚拟机镜像转换kvm镜像</a></h3>
<p>由于收到的vmware镜像，又没有装vmware workstation，所以找到转换镜像的方法，也很方便
<div class="highlight"><pre><span></span><code>qemu-img convert  CentOS\ 5.vmdk  base-000001.raw       
</code></pre></div>
但问题是不支持转换快照文件</p>
<h3 id="_6"><a class="toclink" href="../../../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_6">引用</a></h3>
<p>https://docs.openstack.org/image-guide/convert-images.html</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-19 00:00:00+00:00">2021年1月19日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="weechat"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">weechat 使用方法</a></h2>
<p>weechat 是一个irc客户端， 在终端中运行，不需要gui桌面，非常方便。 这里记录配置方法</p>
<p>主要参考<a href="https://samirparikh.com/blog/setting-up-weechat-commandline-irc-client.html">链接</a></p>
<h3 id="weechat_1"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#weechat_1">安装和运行weechat</a></h3>
<p>安装后，直接在终端运行<code>weechat</code>，就能进入weechat</p>
<h3 id="_1"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_1">配置</a></h3>
<h4 id="server"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#server">添加server</a></h4>
<p>irc有很多server, 常用的是freenode。 另外有darkscience。 添加方法如下，另外weechat里面命令都是以'/' 开头，还能使用tab补全
<div class="highlight"><pre><span></span><code>/server add freenode chat.freenode.net/6697 -ssl
</code></pre></div>
irc 除了有很多服务器url, 每个url 还有多个端口供链接，比如6697</p>
<h4 id="_2"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_2">设置昵称</a></h4>
<p>昵称默认是linux系统的用户名，昵称用来在聊天中显示名称
<div class="highlight"><pre><span></span><code>/nick mynickname
</code></pre></div>
**注意：
手动修改昵称不是简单的事情，特别是当已经连接serer时。 比较方便的办法就是直接改配置文件
<div class="highlight"><pre><span></span><code># ～/.weechat/irc.conf
nicks = &quot;malloy,malloy1,malloy2&quot;
</code></pre></div>
带后缀的昵称用来当malloy占用时的备用，比如网络重连时昵称有冲突就需要备用昵称</p>
<h4 id="_3"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_3">注册昵称</a></h4>
<p>因为有很多聊天室要求注册后才能进入，所以先要使用邮箱注册
<div class="highlight"><pre><span></span><code>/msg nickserv register userpassword example@email
</code></pre></div></p>
<p>然后irc 会提示查收邮件，在邮件里面提示你在irc输入命令完成注册</p>
<h4 id="_4"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_4">加入聊天室</a></h4>
<p>聊天室都是以#开头，例如我使用的 '#archlinuxcn'
<div class="highlight"><pre><span></span><code>/join #weechat
</code></pre></div></p>
<h4 id="_5"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_5">退出聊天室</a></h4>
<p><div class="highlight"><pre><span></span><code>/parted &quot;leave message&quot;
</code></pre></div>
或者
<div class="highlight"><pre><span></span><code>/close
</code></pre></div></p>
<h3 id="_6"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_6">自动设置</a></h3>
<p>设置打开weechat时，自动登陆和自动进入聊天室</p>
<div class="highlight"><pre><span></span><code>/set irc.server.freenode.autoconnect on
/set irc.server.networkname.autojoin &quot;#channel1,#channel2&quot;
</code></pre></div>
<h3 id="_7"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_7">界面设置</a></h3>
<p>先介绍weechat的各名称对应命令 : 
聊天室称为buffer, 切换聊天室命令 <code>/buffer n</code><br />
最左边的聊天列表是bufferlist bar<br />
进入buffer后，最右边的是nicklist bar，一个聊天室界面叫做window， 所以下面的命令设置就与 /bar /windows 有关</p>
<p>隐藏和显示bufferlist
<div class="highlight"><pre><span></span><code>/bar hiden bufferlist 
/bar show bufferlist
/bar toggle bufferlist
</code></pre></div>
分屏显示所有聊天室，水平分屏splith,竖直分屏 splitev
<div class="highlight"><pre><span></span><code>/window splitv 
</code></pre></div>
窗口切换
<div class="highlight"><pre><span></span><code>/window +1
/window -1
</code></pre></div>
窗口合并
<div class="highlight"><pre><span></span><code>/window merge
</code></pre></div></p>
<h3 id="_8"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_8">安全设置</a></h3>
<ol>
<li>上面添加服务器时，已经配置了ssl选项，就表示使用通讯加密了，但irc的聊天记录一般是对外公开的  </li>
<li>设置weechat开启密码， 进入weechat前验密
<div class="highlight"><pre><span></span><code>/secure passphrase superSecretPassphrase
</code></pre></div></li>
</ol>
<h3 id="_9"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_9">自动化设置和鉴权</a></h3>
<p>注册好昵称之后，配置自动化登陆，而不需要手动执行命令</p>
<p>设置irc登陆昵称，作为identify的参数，务必要跟register的保持一致
<div class="highlight"><pre><span></span><code>/secure set networkname_nickname password
</code></pre></div>
设置irc登陆密码，作为identify的参数，务必要跟register的密码保持一致
<div class="highlight"><pre><span></span><code>/secure set networkname_password password
</code></pre></div></p>
<p>设置weechat启动时自动登陆服务器，以及自动加入channel
<div class="highlight"><pre><span></span><code>/set irc.server.libera.autoconnect on
/set irc.server.libera.autojoin &quot;#archlinux-cn,#c,#c++&quot;
</code></pre></div>
以及自动验密
<div class="highlight"><pre><span></span><code>/set irc.server.networkname.command &quot;/msg nickserv identify ${sec.data.networkname_nickname} ${sec.data.network_password}&quot;
</code></pre></div>
其实显而易见地，<code>sec.data.networkname_nickname</code>和<code>sec.data.network_password</code> 都只是保存在sec.data里的变量，其实可以两个变量合成一条也没问题</p>
<h3 id="_10"><a class="toclink" href="../../../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_10">更多功能</a></h3>
<p>weechat有很多拓展插件，可以完成很多事情，比如自动回复，远程控制，连接telegram等, <a href="https://weechat.org/scripts/">参考</a></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-15 00:00:00+00:00">2021年1月15日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="udp"><a class="toclink" href="../../../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">udp 的端口复用实现负载均衡</a></h2>
<h3 id="_1"><a class="toclink" href="../../../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_1">前言</a></h3>
<p>偶尔看到 python 3.9 的release note 里面提到一个bug
<div class="highlight"><pre><span></span><code>asyncio¶

出于重要的安全性考量，asyncio.loop.create_datagram_endpoint() 的 reuse_address 形参不再被支持。 这是由 UDP 中的套接字选项 SO_REUSEADDR 的行为导致的。 更多细节请参阅 loop.create_datagram_endpoint() 的文档。 （由 Kyle Stanley, Antoine Pitrou 和 Yury Selivanov 在 bpo-37228 中贡献。。）
</code></pre></div>
意思是tcp的socket option:SO_REUSEADDR不适用于udp：
在tcp中这个选项表示立即回收端口，减少 time_wait 的时间。而在udp中，这个选项表示多个socket可以绑定一个端口， 由内核来分发请求。</p>
<p>所以看到此功能，自己试了一下，确实如此， 顺便回顾一下知识</p>
<h3 id="_2"><a class="toclink" href="../../../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_2">主要代码</a></h3>
<div class="highlight"><pre><span></span><code>    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8888);
    inet_pton(AF_INET,&quot;127.0.0.1&quot;,(void*)&amp;addr.sin_addr);
    // inet_pton 支持ipv4和ipv6,是比较新的转换函数

    sfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sfd == -1)
    {
        perror(&quot;socket&quot;);
        exit(1);
    }
    int val = 1;
    if(0 != setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT,&amp;val, sizeof(val))){
        perror(&quot;setsockopt&quot;);
        exit(1);
    }
    /* sockaddr 和 sockaddr_in 有什么区别？
       struct sockaddr {  
        sa_family_t sin_family;//地址族
　　      char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息               
　　    }; 
　　    struct sockaddr_in {
　　      sa_family_t sin_family;//地址族
　　      uint16_t sin_port;
　　      struct in_addr sin_addr;    // 32 位地址
　　      char    sin_zero[8];    // reserve
　　    };
　　    struct in_addr {
　　      In_addr_t   s_addr;  //32位
　　    };
　　    
　　    sockaddr_in 和 sockaddr 长度相同，都 sin_family + 14 个字节，但是前者显式划分了
　　 */ 
    if(bind(sfd, (struct  sockaddr*) &amp;addr, sizeof(addr)) != 0)
    {
        perror(&quot;bind&quot;);
        exit(1);
    }
</code></pre></div>
<h3 id="_3"><a class="toclink" href="../../../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_3">效果</a></h3>
<p>先启动两个服务端，再使用ncat 来模拟请求, </p>
<div class="highlight"><pre><span></span><code>ncat -uv 0.0.0.0 8888
</code></pre></div>
<p>启动ncat时，系统会分配给一个服务端处理。 但是重启ncat时， 会切换到另一个服务端处理</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-04 00:00:00+00:00">2021年1月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="dns"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/">阿里云动态设置 dns</a></h2>
<p>如果服务器的公网ip动态变化的情况下，如何访问，甚至如何通过域名访问？ </p>
<p>例如公司自己搭建的服务器如何暴露在公网上， 如果请求固定ip听说很贵， 还可以通过<code>frp</code>实现, 这里介绍2种方案</p>
<h3 id="dns_1"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#dns_1">动态dns</a></h3>
<p>前提是服务器有出口ip, 而不是在路由器下。 
  * 如果服务器在路由器下， 通过设置nat,将外网访问的请求的目的ip转换为局域网'192.168.<em>.</em>'，也能实现公网请求局域网的服务器</p>
<p>阿里云（相信大多数云厂商都支持） 可以支持动态改变dns的解析地址，即通过api调用就能改变dns的解析， 这样当出口ip变化时， 立即调用api来修改dns解析  </p>
<p>实现原理:</p>
<ol>
<li>定时检测出口ip, 例如每5分钟执行一次。 可以通过crontab和以下命令实现
<div class="highlight"><pre><span></span><code>curl https://httpbin.org/ip
</code></pre></div></li>
<li>通过阿里云的api操作dns</li>
<li>如果服务器在内网，添加nat规则，将目的ip转换为内网ip</li>
</ol>
<p>这里有个现成的<a href="https://github.com/NewFuture/DDNS">项目</a></p>
<h3 id="frp"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#frp">frp</a></h3>
<p>frp 就是内网穿透了， 没有出口ip的情况下，例如在路由器下且路由器不支持nat的时候， 或者是在运营商级NAT的模式下，就可以采取这中方式。 但是前提是需要有公网的服务器</p>
<p>实现原理：</p>
<ol>
<li>通过在公网服务器运行frp 服务端， 在没有出口ip的局域网服务器上运行frp客户端</li>
<li>客户端主动去连接服务端， 连接上之后， 服务端会为客户端创建一个端口， 所有的向这个端口的请求都被转发到局域网的服务器，实现公网访问局域网的服务器</li>
</ol>
<h3 id="wireguard"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#wireguard">wireguard</a></h3>
<p>wireguard的功能更加强大，配对后就相当于互连了，不需要frp那样配置端口服务。而且自带加密，更安全。</p>
<h3 id="zero-trust"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#zero-trust">zero-trust</a></h3>
<p>研究过一会，发现这个和wireguard非常类似的功能。而且zero-trust有cloudflare提供了公网接入点，所以公网服务器的钱也省了, 再加上zero-trust自带的加密，所以是连cloudflare也不能侵入。这就比国内的NAT服务安全多了。唯一缺点估计是zero-trust的公网接入点都在国外，所以延迟会高些。</p>
<h3 id="_1"><a class="toclink" href="../../../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#_1">总结</a></h3>
<p>如果有出口ip, 即使经常变化， 可以使用动态dns的技术实现暴露到公网， 成本低廉。 否则使用frp,需要额外购买服务器，或者使用花生壳类似的穿透技术， 但是有被掏裤裆的风险。
有公网服务器就用wireguard， 否则用zero-trust。</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-04 00:00:00+00:00">2021年1月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../../../2021/01/04/crash-boot/">前言</a></h2>
<p>元旦过完回公司发现archlinux 系统无法启动了， 提示没有找到内核之类的错误。 虽然也没有找到根本原因，只知道是内核镜像丢失了， 这里记一下解决办法</p>
<h2 id="_2"><a class="toclink" href="../../../../2021/01/04/crash-boot/#_2">现象</a></h2>
<p>启动之后， 提示缺少内核， 需要先指定内核。 回车后进入grub 界面。 在grub 界面可以执行ls (hd<em>,gpt</em>)/ 来查看分区的文件<br />
hd0、 hd1 代表的硬盘编号， gpt1、 gpt2、 gpt3 代表分区， ls (hd0, gpt1)/ 表示查看第一个硬盘第一个分区的文件</p>
<div class="highlight"><pre><span></span><code>ls (hd1, gpt2)
EFI  grub  initramfs-linux-fallback.img
</code></pre></div>
<p>我的boot分区是第二个硬盘的第二个分区， 可见确实没有 vmlinuz-linux 文件，也很奇怪</p>
<h3 id="_3"><a class="toclink" href="../../../../2021/01/04/crash-boot/#_3">解决办法</a></h3>
<p>没有 'vmlinuz-linux' 文件的话需要通过archlinux的U盘启动盘启动， 挂载分区后，arch-chroot 进入到坏系统  </p>
<p>执行重装linux 
<div class="highlight"><pre><span></span><code>pacman -S linux
</code></pre></div>
执行grub 相关命令， 重建引导配置。 我的EFI单独分区了</p>
<div class="highlight"><pre><span></span><code>grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=Arch
grub-config -o /boot/grub/grub.cfg
</code></pre></div>
<p><code>exit</code>退出坏系统，umount 再重启。 一定要umount 分区否则grub不会生效</p>
<h3 id="umount-grub"><a class="toclink" href="../../../../2021/01/04/crash-boot/#umount-grub">没有umount 导致的grub不生效</a></h3>
<p>因为没有umount，<code>exit</code>后直接重启， 发现依旧无法进入系统，还是进入了grub界面，好在linux内核镜像已经存在了，可以通过grub来配置启动<br />
所以这种情况也适用于系统ok，但引导损坏的情况。</p>
<h4 id="_4"><a class="toclink" href="../../../../2021/01/04/crash-boot/#_4">解决办法</a></h4>
<p>我的boot分区是(hd1,gpt2)</p>
<p>执行一下
<div class="highlight"><pre><span></span><code>set prefix=(hd1,gpt2)/grub/  # 指定实际的grub目录
set root=(hd1,gp2)
insmod normal
normal
</code></pre></div></p>
<p>此时grub会刷新， 继续执行
<div class="highlight"><pre><span></span><code>insmod linux
linux /vmlinuz-linux root=/dev/nvme0n1p2   # 设置内核
initrd /initd.img
boot
</code></pre></div></p>
<p>由于不知道nvme的命名方式，导致也挺麻烦， grub下可以看到uuid,但不能看到分区名称， 后来发现可以通过uuid方式指定root
<div class="highlight"><pre><span></span><code>insmod linux
linux /vmlinuz root=UUID=xxxxxxxxxxx
initrd /initd.img
boot
</code></pre></div></p>
<h3 id="_5"><a class="toclink" href="../../../../2021/01/04/crash-boot/#_5">扩充</a></h3>
<p>同样可以通过磁盘+分区的方式指定内核和initrd</p>
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <a class="md-pagination__link" href="../../">1</a> <a class="md-pagination__link" href="../2/">2</a> <a class="md-pagination__link" href="../3/">3</a> <span class="md-pagination__current">4</span>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../../../2022/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 2022">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                2022
              </div>
            </div>
          </a>
        
        
          
          <a href="../../../2020/" class="md-footer__link md-footer__link--next" aria-label="下一页: 2020">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                2020
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.tabs.sticky", "navigation.instant", "navigation.instant.progress", "navigation.footer", "toc.follow", "content.code.copy", "content.action.view"], "search": "../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../../../js/tex-mml-chtml.js"></script>
      
        <script src="../../../../js/mermaid.min.js"></script>
      
    
  </body>
</html>