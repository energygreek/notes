
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/page/10/">
      
      
      
        <link rel="next" href="../../tags/">
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>Welcome - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#welcome" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Welcome
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Welcome

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../archive/2025/" class="md-tabs__link">
          
  
  
    
  
  归档

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    
      
    
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="../.." class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#udp" class="md-nav__link">
    <span class="md-ellipsis">
      udp 的端口复用实现负载均衡
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dns" class="md-nav__link">
    <span class="md-ellipsis">
      阿里云动态设置 dns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#docker-overlay-filesystem" class="md-nav__link">
    <span class="md-ellipsis">
      docker overlay filesystem
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect-raspberry-and-arduino-via-i2c" class="md-nav__link">
    <span class="md-ellipsis">
      connect raspberry and arduino via i2c
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      C的宏定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    <span class="md-ellipsis">
      python 包的管理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system-calls-method" class="md-nav__link">
    <span class="md-ellipsis">
      system calls method
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#huawei-unlock-bootloader" class="md-nav__link">
    <span class="md-ellipsis">
      huawei unlock bootloader
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tags
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    归档
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2021/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2020/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2019
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#udp" class="md-nav__link">
    <span class="md-ellipsis">
      udp 的端口复用实现负载均衡
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dns" class="md-nav__link">
    <span class="md-ellipsis">
      阿里云动态设置 dns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#docker-overlay-filesystem" class="md-nav__link">
    <span class="md-ellipsis">
      docker overlay filesystem
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect-raspberry-and-arduino-via-i2c" class="md-nav__link">
    <span class="md-ellipsis">
      connect raspberry and arduino via i2c
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      C的宏定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    <span class="md-ellipsis">
      python 包的管理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system-calls-method" class="md-nav__link">
    <span class="md-ellipsis">
      system calls method
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#huawei-unlock-bootloader" class="md-nav__link">
    <span class="md-ellipsis">
      huawei unlock bootloader
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="welcome">Welcome<a class="headerlink" href="#welcome" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-15 00:00:00+00:00">2021年1月15日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="udp"><a class="toclink" href="../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">udp 的端口复用实现负载均衡</a></h2>
<h3 id="_1"><a class="toclink" href="../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_1">前言</a></h3>
<p>偶尔看到 python 3.9 的release note 里面提到一个bug
<div class="highlight"><pre><span></span><code>asyncio¶

出于重要的安全性考量，asyncio.loop.create_datagram_endpoint() 的 reuse_address 形参不再被支持。 这是由 UDP 中的套接字选项 SO_REUSEADDR 的行为导致的。 更多细节请参阅 loop.create_datagram_endpoint() 的文档。 （由 Kyle Stanley, Antoine Pitrou 和 Yury Selivanov 在 bpo-37228 中贡献。。）
</code></pre></div>
意思是tcp的socket option:SO_REUSEADDR不适用于udp：
在tcp中这个选项表示立即回收端口，减少 time_wait 的时间。而在udp中，这个选项表示多个socket可以绑定一个端口， 由内核来分发请求。</p>
<p>所以看到此功能，自己试了一下，确实如此， 顺便回顾一下知识</p>
<h3 id="_2"><a class="toclink" href="../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_2">主要代码</a></h3>
<div class="highlight"><pre><span></span><code>    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8888);
    inet_pton(AF_INET,&quot;127.0.0.1&quot;,(void*)&amp;addr.sin_addr);
    // inet_pton 支持ipv4和ipv6,是比较新的转换函数

    sfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sfd == -1)
    {
        perror(&quot;socket&quot;);
        exit(1);
    }
    int val = 1;
    if(0 != setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT,&amp;val, sizeof(val))){
        perror(&quot;setsockopt&quot;);
        exit(1);
    }
    /* sockaddr 和 sockaddr_in 有什么区别？
       struct sockaddr {  
        sa_family_t sin_family;//地址族
　　      char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息               
　　    }; 
　　    struct sockaddr_in {
　　      sa_family_t sin_family;//地址族
　　      uint16_t sin_port;
　　      struct in_addr sin_addr;    // 32 位地址
　　      char    sin_zero[8];    // reserve
　　    };
　　    struct in_addr {
　　      In_addr_t   s_addr;  //32位
　　    };
　　    
　　    sockaddr_in 和 sockaddr 长度相同，都 sin_family + 14 个字节，但是前者显式划分了
　　 */ 
    if(bind(sfd, (struct  sockaddr*) &amp;addr, sizeof(addr)) != 0)
    {
        perror(&quot;bind&quot;);
        exit(1);
    }
</code></pre></div>
<h3 id="_3"><a class="toclink" href="../../2021/01/15/udp-%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#_3">效果</a></h3>
<p>先启动两个服务端，再使用ncat 来模拟请求, </p>
<div class="highlight"><pre><span></span><code>ncat -uv 0.0.0.0 8888
</code></pre></div>
<p>启动ncat时，系统会分配给一个服务端处理。 但是重启ncat时， 会切换到另一个服务端处理</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-04 00:00:00+00:00">2021年1月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="dns"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/">阿里云动态设置 dns</a></h2>
<p>如果服务器的公网ip动态变化的情况下，如何访问，甚至如何通过域名访问？ </p>
<p>例如公司自己搭建的服务器如何暴露在公网上， 如果请求固定ip听说很贵， 还可以通过<code>frp</code>实现, 这里介绍2种方案</p>
<h3 id="dns_1"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#dns_1">动态dns</a></h3>
<p>前提是服务器有出口ip, 而不是在路由器下。 
  * 如果服务器在路由器下， 通过设置nat,将外网访问的请求的目的ip转换为局域网'192.168.<em>.</em>'，也能实现公网请求局域网的服务器</p>
<p>阿里云（相信大多数云厂商都支持） 可以支持动态改变dns的解析地址，即通过api调用就能改变dns的解析， 这样当出口ip变化时， 立即调用api来修改dns解析  </p>
<p>实现原理:</p>
<ol>
<li>定时检测出口ip, 例如每5分钟执行一次。 可以通过crontab和以下命令实现
<div class="highlight"><pre><span></span><code>curl https://httpbin.org/ip
</code></pre></div></li>
<li>通过阿里云的api操作dns</li>
<li>如果服务器在内网，添加nat规则，将目的ip转换为内网ip</li>
</ol>
<p>这里有个现成的<a href="https://github.com/NewFuture/DDNS">项目</a></p>
<h3 id="frp"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#frp">frp</a></h3>
<p>frp 就是内网穿透了， 没有出口ip的情况下，例如在路由器下且路由器不支持nat的时候， 或者是在运营商级NAT的模式下，就可以采取这中方式。 但是前提是需要有公网的服务器</p>
<p>实现原理：</p>
<ol>
<li>通过在公网服务器运行frp 服务端， 在没有出口ip的局域网服务器上运行frp客户端</li>
<li>客户端主动去连接服务端， 连接上之后， 服务端会为客户端创建一个端口， 所有的向这个端口的请求都被转发到局域网的服务器，实现公网访问局域网的服务器</li>
</ol>
<h3 id="wireguard"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#wireguard">wireguard</a></h3>
<p>wireguard的功能更加强大，配对后就相当于互连了，不需要frp那样配置端口服务。而且自带加密，更安全。</p>
<h3 id="zero-trust"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#zero-trust">zero-trust</a></h3>
<p>研究过一会，发现这个和wireguard非常类似的功能。而且zero-trust有cloudflare提供了公网接入点，所以公网服务器的钱也省了, 再加上zero-trust自带的加密，所以是连cloudflare也不能侵入。这就比国内的NAT服务安全多了。唯一缺点估计是zero-trust的公网接入点都在国外，所以延迟会高些。</p>
<h3 id="_1"><a class="toclink" href="../../2021/01/04/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-dns/#_1">总结</a></h3>
<p>如果有出口ip, 即使经常变化， 可以使用动态dns的技术实现暴露到公网， 成本低廉。 否则使用frp,需要额外购买服务器，或者使用花生壳类似的穿透技术， 但是有被掏裤裆的风险。
有公网服务器就用wireguard， 否则用zero-trust。</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-04 00:00:00+00:00">2021年1月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2021/01/04/crash-boot/">前言</a></h2>
<p>元旦过完回公司发现archlinux 系统无法启动了， 提示没有找到内核之类的错误。 虽然也没有找到根本原因，只知道是内核镜像丢失了， 这里记一下解决办法</p>
<h2 id="_2"><a class="toclink" href="../../2021/01/04/crash-boot/#_2">现象</a></h2>
<p>启动之后， 提示缺少内核， 需要先指定内核。 回车后进入grub 界面。 在grub 界面可以执行ls (hd<em>,gpt</em>)/ 来查看分区的文件<br />
hd0、 hd1 代表的硬盘编号， gpt1、 gpt2、 gpt3 代表分区， ls (hd0, gpt1)/ 表示查看第一个硬盘第一个分区的文件</p>
<div class="highlight"><pre><span></span><code>ls (hd1, gpt2)
EFI  grub  initramfs-linux-fallback.img
</code></pre></div>
<p>我的boot分区是第二个硬盘的第二个分区， 可见确实没有 vmlinuz-linux 文件，也很奇怪</p>
<h3 id="_3"><a class="toclink" href="../../2021/01/04/crash-boot/#_3">解决办法</a></h3>
<p>没有 'vmlinuz-linux' 文件的话需要通过archlinux的U盘启动盘启动， 挂载分区后，arch-chroot 进入到坏系统  </p>
<p>执行重装linux 
<div class="highlight"><pre><span></span><code>pacman -S linux
</code></pre></div>
执行grub 相关命令， 重建引导配置。 我的EFI单独分区了</p>
<div class="highlight"><pre><span></span><code>grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=Arch
grub-config -o /boot/grub/grub.cfg
</code></pre></div>
<p><code>exit</code>退出坏系统，umount 再重启。 一定要umount 分区否则grub不会生效</p>
<h3 id="umount-grub"><a class="toclink" href="../../2021/01/04/crash-boot/#umount-grub">没有umount 导致的grub不生效</a></h3>
<p>因为没有umount，<code>exit</code>后直接重启， 发现依旧无法进入系统，还是进入了grub界面，好在linux内核镜像已经存在了，可以通过grub来配置启动<br />
所以这种情况也适用于系统ok，但引导损坏的情况。</p>
<h4 id="_4"><a class="toclink" href="../../2021/01/04/crash-boot/#_4">解决办法</a></h4>
<p>我的boot分区是(hd1,gpt2)</p>
<p>执行一下
<div class="highlight"><pre><span></span><code>set prefix=(hd1,gpt2)/grub/  # 指定实际的grub目录
set root=(hd1,gp2)
insmod normal
normal
</code></pre></div></p>
<p>此时grub会刷新， 继续执行
<div class="highlight"><pre><span></span><code>insmod linux
linux /vmlinuz-linux root=/dev/nvme0n1p2   # 设置内核
initrd /initd.img
boot
</code></pre></div></p>
<p>由于不知道nvme的命名方式，导致也挺麻烦， grub下可以看到uuid,但不能看到分区名称， 后来发现可以通过uuid方式指定root
<div class="highlight"><pre><span></span><code>insmod linux
linux /vmlinuz root=UUID=xxxxxxxxxxx
initrd /initd.img
boot
</code></pre></div></p>
<h3 id="_5"><a class="toclink" href="../../2021/01/04/crash-boot/#_5">扩充</a></h3>
<p>同样可以通过磁盘+分区的方式指定内核和initrd</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-18 00:00:00+00:00">2020年11月18日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/">二叉树遍历</a></h2>
<h3 id="_2"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_2">二叉树定义</a></h3>
<p>二叉树的父节点最多有2个子节点，如果二叉树的所有父节点没有节点或者有2个节点，那么叫完全二叉树</p>
<h3 id="_3"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_3">二叉树的遍历方式</a></h3>
<p>二叉树有4中遍历方式： 前序遍历， 中序， 后序， 以及层序  </p>
<p>前三种可以对比着看，区别在于父节点先被访问的顺序，这里的先后都是相对于同一个树而言。 这里的访问意思是访问其值， 例如打印节点的数据：<br />
  * 前序遍历， 先父节点，再左子节点，最后是右子节点 
  * 中序遍历， 先左子节点， 再父节点， 最后是右子节点
  * 中序遍历， 先左子节点， 再右子节点 ，最后父节点</p>
<p>可见，都是先左子节点后右子节点  </p>
<p>而层序遍历是从上往下，广度优先</p>
<h3 id="_4"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_4">效果</a></h3>
<p>若有以下二叉树，则遍历结果
<pre class="mermaid"><code>graph BT
    A[1] --&gt; B[0]
    C[2] --&gt; B
    D[3] --&gt; A
    E[4] --&gt; A
    F[5] --&gt; C
    G[6] --&gt; C
    H[7] --&gt; D
    I[8] --&gt; D
    J[9] --&gt; E</code></pre></p>
<p>层序: 0 1 2 3 4 5 6 7 8 9</p>
<p>先序: <u>0</u> 1 <u>3</u> 7 8 4 9 2 5 <u>6</u><br />
中序: 7 <u>3</u> 8 1 9 4 <u>0</u> 5 2 <u>6</u><br />
后序: 7 8 <u>3</u> 9 4 1 5 <u>6</u> 2 <u>0</u>  </p>
<p>注意下划线，即036组成的一个树， 可以证实上面的总结  </p>
<h3 id="_5"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_5">代码实现</a></h3>
<p>实现前三种遍历都有2种方式， 递归和使用stack</p>
<p>节点数据结构
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">Node</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lchild</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<h4 id="_6"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_6">递归实现</a></h4>
<p>前序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<p>中序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<p>后序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_recursion</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_recursion</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
</code></pre></div></p>
<h4 id="stack"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#stack">stack实现</a></h4>
<p>前序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Front_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Node</span> <span class="o">=</span> <span class="n">root</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">Node</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">Node</span><span class="p">:</span>
            <span class="c1"># 访问和入栈的顺序顺序是先父节点后左节点</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
            <span class="c1"># 父节点入栈</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="c1"># 深度优先，找最左节点，下个循环就是先访问父节点后左子节点</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>
        <span class="c1"># 这里需要好好体会，父节点和左子节点已经访问过，只剩下右节点</span>
        <span class="c1"># 所以就是先左后右</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<p>中序遍历
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Middle_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Node</span> <span class="o">=</span> <span class="n">root</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">Node</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">Node</span><span class="p">:</span>
            <span class="c1"># 父节点入栈</span>
            <span class="c1"># 左子节点入栈</span>
            <span class="c1"># 但都不访问，因为压栈顺序是先父后左子，到出栈的时候再访问</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>

        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># 找到最左子节点了，开始出栈，所以肯定是先出左节点， 然后再出栈之后就是父节点</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># 最后就是右节点， 回到第一个while 继续找右子树的最左节点</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span>
</code></pre></div></p>
<p>后序的stack比较复杂</p>
<p>还有一个比较简单的先序stack
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Front_stack</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># stack 先进后出，所以先压右节点</span>
        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
</code></pre></div></p>
<p>层序遍历,是广度优先的一种方式，所以使用到queue
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Layer_queue</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># 取前面的</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
</code></pre></div></p>
<h4 id="_7"><a class="toclink" href="../../2020/11/18/binary-tree-traversal/#_7">后序栈遍历</a></h4>
<p>后序遍历的顺序是先左子后右子，最后才是父节点</p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">1. 同样先找到最左边的节点，父节点和左子节点入栈</span>
<span class="sd">2. 找到最后一个左子节点之后，判断栈顶的节点，出栈顺序是先左子后父节点，所以只需要判断右子节点的情况：</span>
<span class="sd">   如果栈顶节点的右子节点为空，直接打印栈顶节点。 如果栈顶节点的右子节点是上一个出栈的节点，那么说明已经访问到了右子节点，可以继续打印父节点  </span>
<span class="sd">   如果栈顶的右子节点不为空也不是上一个访问的节点，所以要先去访问右子树， 将右子节点入栈，退出循环，执行第一步</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">back_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Tag</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">lchild</span><span class="p">)</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">lchild</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Tag</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">or</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
                <span class="n">Tag</span> <span class="o">=</span> <span class="n">Node</span>
            <span class="k">elif</span> <span class="n">Node</span><span class="o">.</span><span class="n">rchild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">rchild</span><span class="p">)</span>
                <span class="k">break</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-18 00:00:00+00:00">2020年11月18日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="docker-overlay-filesystem"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/">docker overlay filesystem</a></h2>
<p>overlay 是docker使用的文件系统，具有分层的特点, docker使用的文件系统经过很多变化，而且各发行版可能不同。<br />
执行<code>docker info</code> 查看当前使用的是overlay2</p>
<div class="highlight"><pre><span></span><code>sudo docker info | grep -i storage                                                                                                                                              
 Storage Driver: overlay2
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_1">历史</a></h3>
<p>除了 overlay，类似有rootfs， aufs （ubuntu）， devicemapper（centos），不够成熟的btrfs</p>
<p>他们都有2个目的：<br />
1. 提供不含内核的文件系统（rootfs）即容器, 在内核之上。这是docker 最有价值的地方，就是无论在那里运行docker， 容器里的环境都是一致的
2. 提供分层</p>
<h3 id="overlay"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay">overlay的优势</a></h3>
<ol>
<li>page caching， 可以在多个不同实例之间共享</li>
<li>写时复制， 只有执行write操作时， 会将lower layer 的文件复制到container层</li>
<li>不同层之间，相同文件使用硬连接， 节省inode 和 大小</li>
</ol>
<p>写时复制 copy-up 会导致第一次写时造成延迟，特别是大文件，拷贝起来费时。 但第二次就不会延时， 而且overlay2 有caching， 相比其它文件系统，更减少延时</p>
<h3 id="overlay_1"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay_1">overlay的问题</a></h3>
<ol>
<li>实现不够完全， 例如没有实现uname </li>
<li>先只读打开一个文件 open（read）， 再读写打开相同文件open（write）， 两个fd 会对应2个不同文件， 第一个对应的lower的文件，第二个造成写时复制，对应容器里的文件。 </li>
<li>规避方法是先执行touch 操作。 现实的例子是 yum 需要安装yum-plugin-ovl。 但这个只有7.2才支持， 之前的话就需要先<code>touch /var/lib/rpm/*</code></li>
</ol>
<h3 id="_2"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_2">最佳实践</a></h3>
<ol>
<li>使用ssd </li>
<li>对于写操作比较多的目录， 使用映射文件。这样跳过了overlay的复杂操作，直接使用主机的文件系统。</li>
</ol>
<h3 id="_3"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_3">分层介绍</a></h3>
<p>我理解就是将分离的多个目录挂载到一起的技术。
例如对docker 容器的文件进行增删改后，再commit， 会多一层layer。 
再当docker 容器启动时，会自动挂载多层layer。 
<strong><em>组织</em></strong>： overlay对运行的实例通过元数据组织文件， 是否是link文件 </p>
<div class="highlight"><pre><span></span><code>ls 04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/
diff  link  lower  merged  work
</code></pre></div>
<h4 id="mount"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#mount">手动mount的例子</a></h4>
<ol>
<li>原本目录，文件都分散在不同目录ABC
<div class="highlight"><pre><span></span><code>.
├── A
│   ├── aa
│   └── a.txt
├── B
│   ├── a.txt
│   └── b.txt
├── C
│   └── c.txt
└── worker
    └── work [error opening dir]
</code></pre></div></li>
<li>overlay 挂载到/tmp/test目录 <code>sudo mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /tmp/test/</code></li>
<li>查看test目录 
<div class="highlight"><pre><span></span><code>/tmp/test/
├── aa
├── a.txt
├── b.txt
└── c.txt
</code></pre></div>
<div class="highlight"><pre><span></span><code>mount  | grep &#39;overlay&#39;
overlay on /tmp/test type overlay (rw,relatime,lowerdir=A:B,upperdir=C,workdir=worker)
</code></pre></div></li>
</ol>
<h4 id="overlay_2"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#overlay_2">overlay的增删改</a></h4>
<p>当运行docker容器时查看挂载</p>
<p><div class="highlight"><pre><span></span><code>overlay on /var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/merged type overlay 
(rw,relatime,
    lowerdir=/var/lib/docker/overlay2/l/B74PWZCBMRCWXFH5UL2ZXB5WEU:/var/lib/docker/overlay2/l/WNHICVPVSDNUGSCZW435TPSMOK,
    upperdir=/var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/diff,
    workdir=/var/lib/docker/overlay2/04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2/work
)
</code></pre></div>
docker 将镜像的文件挂载为只读， 将容器层挂载为可读可写。 文件系统可以分为2部分
upper（容器层） + lower （镜像层）</p>
<ul>
<li>当在容器里执行写时， 如果文件不存在， 会依次遍历lower。如果都不存在就会在upper层创建文件</li>
<li>读也相同</li>
<li>删除时会创建一个without 来隐藏， 这是为什么即使删除容器里的文件， 镜像还是会增大。 </li>
<li>删除目录情况也差不多</li>
</ul>
<p>似乎很奇怪，为什么多了一个workdir,  据说这个目录总是空的，为了实现原子操作添加和删除文件</p>
<h4 id="_4"><a class="toclink" href="../../2020/11/18/docker-overlay-filesystem/#_4">特殊情况</a></h4>
<p>在修改容器后， 容器系统会多一层， 里面包含了修改的文件，以及删除后生成的without文件， 然后生成镜像</p>
<p>但对于以下特殊目录文件不会提交， 因为这些文件是运行时docker 要根据用户配置进行修改的。  </p>
<ol>
<li>/etc/hostname </li>
<li>/etc/hosts </li>
<li>/etc/resov.conf</li>
</ol>
<p>例如docker 的link选项，会在容器的hosts 文件里定义对应的容器名-&gt;容器ip</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-12 00:00:00+00:00">2020年11月12日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="connect-raspberry-and-arduino-via-i2c"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/">connect raspberry and arduino via i2c</a></h2>
<h3 id="_1"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#_1">准备</a></h3>
<p>先接线，然后启动 arduino, 最后在树莓派中验证和读写。</p>
<h4 id="gnd-sda-scl"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#gnd-sda-scl">连接两个设备的GND SDA SCL</a></h4>
<p>树莓派的SDA连arduino的SDA，SCL接SCL，这跟串口的接线不一样（RX接TX,TX接RX）。</p>
<p><img alt="alt text" src="../../img/arduino_nano_sda_scl_pins.png" /></p>
<p><img alt="alt text" src="../../img/raspberry_pi_zerow_sda_scl_pins.png" /></p>
<h4 id="arduino"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#arduino">启动arduino</a></h4>
<p>arduino 从端代码，注册了i2c的地址为0x08</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Wire.h&gt;</span>
<span class="cp">#define SLAVE_ADDRESS 0x08</span>
<span class="n">byte</span><span class="w"> </span><span class="n">data_to_echo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">SLAVE_ADDRESS</span><span class="p">);</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="n">receiveData</span><span class="p">);</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">onRequest</span><span class="p">(</span><span class="n">sendData</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">receiveData</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bytecount</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bytecount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data_to_echo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sendData</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Wire</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data_to_echo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="i2c"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#i2c">树莓派开启i2c</a></h4>
<p>进入树莓派终端执行<code>raspi-config</code> 开启I2c功能，重启后执行命令<code>i2cdetect -y 1</code>，可以看到bus上的设备。</p>
<h4 id="master"><a class="toclink" href="../../2020/11/12/connect-raspberry-and-arduino-via-i2c/#master">树莓派的master端读写操作代码</a></h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/i2c-dev.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;i2c/smbus.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span>

<span class="cp">#define DEVICE_ID 0x08</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Setup I2C communication</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/i2c-1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to init I2C communication.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ioctl</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">I2C_SLAVE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE_ID</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I2C communication successfully setup.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Send data to arduino</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span>
<span class="w">    </span><span class="n">i2c_smbus_write_byte</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Read data from arduino</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">received_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_read_byte</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">received_data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Success!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-10 00:00:00+00:00">2020年11月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="c"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/">C的宏定义</a></h2>
<p>宏定义是在c/c++里特有的方式， 像变量一样， 又像模板编程一样， 但最常见的用法还是做头文件的唯一性保证  </p>
<p>在每一个头文件都套用这种格式，就可以避免多次引入头文件而导致的重复定义报错</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef FILE_NAME</span>
<span class="cp">#def FILE_NAME</span>

<span class="c1">// 代码</span>

<span class="cp">#endif FILE_NAME</span>
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_1">原理</a></h3>
<p>宏定义与变量、模板的最大区别在与处理的时期， 宏定义在预编译时处理， 而变量和模板函数则是在编译期处理。
查看预编译后的代码可以使用命令<code>gcc -E</code> 或者 <code>cpp</code>， 实际上是前者是调用了后者</p>
<div class="highlight"><pre><span></span><code>NAME
       cpp - The C Preprocessor
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_2">用法</a></h3>
<p>除了<code>#ifdef</code> 的用法，宏定义可以分两种类型，变量型和函数型</p>
<h4 id="_3"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_3">变量型</a></h4>
<p>这个最简单，就像使用变量一样，先define 然后再使用</p>
<p><div class="highlight"><pre><span></span><code><span class="cp"># marco.c</span>
<span class="cp">#define BUFFER_SIZE 1024</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="w"> </span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
执行 <code>gcc -E marco.c</code> 得到
<div class="highlight"><pre><span></span><code><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</code></pre></div></p>
<p>多行使用 '\' 来连接
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#define GREETING_STR \</span>
<span class="cp">  &quot;hello \</span>
<span class="cp">world&quot;</span>
</code></pre></div></p>
<ul>
<li>注意, 宏定义的定义不分前后， 也不像变量那样先定义再使用， 宏定义可以先使用后定义  </li>
</ul>
<p>以下两种方式的效果相同</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define GREETING_NAME &quot;wayou&quot;</span>

<span class="cp">#define GREETING &quot;hello,&quot; GREETING_NAME</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="n">printf</span><span class="p">(</span><span class="n">GREETING</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="gi">+#define GREETING &quot;hello,&quot; GREETING_NAME</span>

#define GREETING_NAME &quot;wayou&quot;

<span class="gd">-#define GREETING &quot;hello,&quot; GREETING_NAME</span>

int main() {
printf(GREETING);
return 0;
}
</code></pre></div>
<h4 id="_4"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_4">函数型</a></h4>
<p>函数类型的宏，可以像正常函数一样指定入参，入参需为逗号分隔合法的 C 字面量。
宏的参数必须要用括号包起来，否则当参数为表达式时，会出错</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">          </span><span class="err">→</span><span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">          </span><span class="err">→</span><span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w">    </span><span class="err">→</span><span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>
<span class="w"> </span><span class="err">```</span>

<span class="cp">### 宏定义字符串化</span>

<span class="n">当宏定义的参数被引号包起来时</span><span class="err">，</span><span class="w"> </span><span class="n">不会进行替换</span><span class="err">，</span><span class="n">如下</span>
<span class="err">```</span><span class="n">c</span>
<span class="cp">#define foo(x) x, &quot;x&quot;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w">        </span><span class="err">→</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span>
</code></pre></div>
<p>加入需要将参数替换到字符串里， 可以使用'#'  </p>
<div class="highlight"><pre><span></span><code><span class="cp">#define WARN_IF(EXP) \</span>
<span class="cp">do { if (EXP) \</span>
<span class="cp">        fprintf (stderr, &quot;Warning: &quot; #EXP &quot;\n&quot;); } \</span>
<span class="cp">while (0)</span>
<span class="n">WARN_IF</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">     </span><span class="err">→</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">           </span><span class="n">fprintf</span><span class="w"> </span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Warning: &quot;</span><span class="w"> </span><span class="s">&quot;x == 0&quot;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>而当 这里的x 也是宏定义时， 只有if里的x会替换， 字符串里的x则不会替换  </p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#define X ( 1 - 1 )</span>
<span class="n">WARN_IF</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
会被替换为  </p>
<div class="highlight"><pre><span></span><code><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">fprintf</span><span class="w"> </span><span class="p">(</span>
<span class="n">stderr</span>
<span class="p">,</span><span class="w"> </span><span class="s">&quot;Warning: &quot;</span><span class="w"> </span><span class="s">&quot;X == 0&quot;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<h4 id="_5"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_5">拼接</a></h4>
<p>通过 ## 可将两个宏展开成一个，即将两者进行了拼接，宏拼接一般用在需要拼接的宏是来自宏参数的情况，<br />
其他情况，大可直接将两个宏写在一起即可</p>
<p>当有以下情况时非常有用
<div class="highlight"><pre><span></span><code>struct command
{
  char *name;
  void (*function) (void);
};

struct command commands[] =
{
{ &quot;quit&quot;, quit_command },
{ &quot;help&quot;, help_command },
…
};
</code></pre></div></p>
<p>可以使用如下：
<div class="highlight"><pre><span></span><code><span class="cp">#define COMMAND(NAME)  { #NAME, NAME ## _command }</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">command</span><span class="w"> </span><span class="n">commands</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span>
<span class="p">{</span>
<span class="n">COMMAND</span><span class="w"> </span><span class="p">(</span><span class="n">quit</span><span class="p">),</span>
<span class="n">COMMAND</span><span class="w"> </span><span class="p">(</span><span class="n">help</span><span class="p">),</span>
<span class="err">…</span>
<span class="p">};</span>
</code></pre></div></p>
<h4 id="_6"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_6">不定参数和混合参数</a></h4>
<p>宏定义也可以使用不定参数
<div class="highlight"><pre><span></span><code><span class="cp">#define eprintf(args…) fprintf (stderr, args)</span>
<span class="c1">// or</span>
<span class="cp">#define eprintf(…) fprintf (stderr, __VA_ARGS__)</span>
</code></pre></div></p>
<p>也可以使用混合参数
<div class="highlight"><pre><span></span><code><span class="cp">#define eprintf(format, args...) fprintf (stderr, format, args)</span>
</code></pre></div>
这个可以常在格式化打印时用到， 例如 <code>spdlog</code> 库  </p>
<div class="highlight"><pre><span></span><code><span class="cp">#define SPDLOG_LOGGER_CALL(logger, level, ...)                                                                                             \</span>
<span class="cp">    if (logger-&gt;should_log(level))                                                                                                         \</span>
<span class="cp">    logger-&gt;log(spdlog::source_loc{SPDLOG_FILE_BASENAME(__FILE__), __LINE__, SPDLOG_FUNCTION}, level, __VA_ARGS__)</span>

<span class="cp">#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_TRACE</span>
<span class="cp">#define SPDLOG_LOGGER_TRACE(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::trace, __VA_ARGS__)</span>
<span class="cp">#define SPDLOG_TRACE(...) SPDLOG_LOGGER_TRACE(spdlog::default_logger_raw(), __VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define SPDLOG_LOGGER_TRACE(logger, ...) (void)0</span>
<span class="cp">#define SPDLOG_TRACE(...) (void)0</span>
<span class="cp">#endif</span>

<span class="cp">#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_DEBUG</span>
<span class="cp">#define SPDLOG_LOGGER_DEBUG(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::debug, __VA_ARGS__)</span>
<span class="cp">#define SPDLOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define SPDLOG_LOGGER_DEBUG(logger, ...) (void)0</span>
<span class="cp">#define SPDLOG_DEBUG(...) (void)0</span>
<span class="cp">#endif</span>
</code></pre></div>
<h3 id="_7"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_7">重复和覆盖</a></h3>
<p>这些是相似的：
<div class="highlight"><pre><span></span><code><span class="cp">#define FOUR (2 + 2)</span>
<span class="cp">#define FOUR         (2    +    2)</span>
<span class="cp">#define FOUR (2 </span><span class="cm">/* two */</span><span class="cp"> + 2)</span>
</code></pre></div></p>
<p>以下都是不同的宏
<div class="highlight"><pre><span></span><code><span class="cp">#define FOUR (2 + 2)</span>
<span class="cp">#define FOUR ( 2+2 ) </span><span class="c1">// 空白位置不一样 </span>
<span class="cp">#define FOUR (2 * 2) </span><span class="c1">// 宏的内容不一样</span>
<span class="cp">#define FOUR(score,and,seven,years,ago) (2 + 2) </span><span class="c1">// 入参不一样</span>
</code></pre></div></p>
<p>对于使用了 <code>#undef</code> 注销过的宏，再次定义同名的宏时，要求新定义的宏不与老的相似。</p>
<p>而如果说一个已经存在的宏，并没有注销，重复定义时，如果相似，则新的定义会忽略，如果不相似，编译器会报警告同时使用新定义的宏。这允许在多个文件中定义同一个宏。</p>
<h3 id="_8"><a class="toclink" href="../../2020/11/10/advanced-marco-in-c/#_8">最后</a></h3>
<p>可以查看更多<a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros">内置宏定义</a></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-10 00:00:00+00:00">2020年11月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="python"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/">python 包的管理</a></h2>
<p>python 有 sdist 和 wheel 两种方式管理包：</p>
<p>sdist 是在 <code>python setup.py sdist</code>时产生的包，是一个源码压缩包，在安装时需要编译，所以环境依赖make和gcc<br />
wheel 是在<code>python setup.py  bdist_wheel</code>是产生的whl 格式包</p>
<p>从命令都可以看出来sdist即source源码包， bdist 即binary二进制包  </p>
<p>sdist 由distutils、setuptools 定义和依赖的编译系统， 可以运行任意的代码<br />
wheel 包为编译和安装时提供了简单的接口，里面包含了二进制的包，可以让安装者不需要知道编译体系,依赖wheel
<div class="highlight"><pre><span></span><code>pip install wheel
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/#_1">两种包的打包命令</a></h3>
<p>前提是环境安装了setuptools和wheel, 且编写了setup.py文件如  </p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># setup.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">setuptools</span><span class="w"> </span><span class="kn">import</span> <span class="n">setup</span><span class="p">,</span><span class="n">find_namespace_packages</span>
<span class="c1">#import pathlib</span>
<span class="c1">#import pkg_resources</span>
<span class="c1">#import os</span>
<span class="c1">#import sys</span>

<span class="c1">#sys.path.insert(0, os.path.join(</span>
<span class="c1">#    os.path.dirname(os.path.abspath(__file__)), &#39;src&#39;))</span>

<span class="c1"># 解析文本文件</span>
<span class="c1">#with pathlib.Path(&#39;requirements.txt&#39;).open() as requirements_txt:</span>
<span class="c1">#    install_requires = [str(requirement) for requirement in pkg_resources.parse_requirements(requirements_txt) ]</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;myflask&#39;</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.3&#39;</span><span class="p">,</span>
      <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
            <span class="s1">&#39;Bootstrap-Flask==1.4&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Flask==1.1.2&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Flask-Login==0.5.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;SQLAlchemy==1.3.18&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Werkzeug==1.0.1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;WTForms==2.3.1&#39;</span>
          <span class="p">],</span>
      <span class="n">entry_points</span><span class="o">=</span><span class="p">{</span>
             <span class="s1">&#39;console_scripts&#39;</span><span class="p">:[</span>
                   <span class="s1">&#39;myflask=wsgi:main&#39;</span>
                   <span class="p">]</span>
            <span class="p">},</span>
      <span class="n">package_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.html&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.css&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;*.js&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;static/*&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;templates/*&#39;</span><span class="p">],</span>
      <span class="p">},</span>
      <span class="n">py_modules</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;myflask&#39;</span><span class="p">],</span>
      <span class="n">packages</span><span class="o">=</span><span class="n">find_namespace_packages</span><span class="p">(),</span>
      <span class="n">zip_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
      <span class="n">include_package_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
      <span class="p">)</span>
</code></pre></div>
我这里定义了安装模块，myflask,可以被uwsgi 文件引入，方便管理， 同时也加入了很多html的静态文件， 是一个完整的网站  </p>
<ol>
<li>
<p>生成sdist包， 在项目目录执行<code>python setup.py sdist</code>，可以在sdit目录看到tar包
<div class="highlight"><pre><span></span><code><span class="c1"># myflask &gt; ls dist                                                                                                                                                                                                      </span>
myflask-1.3.tar.gz
</code></pre></div></p>
</li>
<li>
<p>生成wheel包，在项目目录执行<code>python setup.py bdist_wheel</code>，可以在sdit目录看到whl包
<div class="highlight"><pre><span></span><code># myflask &gt; ls dist
myflask-1.3-py3-none-any.whl  myflask-1.3.tar.gz
</code></pre></div></p>
</li>
</ol>
<h3 id="_2"><a class="toclink" href="../../2020/11/10/python-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/#_2">安装</a></h3>
<p>安装命令相同，<code>pip install myflask-1.3.tar.gz</code> <code>pip instal myflask-1.3-py3-none-any.whl</code>。但过程不同</p>
<p>举例安装yarl 的源码包, 源码包需要编译，如果环境没有gcc,就会安装失败
<div class="highlight"><pre><span></span><code>Collecting yarl&lt;2.0,&gt;=1.0 (from aiohttp==3.6.2)
  Downloading yarl-1.6.2.tar.gz (177kB)
  Installing build dependencies: started
  Installing build dependencies: finished with status &#39;done&#39;
  Getting requirements to build wheel: started
  Getting requirements to build wheel: finished with status &#39;done&#39;
    Preparing wheel metadata: started
    Preparing wheel metadata: finished with status &#39;done&#39;
...

  gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/opt/ha/include/python3.8 -c yarl/_quoting_c.c -o build/temp.linux-x86_64-3.8/yarl/_quoting_c.o
  error: command &#39;gcc&#39; failed with exit status 1
  ----------------------------------------
  ERROR: Failed building wheel for yarl
  Running setup.py clean for yarl
Failed to build yarl
</code></pre></div></p>
<p>此时，如果使用wheel包就不会出问题，但如果wheel包里面依赖了二进制文件，则需要区分cpu架构和系统了<br />
我的myflask不依赖任何二进制文件，所以是none, 所有cpu和系统都可以安装<br />
<div class="highlight"><pre><span></span><code>myflask-1.3-py3-none-any.whl 
</code></pre></div>
对于yarl不同， 在pypi.org 下载时，需要选择正确的包。或者选择源码包<code>yarl-1.6.2.tar.gz</code>来安装编译  </p>
<p>当然如果让pip选择在线安装就不需要考虑， 他会自动帮你寻找对应你系统的版本</p>
<div class="highlight"><pre><span></span><code>Download files

Download the file for your platform. If you&#39;re not sure which to choose, learn more about installing packages.
Files for yarl, version 1.6.2
Filename, size  File type   Python version  Upload date     Hashes
yarl-1.6.2-cp36-cp36m-macosx_10_14_x86_64.whl (128.3 kB)    Wheel   cp36    Oct 13, 2020    View
yarl-1.6.2-cp36-cp36m-manylinux1_i686.whl (293.5 kB)    Wheel   cp36    Oct 13, 2020    View
yarl-1.6.2-cp36-cp36m-manylinux2014_aarch64.whl (294.5 kB)  Wheel   cp36    Oct 13, 2020    View

...

yarl-1.6.2.tar.gz (177.5 kB)    Source  None    Oct 13, 2020    View 
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-09 00:00:00+00:00">2020年11月9日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="system-calls-method"><a class="toclink" href="../../2020/11/09/system-calls-method/">system calls method</a></h2>
<p>之前学汇编发现教材和实际的有出入， 书上写的int, 但是汇编不通过，而gcc 反汇编的结果是调用syscall。<br />
原来这是两种方式调用方式即： int  0x80 和 syscall  </p>
<p>除此之外还有一个名词是vdso,  很多elf文件会链接这个vdso库</p>
<div class="highlight"><pre><span></span><code>ldd a.out                                                                                                                                                                                                                   √ 19:03:30 
    linux-vdso.so.1 (0x00007fffb3de0000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f5b48d4a000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5b48f36000)
</code></pre></div>
<h3 id="_1"><a class="toclink" href="../../2020/11/09/system-calls-method/#_1">词汇说明</a></h3>
<p><code>int 0x80</code> 即80中断， 是最老的系统函数调用方式
<code>syscall/sysret</code> 是amd64 制定的标准， 也是目前的x86 64位的标准，即<code>amd64</code>
<code>sysenter/syssysexit</code> 是inter制定的x86 64位标准， 目前已被放弃
<code>vdso</code> 是linux内核虚拟出的so, 实现了int 80 和 syscall，调用方式为 <code>vsyscall</code></p>
<h3 id="_2"><a class="toclink" href="../../2020/11/09/system-calls-method/#_2">系统函数调用路径</a></h3>
<p>系统调用多被封装成库函数提供给应用程序调用，应用程序调用库函数后，由 glibc 库负责进入内核调用系统调用函数。
即<code>用户函数-&gt; glibc -&gt; 系统调用</code></p>
<h3 id="int-0x80"><a class="toclink" href="../../2020/11/09/system-calls-method/#int-0x80">int 0x80</a></h3>
<p>int 即是interrupt 中断， 0x80是IDT上注册的中断向量， 每个编号对应一个处理函数handle， linux的0x80的handle即是内核，即系统调用。
所以不同的系统设置的0x80的handle可能不同</p>
<p>调用方式：首先是将参数复制到寄存器， 参数包括系统调用编号和传入参数，然后执行 init  0x80 
例如，以下的进程退出的系统调用
<div class="highlight"><pre><span></span><code>.data
    s:
        .ascii &quot;hello world\n&quot;
        len = . - s
.text
    .global _start
    _start:

        movl $4, %eax   /* write system call number */
        movl $1, %ebx   /* stdout */
        movl $s, %ecx   /* the data to print */
        movl $len, %edx /* length of the buffer */
        int $0x80

        movl $1, %eax   /* 退出的系统调用编号 */
        movl $0, %ebx   /* exit status */
        int $0x80
</code></pre></div></p>
<h3 id="vdos"><a class="toclink" href="../../2020/11/09/system-calls-method/#vdos">vdos</a></h3>
<p>vdos即 linux-vdso.so.1， 几乎很多elf 都会链接这个库，但其实他并不是真实存在的so文件，<br />
而是由内核虚拟的文件，再映射到用户的进程来调用。</p>
<p>vdos  是对以下几个函数的实现，称作快速调用</p>
<div class="highlight"><pre><span></span><code>#define __NR_gettimeofday 96 //0x60
#define __NR_time 201 //0xc9
#define __NR_clock_gettime 228 //0xE4
#define __NR_getcpu 309 //0x135
</code></pre></div>
<h3 id="_3"><a class="toclink" href="../../2020/11/09/system-calls-method/#_3">对比</a></h3>
<p>所以以上总结其实就3种方式， int ，syscall/sysret ， vdso</p>
<p>int 0x80 方式很慢，所以出现了syscall 即快速调用</p>
<p>执行区别
<div class="highlight"><pre><span></span><code>在 x86 保护模式中，处理 INT 中断指令时，CPU 首先从中断描述表 IDT 取出对应的门描述符，判断门描述符的种类，然后检查门描述符的级别 DPL 和 INT 指令调用者的级别 CPL，当 CPL&lt;=DPL 也就是说 INT 调用者级别高于描述符指定级别时，才能成功调用，最后再根据描述符的内容，进行压栈、跳转、权限级别提升。内核代码执行完毕之后，调用 IRET 指令返回，IRET 指令恢复用户栈，并跳转会低级别的代码。

其实，在发生系统调用，由 Ring3 进入 Ring0 的这个过程浪费了不少的 CPU 周期，例如，系统调用必然需要由 Ring3 进入 Ring0（由内核调用 INT 指令的方式除外，这多半属于 Hacker 的内核模块所为），权限提升之前和之后的级别是固定的，CPL 肯定是 3，而 INT 80 的 DPL 肯定也是 3，这样 CPU 检查门描述符的 DPL 和调用者的 CPL 就是完全没必要。正是由于如此，Intel x86 CPU 从 PII 300（Family 6，Model 3，Stepping 3）之后，开始支持新的系统调用指令 sysenter/sysexit。sysenter 指令用于由 Ring3 进入 Ring0，SYSEXIT 指令用于由 Ring0 返回 Ring3。由于没有特权级别检查的处理，也没有压栈的操作，所以执行速度比 INT n/IRET 快了不少。
</code></pre></div></p>
<p>返回的区别
<div class="highlight"><pre><span></span><code>在 Intel 的手册中，还提到了 sysenter/sysexit 和 int n/iret 指令的一个区别，那就是 sysenter/sysexit 指令并不成对，sysenter 指令并不会把 SYSEXIT 所需的返回地址压栈，sysexit 返回的地址并不一定是 sysenter 指令的下一个指令地址。调用 sysenter/sysexit 指令地址的跳转是通过设置一组特殊寄存器实现的。
</code></pre></div></p>
<p>vdos的局限（syscall）
<div class="highlight"><pre><span></span><code>而&quot;快速系统调用指令&quot;比起中断方式的系统调用方式，还存在一定局限，例如无法在一个系统调用处理过程中再通过&quot;快速系统调用指令&quot;调用别的系统调用。因此，并不一定每个系统调用都需要通过&quot;快速系统调用指令&quot;来实现。比如，对于复杂的系统调用例如 fork，两种系统调用方式的时间差和系统调用本身运行消耗的时间来比，可以忽略不计，此处采取&quot;快速系统调用指令&quot;方式没有什么必要。而真正应该使用&quot;快速系统调用指令&quot;方式的，是那些本身运行时间很短，对时间精确性要求高的系统调用，例如 getuid、gettimeofday 等等。
</code></pre></div></p>
<h3 id="_4"><a class="toclink" href="../../2020/11/09/system-calls-method/#_4">最后总结</a></h3>
<p>int 是最老的方式，目前用amd64的 syscall 方式， 而vdso是基于syscall实现的快速调用。<br />
只有在调用clock_gettime、gettimeofday、getcpu、time这些系统调用时，才会使用vdso，其他系统调用是通过syscall实现的</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2020-11-05 00:00:00+00:00">2020年11月5日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="huawei-unlock-bootloader"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/">huawei unlock bootloader</a></h2>
<p>解锁华为平板M3的BL锁，以及获取root权限</p>
<h2 id="_1"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_1">背景</a></h2>
<p>我有一个华为平板M3，WIFI版, 型号BTV-W09，系统是emui5， 买来没什么用，最大的功能就是看视频。 偶尔发现一个app，LinuxDeploy, 可以在安卓上安装完整的Linux系统，而不是内置的阉割版， 前提是获得root权限。</p>
<h2 id="_2"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_2">步骤</a></h2>
<p>全部步骤分4个： <br />
1. 解BL
2. 刷入recovery 也就是RTWP
3. 将root压缩包复制到平板，在RTWP下安装
4. 安装supersu 的apk
5. 可选刷入xposed框架，并安装xposed manager，步骤参考3,4</p>
<h3 id="_3"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_3">解锁</a></h3>
<p>因为华为官方停止申请解锁BL的服务， 所以需要上淘宝找人帮你搞定。 解锁BL之后， 在关机状态按住电源和音量减，进入fastboot模式时，有红字提示unlocked</p>
<h3 id="rec"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#rec">刷入rec</a></h3>
<p>找到与设备型号对应的rec非常重要，因为型号不对会刷不进去，我尝试了很多个版本，最终在华为论坛找到了。 
有了rec后， 让手机处于fastboot状态， 连接手机到电脑，使用 <code>fastboot flash recovery rec</code> 来刷入 ，提书刷入成功之后，可能自动重启，如果没有重启，长按电源键强制关机。 <br />
关机状态下， 按住电源键和音量+，进入recovery ， 能看到RTWP的界面说明输入成功，如果没有看到RTWP,而是进入华为官方的eRecovery 表示失败，又可能是被华为覆盖了。
一旦能进入RTWP, 那么RTWP会自动安装，以后就不用担心被覆盖的问题。</p>
<h3 id="root"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#root">刷入root工具</a></h3>
<p>将root.zip 拷贝到平板的储存卡目录，进入RTWP，点INSTALL,  然后选择root.zip 就会开始安装了， 安装后再安装supersu 的应用</p>
<p>这样就root成功了， 所以步骤很简单，找到对应机型的rec 很关键。 </p>
<h3 id="xposed"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#xposed">刷入xposed</a></h3>
<p>xposed 很强大，但是xposed只是个框架，需要安装包来实现对app的hack。但是我安装完，没发现什么很强大包，感觉也没什么用。 </p>
<h3 id="_4"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#_4">更新</a></h3>
<p>平板一直都在吃灰，最近发现访问网站都报证书错误，可能是系统旧了(后面发现是电池馈电太久，时间不同步)，所以决定升级系统。这次完整贴出命令，因为发现我之前写的难以参考。在XDA网站发现有新的lineage17适合btv-w09,于是按照帖子里面的方法做：
1. 下载TWRP 3.3.1-1，lineage 17 系统压缩包， boot 镜像，我的是wifi-only版本。
2. 在平板关闭状态下，按住电源+音量减，振动的时候释放电源键，然后就进入fastboot状态，显示<code>phone unlock</code>
3. 刷入twrp <code>fastboot flash recovery twrp-xxx.img</code>
4. 刷入boot <code>fastboot flash boot boot-xxx.img</code>
5. 进入twrp，这里有点迷惑，网上说（包括我之前说的）按住电源+音量加总是无法进入twrp而是进入了华为的eRecovery,使用<code>adb boot-recovery</code>则进入了正常系统。最后发现在开发者模式下开启<code>高级重启</code>功能，重启的时候选择重启到<code>recovery</code>则能正常进入Twrp界面。可能是平板接着USB线。
6. 帖子上说了，升级lineage需要Wipe，彻底初始化但保留系统，执行后连sdcard目录也会格式化，剩几个标准目录。
7. 用adb push 将系统安装压缩包发送到平板的存储空间，<code>adb push Lineage-xxx.zip /sdcard</code>，然后在TWRP中选择 Install，选择这个zip 进行安装。 不过发现这个zip文件校验失败，不管他了。</p>
<p>然后就重启进入新版本的Lineage 17(android 10)，可惜的是没有相机功能。</p>
<h3 id="2025lineageos20"><a class="toclink" href="../../2020/11/05/huawei-unlock-bootloader/#2025lineageos20">2025年重新刷lineageos20</a></h3>
<p>同样问题又出现了</p>
<ol>
<li>进入 fastboot 模式 <code>adb reboot bootloader</code>， 如今没有adb reboot fastboot命令了， fastboot模式和bootloader模式应该是一样的</li>
<li>刷入新的recovery <code>fastboot flash recovery ~/Downloads/recovery.img</code></li>
<li>进入recovery，格式化data分区</li>
<li>在recovery中点击Apply Update， 再点击Apply from ADB， 执行线刷</li>
<li>在电脑输入<code>adb sideload ~/Downloads/lineage-20.0-20250102-RELEASE-btvw09.zip</code></li>
</ol>
<p>但是第5步出现错误
<div class="highlight"><pre><span></span><code>adb sideload ~/Downloads/lineage-20.0-20250102-RELEASE-btvw09.zipmain  
adb: sideload connection failed: insufficient permissions for device: missing udev rules? user is in the plugdev group
See [http://developer.android.com/tools/device.html] for more information
adb: trying pre-KitKat sideload method...
adb: pre-KitKat sideload connection failed: insufficient permissions for device: missing udev rules? user is in the plugdev group
See [http://developer.android.com/tools/device.html] for more information 
</code></pre></div></p>
<p>查看设备情况提示
<div class="highlight"><pre><span></span><code>adb devices
List of devices attached
SLYDU17401001667        no permissions (missing udev rules? user is in the plugdev group); see [http://developer.android.com/tools/device.html]
</code></pre></div></p>
<p>网上查找解决办法，尝试了好几个，最终通过
<div class="highlight"><pre><span></span><code><span class="c1"># 添加udev规则</span>
cat<span class="w"> </span>/etc/udev/rules.d/51-android.rules
<span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;usb&quot;</span>,<span class="w"> </span>ATTR<span class="o">{</span>idVendor<span class="o">}==</span><span class="s2">&quot;id_you_copied&quot;</span>,<span class="w"> </span><span class="nv">MODE</span><span class="o">=</span><span class="s2">&quot;0666&quot;</span>,<span class="w"> </span><span class="nv">GROUP</span><span class="o">=</span><span class="s2">&quot;plugdev&quot;</span>

sudo<span class="w"> </span>chmod<span class="w"> </span>a+r<span class="w"> </span>/etc/udev/rules.d/51-android.rules
sudo<span class="w"> </span>udevadm<span class="w"> </span>control<span class="w"> </span>--reload-rules
sudo<span class="w"> </span>udevadm<span class="w"> </span>trigger
</code></pre></div></p>
<p>上面还是不行，最后拔掉usb线又重新插入就正常了</p>
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <a class="md-pagination__link" href="../..">1</a> <span class="md-pagination__dots">..</span> <a class="md-pagination__link" href="../8/">8</a> <a class="md-pagination__link" href="../9/">9</a> <span class="md-pagination__current">10</span> <a class="md-pagination__link" href="../11/">11</a> <a class="md-pagination__link" href="../12/">12</a> <a class="md-pagination__link" href="../13/">13</a>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
        
          
          <a href="../../tags/" class="md-footer__link md-footer__link--next" aria-label="下一页: Tags">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                Tags
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.tabs.sticky", "navigation.instant", "navigation.instant.progress", "navigation.footer", "toc.follow", "content.code.copy", "content.action.view"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../js/tex-mml-chtml.js"></script>
      
        <script src="../../js/mermaid.min.js"></script>
      
    
  </body>
</html>