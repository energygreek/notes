
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/page/9/">
      
      
      
        <link rel="next" href="../../tags/">
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>Welcome - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#welcome" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Welcome
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Welcome

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../archive/2025/" class="md-tabs__link">
          
  
  
    
  
  归档

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    
      
    
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="../.." class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#urxvt" class="md-nav__link">
    <span class="md-ellipsis">
      urxvt配置
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static-compile-warning-if-namespace-resolving-function-used" class="md-nav__link">
    <span class="md-ellipsis">
      static compile warning if namespace resolving function used
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      智能指针
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avahi" class="md-nav__link">
    <span class="md-ellipsis">
      使用avahi将传统打印机支持无线打印
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模板编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      右值, 临时变量与引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      子串查找算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#systemd" class="md-nav__link">
    <span class="md-ellipsis">
      创建 systemd 服务
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhel" class="md-nav__link">
    <span class="md-ellipsis">
      rhel系列修改密码
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weechat" class="md-nav__link">
    <span class="md-ellipsis">
      weechat 使用方法
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tags
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    归档
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2021/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2020/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2019
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#urxvt" class="md-nav__link">
    <span class="md-ellipsis">
      urxvt配置
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static-compile-warning-if-namespace-resolving-function-used" class="md-nav__link">
    <span class="md-ellipsis">
      static compile warning if namespace resolving function used
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      智能指针
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avahi" class="md-nav__link">
    <span class="md-ellipsis">
      使用avahi将传统打印机支持无线打印
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模板编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      右值, 临时变量与引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      子串查找算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#systemd" class="md-nav__link">
    <span class="md-ellipsis">
      创建 systemd 服务
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhel" class="md-nav__link">
    <span class="md-ellipsis">
      rhel系列修改密码
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weechat" class="md-nav__link">
    <span class="md-ellipsis">
      weechat 使用方法
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="welcome">Welcome<a class="headerlink" href="#welcome" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-25 00:00:00+00:00">2021年3月25日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="urxvt"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/">urxvt配置</a></h2>
<p>自使用arch以来，一直在用urxvt, 它简洁，轻量，但不可否认的有问题，比如中文输入模式长时间时会无法输入中文，配置麻烦, 需要在启动脚本配置.xresource<br />
这里要记一下自己的urxvt的配置以做备份  </p>
<h3 id="urxvt_1"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/#urxvt_1">使用urxvt的主要功能</a></h3>
<p>urxvt 非常简洁的tab功能,支持多路复用以及右键菜单格式化字符串，而且支持假透明，非常轻量。</p>
<p>urxvt不够现代化，不是开箱即用的，需要如下修改： 
* tab功能需要修改perl的包，因为默认情况下不支持切换tab
* 不支持icon, 需要在配置文件手动指定icon的位置
* tab功能需要额外启动参数，所以顺便编一个desktop启动文件</p>
<h3 id="perl"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/#perl">perl修改</a></h3>
<p>复制/usr/lib/perl/ext/tabbed到用户目录~/.urxvt/ext/, 修改<code>tab_key_press</code>函数如下</p>
<div class="highlight"><pre><span></span><code><span class="c1"># if ($keysym == 0xff51 || $keysym == 0xff53)  表示使用ctrl+shift 和方向键来移动tab</span>
<span class="k">sub</span><span class="w"> </span><span class="nf">tab_key_press</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="p">,</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="nv">$event</span><span class="p">,</span><span class="w"> </span><span class="nv">$keysym</span><span class="p">,</span><span class="w"> </span><span class="nv">$str</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">@_</span><span class="p">;</span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ShiftMask</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ControlMask</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">grep</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$_</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="nv">$#</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="w">         </span><span class="o">--</span><span class="nv">$idx</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="p">;</span>
<span class="w">         </span><span class="o">++</span><span class="nv">$idx</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">;</span>

<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">make_current</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx</span><span class="w"> </span><span class="nv">%</span><span class="w"> </span><span class="err">@</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}}]);</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">elsif</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff54</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">new_tab</span><span class="p">;</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span><span class="k">elsif</span><span class="w"> </span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ControlMask</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ShiftMask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">grep</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$_</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="nv">$#</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<span class="w">         </span><span class="k">my</span><span class="w">  </span><span class="nv">$idx2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="p">?</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="nv">%</span><span class="w"> </span><span class="err">@</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="w">         </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx1</span><span class="p">],</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">])</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">],</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx1</span><span class="p">]);</span>

<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">make_current</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">]);</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="urxvt_2"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/#urxvt_2">urxvt 启动文件</a></h3>
<p>创建启动文件，使其默认为tab模式 '.local/share/applications/urxvtq.desktop'
<div class="highlight"><pre><span></span><code>[Desktop Entry]
Version=1.0
Name=urxvtq
Comment=An unicode capable rxvt clone
Exec=urxvt -pe tabbed
Icon=utilities-terminal
Terminal=false
Type=Application
Categories=System;TerminalEmulator;
</code></pre></div></p>
<h3 id="urxvt_3"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/#urxvt_3">urxvt 配置</a></h3>
<p>创建如下的文件，并要在合适的启动脚本里添加一行<code>[ -f "$HOME/.Xresources" ] &amp;&amp;  xrdb -merge "$HOME/.Xresources"</code>
<div class="highlight"><pre><span></span><code>!!$HOME/.Xresources

!! dbi
Xft.dpi:98

/* Couleurs Tango */

!! 下划线色
URxvt.colorUL:  #87afd7
URxvt.colorBD:  white
URxvt.colorIT:  green

!! tab 配色
URxvt.tabbed.tabbar-fg: 2
URxvt.tabbed.tabbar-bg: 0
URxvt.tabbed.tab-fg:    3
URxvt.tabbed.tab-bg:    2
URxvt.tabbed.tabren-bg: 3
URxvt.tabbed.tabdiv-fg: 8
URxvt.tabbed.tabsel-fg: 1
URxvt.tabbed.tabsel-bg: 8

!! fake transparent
URxvt.transparent: true
URxvt.shading:     10
URxvt.fading:      40
!! font
URxvt.font:        xft:Monospace,xft:Awesome:pixelsize=14
URxvt.boldfont:    xft:Monospace,xft:Awesome:style=Bold:pixelsize=16

!! scroll behavior
URxvt.scrollBar:         false
URxvt.scrollTtyOutput:   false
URxvt.scrollWithBuffer:  true
URxvt.scrollTtyKeypress: true

!! addtional
URxvt.internalBorder:     0
URxvt.cursorBlink: true
URxvt.saveLines:          2000
URxvt.mouseWheelScrollPage:             false

! Restore Ctrl+Shift+(c|v)
URxvt.keysym.Shift-Control-V: eval:paste_clipboard
URxvt.keysym.Shift-Control-C: eval:selection_to_clipboard
URxvt.iso14755: false
URxvt.iso14755_52: false

! alt+s 搜索
URxvt.perl-ext:   default,matcher,searchable-scrollback
URxvt.keysym.M-s: searchable-scrollback:start

! url match 问题是tab模式下不支持跳转浏览器
URxvt.url-launcher:       /usr/bin/firefox
URxvt.matcher.button:     1


URxvt.termName:         xterm-256color
URxvt.iconFile:     /usr/share/icons/gnome/32x32/apps/gnome-terminal-icon.png
! fast key
URxvt.keysym.Control-Up:     \033[1;5A
URxvt.keysym.Control-Down:   \033[1;5B
URxvt.keysym.Control-Left:   \033[1;5D
URxvt.keysym.Control-Right:  \033[1;5C
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../2021/03/25/urxvt%E9%85%8D%E7%BD%AE/#_1">最后</a></h3>
<p>用了kitty就不会有输入法的问题，字体也很丰富, 推荐现代化模拟终端kitty</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-17 00:00:00+00:00">2021年3月17日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="static-compile-warning-if-namespace-resolving-function-used"><a class="toclink" href="../../2021/03/17/static-compile-warning-if-namespace-resolving-function-used/">static compile warning if namespace resolving function used</a></h2>
<p>当程序里面有使用到解析函数的时候， 静态编译程序会报warning</p>
<h3 id="_1"><a class="toclink" href="../../2021/03/17/static-compile-warning-if-namespace-resolving-function-used/#_1">现象</a></h3>
<div class="highlight"><pre><span></span><code>../../lib/libhacore.a(File.cpp.o): In function `_ZN2ha4core9gid2groupB5cxx11Ej&#39;:
/tmp/src/ha/core/File.cpp:213: warning: Using &#39;getgrgid_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `ha::core::group2gid(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned int&amp;)&#39;:
/tmp/src/ha/core/File.cpp:291: warning: Using &#39;getgrnam_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `ha::core::username2uid(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned int&amp;)&#39;:
/tmp/src/ha/core/File.cpp:271: warning: Using &#39;getpwnam_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `_ZN2ha4core12uid2usernameB5cxx11Ej&#39;:
/tmp/src/ha/core/File.cpp:194: warning: Using &#39;getpwuid_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
CMakeFiles/hasync-exec.dir/main.cpp.o: In function `boost::asio::detail::socket_ops::getaddrinfo(char const*, char const*, addrinfo const&amp;, addrinfo**, boost::system::error_code&amp;)&#39;:
/usr/local/include/boost/asio/detail/impl/socket_ops.ipp:3348: warning: Using &#39;getaddrinfo&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcrypto.a(b_sock.o): In function `BIO_gethostbyname&#39;:
b_sock.c:(.text+0x51): warning: Using &#39;gethostbyname&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcares.a(libcares_la-ares_getaddrinfo.o): In function `ares_getaddrinfo&#39;:
ares_getaddrinfo.c:(.text+0x73f): warning: Using &#39;getservbyname&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcares.a(libcares_la-ares_getnameinfo.o): In function `lookup_service.part.0.constprop.2&#39;:
ares_getnameinfo.c:(.text+0x32d): warning: Using &#39;getservbyport_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2021/03/17/static-compile-warning-if-namespace-resolving-function-used/#_2">结论</a></h3>
<p>即使静态链接glibc, glibc内部在运行时依旧要调用<code>动态库</code>，这些库函数多与域名解析有关, 所以要求运行时的库版本要与编译时相同， 当然基于容器化部署就不用担心了  </p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-15 00:00:00+00:00">2021年3月15日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></h2>
<p>智能指针是c++11加入的特性，包括shared_ptr和unique_ptr，weak_ptr，以及make_shared函数，但make_unique是c++14才出来<br />
不过c++11可以通过模版来实现make_unique</p>
<h3 id="_2"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_2">普通指针和智能指针的区别</a></h3>
<p>shared_ptr和unique_ptr都是异常安全的(exception-safe)，而普通指针不是，举例如下
<div class="highlight"><pre><span></span><code>void nonsafe_call(T1* t1, T2* t2);
void safe_call(unique_ptr&lt;T1&gt; t1, unique_ptr&lt;T2&gt; t2);

nonsafe_call(new T1, new T2);
safe_call(make_unique&lt;T1&gt;, make_unique&lt;T2&gt;);
</code></pre></div></p>
<h4 id="_3"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_3">引用计数</a></h4>
<p><img alt="shared_ptr.png" src="../../img/shared_ptr.png" /></p>
<h4 id="_4"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_4">当形参为普通指针时</a></h4>
<p>虽然new是安全的，会先申请内存再构造对象t1。 如果t1的构造函数抛异常，申请的内存会自动释放，不会内存泄漏<br />
但当两个new作为函数参数时，情况不同。 因为参数必须在调用函数前决断，所以步骤如下
<div class="highlight"><pre><span></span><code>1. 为t1申请内存
2. 构造t1
3. 为t2申请内存
4. 构造t2
5. 调用函数
</code></pre></div></p>
<ul>
<li>当执行到2失败时，不会泄漏，new会释放t1的内存</li>
<li>当执行到4失败是，会泄漏t1，因为t1已经构造完成，不会释放内存</li>
</ul>
<h4 id="_5"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_5">当形参为智能指针时</a></h4>
<p>步骤为
<div class="highlight"><pre><span></span><code>1. t1 = make_unique&lt;T1&gt;()
2. t2 = make_unique&lt;T2&gt;()
3. 调用函数
</code></pre></div>
如果2失败，t1的对象由unique_ptr管理，当t1释放时，会释放内存，所以无论t1构造失败还是t2构造失败，都能正确释放内存，不会导致泄漏<br />
就因为unique_ptr和shared_ptr是内存安全的</p>
<h4 id="_6"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_6">但以普通指针构造智能指针的方式不是异常安全的</a></h4>
<p>即<code>foo(std::unique_ptr&lt;T1&gt;(new T1()), std::unique_ptr&lt;T2&gt;(new T2()));</code> 不是异常安全的</p>
<p>此时步骤可能如下
<div class="highlight"><pre><span></span><code>1. 为t1申请内存
2. 构造t1
3. 为t2申请内存
4. 构造t2
5. 构造unique_ptr&lt;T1&gt;
6. 构造unique_ptr&lt;T2&gt;
7. 调用函数
</code></pre></div>
当步骤4发生异常时，t1并未被unique_ptr管理，所以不会去释放t1的内存，故发生内存泄漏</p>
<h3 id="_7"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_7">智能指针的构造</a></h3>
<p>shared_ptr对应的函数是make_shared<T><br />
但c++11中没有make_unique, 可以使用模版实现如下</p>
<p><div class="highlight"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span><span class="w"> </span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
那为什么这样就能异常安全呢？因为调用make_uniqe时，可以确保t1的内存被unique_ptr管理了 </p>
<h3 id="make_sharednew"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#make_sharednew">make_shared创建智能指针和用new创建智能指针的区别</a></h3>
<p>除了上面说所的make_shared/make_unique是异常安全，而unique_ptr<T>(new T()) 不是异常安全外，其构造的智能指针也不同  </p>
<p>智能指针之所以会释放内存，是因为智能指针本身也是一个对象，在其生命周期结束后会调用dtor, 并在那里释放内存<br />
所以智能指针的对象内存即包含了T，也包含了智能指针本身，而make_shared<T>() 和 shared_ptr<T>(new T)的区别在于<code>前者是两个部分的地址连续，而后者并不一定连续</code></p>
<h3 id="unique_ptr"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#unique_ptr">unique_ptr的区别</a></h3>
<p>unique_ptr和shared_ptr不同，后者为了多变量同时拥有资源的访问，而unique_ptr表示任何时刻，只有一个变量能访问资源和释放资源，比如打开的文件设备, 
而且通常为管理的资源设置析构函数，比如指定析构时关闭文件和设备</p>
<p>如下代码，当fp析构时，自动关闭文件
<div class="highlight"><pre><span></span><code>// helper function for the custom deleter demo below
void close_file(std::FILE* fp)
{
    std::fclose(fp);
}
using unique_file_t = std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt;;
unique_file_t fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file);
</code></pre></div></p>
<p>unique_ptr要配合move使用，当move之后，原对象不拥有指针资源</p>
<h3 id="_8"><a class="toclink" href="../../2021/03/15/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_8">总结</a></h3>
<p>为了避免多参数决断时，导致已经决断的参数内存泄漏，应尽可能使用智能指针来管理内存</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-10 00:00:00+00:00">2021年3月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="avahi"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/">使用avahi将传统打印机支持无线打印</a></h2>
<p>自从知道mdns之后，发现它非常方便，例如可以找到lan下有哪些ftp服务，ssh服务等。甚至我配置好的打印机服务。</p>
<h3 id="mdns"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#mdns">mdns介绍</a></h3>
<p>有别于dns, mdns专门用来解析链路域名（TLD为*.local）， 且不需要域名服务器（nameserver）。 <br />
原理是同一个lan里的主机通过avahi或zeroconfig类似的工具，向lan广播自己的ip信息和服务</p>
<h3 id="avahi_1"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#avahi_1">avahi 介绍</a></h3>
<p>avahi是zeroconfig的开源实现，在linux下还有systemd-resolve 同样可以实现mdns解析，但是avahi依旧是linux预装的软件。</p>
<h4 id="avahi_2"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#avahi_2">avahi 配置</a></h4>
<p>主要修改<code>/etc/avahi/avahi-daemon.conf</code>, 这里使用了br0和wlan0两个网卡，avahi就可以访问两个网络
<div class="highlight"><pre><span></span><code>use-ipv4=yes
allow-interfaces=br0,wlan0
</code></pre></div>
再设置自启动</p>
<h4 id="nss"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#nss">nss 配置</a></h4>
<p>要让主机能解析到*.local 域名，需要修改配置文件<code>/etc/nsswitch.conf</code> 
<div class="highlight"><pre><span></span><code><span class="gd">- hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns</span>
<span class="gi">+ hosts: files mymachines myhostname mdns_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] dns</span>
</code></pre></div>
这样，在主机请求解析域名的时候， 会先去请求avahi解析，如果avahi解析失败（说明不是一个local域名）才会去查找域名解析（dns）</p>
<h3 id="systemd-resolved"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#systemd-resolved">使用systemd-resolved</a></h3>
<p>对于使用systemd-resoved来管理dns解析时，可以直接用<code>sudo systemd-resolve --set-mdns=yes --interface=eth0</code>启动eth0端口的mdns广播。</p>
<p>顺便提一下，用systemd-networkd配置dns服务器和用systemd-resolved配置dns的区别，前者为每个以太网口单独配置，而systemd-resoved会读取每个以太网口配置，另外还有一个全局的dns配置。</p>
<h4 id="_1"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_1">测试</a></h4>
<p>首先可以ping 本地local域名
<div class="highlight"><pre><span></span><code>~<span class="w"> </span>&gt;<span class="w"> </span>ping<span class="w"> </span>hst.local<span class="w">                                                                                                                                                                                      </span>
PING<span class="w"> </span>hst.local<span class="o">(</span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">))</span><span class="w"> </span><span class="m">56</span><span class="w"> </span>data<span class="w"> </span>bytes
<span class="m">64</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">)</span>:<span class="w"> </span><span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">ttl</span><span class="o">=</span><span class="m">64</span><span class="w"> </span><span class="nv">time</span><span class="o">=</span><span class="m">0</span>.113<span class="w"> </span>ms
<span class="m">64</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">)</span>:<span class="w"> </span><span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="nv">ttl</span><span class="o">=</span><span class="m">64</span><span class="w"> </span><span class="nv">time</span><span class="o">=</span><span class="m">0</span>.144<span class="w"> </span>ms
</code></pre></div></p>
<p>然后执行<code>avahi-discover-standalone</code> 可以查找到很多*.local的地址，特别是在公司网络里</p>
<h3 id="_2"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_2">广告自己的服务</a></h3>
<p>配置好了avahi, 就可以向外界发布自己的服务，让其他人知道，也可以选择不发布<br />
例如要广告我的ssh服务, 只需要将预设的配置文件拷贝到avahi的配置目录下
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>cp<span class="w"> </span>/usr/share/doc/avahi/ssh.service<span class="w"> </span>/etc/avahi/services
</code></pre></div>
这样，别人就能发现我的ssh服务了</p>
<h3 id="_3"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_3">配置打印机</a></h3>
<p>linux的打印功能依赖CUPS这个软件，先安装CUPS，设置自启动，然后就可以访问CUPS的网页版管理界面<code>http://localhost:631</code><br />
在这个网页中添加网络打印机或者本地打印机，然后测试打印是否正常</p>
<h3 id="_4"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_4">最后，配置无线功能</a></h3>
<p>上一部添加的打印机可能是有线网络打印机，也可能是串口打印机，都不能让我们的手机直接使用。  </p>
<p>但是通过cups + avahi 就可以将你的有线打印机变成无线打印机了<br />
首先在cups里配置，勾选<code>Share This Printer</code>， 
<img alt="cups shares printer" src="../../img/cups_share.png" /></p>
<p>然后像刚才添加ssh服务一样， 添加打印服务<br />
在<code>/etc/avahi/services/</code> 创建一个service后缀的文件<code>airprint.service</code></p>
<p><div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; standalone=&#39;no&#39;?&gt;</span><span class="cm">&lt;!--*-nxml-*--&gt;</span>
<span class="cp">&lt;!DOCTYPE service-group SYSTEM &quot;avahi-service.dtd&quot;&gt;</span>
<span class="nt">&lt;service-group&gt;</span>
<span class="w">  </span><span class="nt">&lt;name&gt;</span>Printer<span class="nt">&lt;/name&gt;</span>
<span class="w">  </span><span class="nt">&lt;service&gt;</span>
<span class="w">    </span><span class="nt">&lt;type&gt;</span>_ipp._tcp<span class="nt">&lt;/type&gt;</span>
<span class="w">    </span><span class="nt">&lt;subtype&gt;</span>_universal._sub._ipp._tcp<span class="nt">&lt;/subtype&gt;</span>
<span class="w">    </span><span class="nt">&lt;port&gt;</span>631<span class="nt">&lt;/port&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>txtver=1<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>qtotal=1<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>rp=printers/Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>ty=Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>adminurl=http://yourip:631/printers/Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>note=Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>priority=0<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>product=(GPL<span class="w"> </span>Ghostscript)<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>printer-state=3<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>printer-type=0x801046<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Transparent=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Binary=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Fax=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Color=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Duplex=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Staple=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Copies=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Collate=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Punch=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Bind=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Sort=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Scan=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>pdl=application/octet-stream,application/pdf,application/postscript,image/jpeg,image/png,image/urf<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>URF=W8,SRGB24,CP1,RS600<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">  </span><span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/service-group&gt;</span>
</code></pre></div>
根据情况修改一下内容，就完成了, 亲测iphone可以使用这个服务打印</p>
<h3 id="_5"><a class="toclink" href="../../2021/03/10/%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_5">注意</a></h3>
<p>上面的情况假设防火墙处于关闭状态，如果启用防火墙的情况下，需要开放avahi、ssh以及ipp服务</p>
<div class="highlight"><pre><span></span><code>sudo firewall-cmd --add-service ssh ipp --permanent
sudo firewall-cmd --add-port=5353/tcp --permanent
sudo firewall-cmd --reload
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-04 00:00:00+00:00">2021年3月4日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 5 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/">模板编程</a></h2>
<p>模板编程是其它高级语言没有的技术, 也称为范型编程，元编程(meta programing), stl的基石。这种对类型的泛化相当于在编程之上编程</p>
<h3 id="_2"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_2">概述</a></h3>
<p>模板可以作用于函数和类，即能泛化<code>类型</code>，也可以泛化<code>大小</code>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="p">};</span>

<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// array of two int</span>
<span class="w">    </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// class has a array of two int </span>
<span class="w">    </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">F</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
</code></pre></div></p>
<h3 id="_3"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_3">模板的特化</a></h3>
<p>跟泛化相反的方向，叫特化，编译器会优先使用特化的版本, 而特化有2个方向，<code>类型特化</code>和<code>范围特化</code>  </p>
<h4 id="_4"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_4">类型特化</a></h4>
<p>对于特化类型个数的不同，分为偏特化和全特化，全特化即为所有类型都指定，特化类型越多匹配优先级越高 
注意：模板函数不能偏特化</p>
<div class="highlight"><pre><span></span><code>template&lt;typename T1, typename T2&gt; struct Foo{};
template&lt;typename T2&gt; struct Foo&lt;int, T2&gt; {};
// 全特化
template&lt;&gt; struct Foo&lt;int,int&gt;{};
</code></pre></div>
<p>例如`Foo<int, int> foo'，编译器会使用第三个版本</p>
<h4 id="_5"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_5">范围特化</a></h4>
<p>比如常见的指针和引用，这和int, float, class 都是无关的，属于另个维度，也可以说是范围, 在stl为兼容指针做大量的工作  </p>
<p><div class="highlight"><pre><span></span><code>template &lt;typename T, typename N&gt; struct Foo&lt;T *, N&gt; {};
</code></pre></div>
这样'Foo<int *, int> foo'会使用这个版本</p>
<p>还例如指定对大小的特例化
<div class="highlight"><pre><span></span><code>//模板
template&lt;int n&gt; foo(){}

//值特例化
template&lt;&gt; foo&lt;10&gt; foo(){}
</code></pre></div>
那么如果调用<code>foo&lt;10&gt;();</code>时，优先匹配特例化版本</p>
<h4 id="_6"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_6">函数匹配优先级</a></h4>
<p>在函数调用时，普通函数的匹配优先级高于模板函数
<div class="highlight"><pre><span></span><code>template &lt;typename T&gt; void f(T) { std::cout &lt;&lt; &quot;temp\n&quot;; }
void f(int d) { std::cout &lt;&lt; &quot;temp1\n&quot;; }
template &lt;&gt; void f(int d) { std::cout &lt;&lt; &quot;temp2\n&quot;; }

f(1); // temp1
</code></pre></div></p>
<h4 id="_7"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_7">自定义类型的范围特化</a></h4>
<p>上面讲的是指针类型和引用类型两种，但如果是自定义类型，那就无穷无尽了，所以模板编程也是'图灵完备'的</p>
<p>例如以下，创建了一个自定义的类型来包装基本类型(int,float)，这样可以有自定义类型的特化版本
<div class="highlight"><pre><span></span><code>  template &lt;typename T&gt; struct Decor { using type = T; };
  template &lt;typename T&gt; struct Strip { using type = T; };
  template &lt;typename T&gt; struct Strip&lt;Decor&lt;T&gt;&gt; { using type = T; };
  template &lt;typename T&gt; using StripDecor = typename Strip&lt;T&gt;::type;

  template &lt;typename T&gt; class Row {};

  int main() {
    using nodecor = Row&lt;int&gt;;
    using decor = Decor&lt;Row&lt;int&gt;&gt;;
    // 虽底层同为int, 但nodecor 类型不同于decor类型
    static_assert(std::is_same&lt;col&gt;, nocol&gt;::value);
    // 通过Strip取出其底层类型
    static_assert(std::is_same&lt;StripDecor&lt;col&gt;, nocol&gt;::value);
    return 0;
  }
</code></pre></div></p>
<h4 id="_8"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_8">模板的声明定义分离</a></h4>
<ol>
<li>由于template用来生成函数和类，所以编译器需要同时知道template的类型和其细节，所以模板函数不支持将定义放到源文件中</li>
<li>而且编译器通常是以cpp为编译单元，当编译模板cpp时不知道调用cpp, 编译调用cpp时，不知道模板cpp。所以模板函数不支持将定义放到源文件中</li>
<li>对于模板类可以将成员函数的定义放到源文件，但要为每个成员函数都添加'template'限定, <strong><em>而且要为实例添加特例化</em></strong>。</li>
<li>显式特例化支持只声明不定义，而在源文件中为每种所需的类型都特例化，即与3相同。其实显示特例化是不需要特例化而强制特例化。 </li>
</ol>
<p>如下，模板类的定义放到cpp中，这样会报错，因为在编译call_foo.cpp时不知到模板定义, 因为没有生成过int版本的Foo。<br />
为此，必须在foo.cpp里添加<code>template class Foo&lt;int&gt;</code>, 如同4，实在吃力不讨好。
<div class="highlight"><pre><span></span><code><span class="c1">// foo.h</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">class</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span>
<span class="w">      </span><span class="n">Foo</span><span class="p">();</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="nf">someMethod</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">private</span><span class="o">:</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="c1">// foo.cpp</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">someMethod</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="c1">// call_foo.cpp</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">blah_blah_blah</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">      </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">      </span><span class="n">f</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div></p>
<p>当然把模板的定义放到头文件中会增加可执行文件的体积。</p>
<h5 id="_9"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_9">实际运用</a></h5>
<p>grpc 能以流和非流方式传输，而grpc参数protobuf消息类型是另一个范围。那么要封装grpc方法, 需要封装流+类型</p>
<p>举例protobuf的消息类型有string, fixed32
- string
- fixed32
- Stream<fixed32>
- Stream<string></p>
<p>通过上面的偏特化可以即能区分流和非流又能区分类型</p>
<h4 id="_10"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_10">赘述一下模板的类型</a></h4>
<p>上面的模板类型T都是实际编程时定义的类型，但作为图灵完备的模板编程，未决的template类型也可以作为template类型</p>
<p>如下是一个模板用另一个模板来特例化
<div class="highlight"><pre><span></span><code>template &lt;typename T&gt; struct Upper {};
template &lt;template &lt;typename&gt; class T&gt; struct Lower {};

template&lt;typename T&gt;
Lower&lt;Upper&lt;T&gt;&gt; l;
</code></pre></div></p>
<h3 id="variadic-templates"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#variadic-templates">可变模版variadic templates</a></h3>
<p>c中有可变参数<code>...</code>和gcc内置<code>__VA_ARGS__</code>宏定义, 实现不同个数的变量打印。这是由编译期实现的，会将format的格式符替换成参数
<div class="highlight"><pre><span></span><code>int printf ( const char * format, ... );
</code></pre></div></p>
<p>c++有模版，而且在c++11之后引入了动态参数模版，即模版函数或类可以使用动态参数</p>
<h4 id="1"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#1">实际运用1</a></h4>
<p>在实际项目中手动跑单元测试用例的时候，不希望再去看日志文件，而是想日志直接输出到终端, 有以下办法</p>
<h5 id="c11"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c11">c++11及以上标准</a></h5>
<p>可以使用动态参数模版替换原本的日志打印函数
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Rest</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">rest</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 这时日志就直接输出到终端了, 这里使用了fmt库</span>
<span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;aasdas{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bbbb&quot;</span><span class="p">);</span>
</code></pre></div></p>
<p>也可简单写成
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">...)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>如果不使用fmt格式化，还可以用
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>
<span class="c1">// 定义一个空函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">log_debug</span><span class="p">(){}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Rest</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">First</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Arg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">arg</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="n">log_debug</span><span class="p">(</span><span class="n">arg</span><span class="p">...);</span>
<span class="p">}</span>
</code></pre></div>
需要解释一下，函数<code>log_debug()</code>必须要先声明，因为模版实例化的的最终要调用这个无参的函数<br />
模拟一下堆栈, 因为参数在每次递归时减少一个，所以最终是0个参数
<div class="highlight"><pre><span></span><code>log_debug(1, 0.2, &quot;aaa&quot;);
log_debug(0.2, &quot;aaa&quot;);
log_debug(&quot;aaa&quot;);
log_debug();
</code></pre></div></p>
<h5 id="c11_1"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c11_1">c++11以前的标准</a></h5>
<p>可以使用宏定义来替换了, 然后需要重载<code>,</code>方法
<div class="highlight"><pre><span></span><code><span class="cp">#define log_debug(...) std::cout , __VA_ARGS__ , std::endl</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">,(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//overloaded version to handle all those special std::endl and others...</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">,(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h5 id="c"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c">直接用c的方式</a></h5>
<p>因为printf是支持varidic的
<div class="highlight"><pre><span></span><code><span class="cp">#undef log_debug</span>

<span class="cp">#define log_debug(...) printf(__VA_ARGS__), printf(&quot;\n&quot;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;example&quot;</span><span class="p">,</span><span class="s">&quot;output&quot;</span><span class="p">,</span><span class="s">&quot;filler&quot;</span><span class="p">,</span><span class="s">&quot;text&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h5 id="c17-fold-expression"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#c17-fold-expression">c++17 引入了<code>fold expression</code></a></h5>
<p>可以改写为
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">log_debug</span><span class="p">(</span><span class="n">Args</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>动态参数模版除了以上的用法，还有更多用处, 例如<code>std::tupe</code>的实现</p>
<h4 id="2"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#2">实际运用2</a></h4>
<h5 id="_11"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_11">使用模板生成并发代码</a></h5>
<p>以下代码实现复制二维数组，
<div class="highlight"><pre><span></span><code>for( size_t ch=0 ; ch&lt;channelNum ; ++ch ) {
    for( size_t i=0; i&lt;length ; ++i ) {
        out[ch][i]=in[ch][i];
    }
}
</code></pre></div></p>
<p>但以下理论更快，没有两层for，前提是知道channel大小
<div class="highlight"><pre><span></span><code>for(size_t i=0;i&lt;length;++i) {
    out[0][i]=in[0][i];
    out[1][i]=in[1][i];
    out[2][i]=in[2][i];
    out[3][i]=in[3][i];
}
</code></pre></div></p>
<p>但如果用模板，就不需要知道channel大小，自动生成上面的代码</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Copy</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Copy</span><span class="o">&lt;</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">go</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">out</span><span class="p">[</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Copy</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">channelNum</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">parall_copy</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Copy</span><span class="o">&lt;</span><span class="n">channelNum</span><span class="o">&gt;::</span><span class="n">go</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>需要提醒的，如同打印日志的，0的特例化不能省，否则编译出错</p>
<h4 id="3"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#3">实际运用3 工厂模式</a></h4>
<p>在使用spdlog时发现有使用到template未决名, 用来实现两个维度的工厂模式。</p>
<p>第一层提供两种sink的工厂，而其factory是未决名，所以要加上<code>Factory::template</code>消歧义，不然<code>&lt;</code>会当成小于号  </p>
<div class="highlight"><pre><span></span><code><span class="c1">//</span>
<span class="c1">// factory functions</span>
<span class="c1">//</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_factory</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basic_logger_mt</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">filename_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Factory</span><span class="o">::</span><span class="n">template</span><span class="w"> </span><span class="n">create</span><span class="o">&lt;</span><span class="n">sinks</span><span class="o">::</span><span class="n">basic_file_sink_mt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">truncate</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_factory</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basic_logger_st</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">filename_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Factory</span><span class="o">::</span><span class="n">template</span><span class="w"> </span><span class="n">create</span><span class="o">&lt;</span><span class="n">sinks</span><span class="o">::</span><span class="n">basic_file_sink_st</span><span class="o">&gt;</span><span class="p">(</span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">truncate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>此时factory可以是<code>synchronous_factory</code>, 也可以是异步版本，但这需要用户自己实现。
<div class="highlight"><pre><span></span><code><span class="c1">// Default logger factory-  creates synchronous loggers</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">synchronous_factory</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Sink</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="p">...</span><span class="w"> </span><span class="n">SinkArgs</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">spdlog</span><span class="o">::</span><span class="n">logger</span><span class="o">&gt;</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">logger_name</span><span class="p">,</span><span class="w"> </span><span class="n">SinkArgs</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">sink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">SinkArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">new_logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">logger</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">logger_name</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">));</span>
<span class="w">        </span><span class="n">details</span><span class="o">::</span><span class="n">registry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">initialize_logger</span><span class="p">(</span><span class="n">new_logger</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">new_logger</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">using</span><span class="w"> </span><span class="n">default_factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">synchronous_factory</span><span class="p">;</span>
</code></pre></div></p>
<p>简化为下面的demo，固然可以直接使用call_dd的方式，但维度只有一个。而call_dd2则有2个维度了<br />
但必须使用<code>T::template</code>消歧义, 因为此时的foo未决名, 不知道是那个类里面的foo。
<div class="highlight"><pre><span></span><code>  struct AA {
    template &lt;typename cc&gt; static void foo() { std::cout &lt;&lt; &quot;dd::foo\n&quot;; };
  };

  struct BB {
    template &lt;typename cc&gt; static void foo() { std::cout &lt;&lt; &quot;dd::foo\n&quot;; };
  };

  template &lt;typename T&gt; void call_dd() { AA::foo&lt;T&gt;(); }
  template &lt;typename T, typename K&gt; void call_dd2() { T::template foo&lt;K&gt;(); }

  int main() {
    call_dd&lt;void&gt;();
    call_dd2&lt;AA&gt;();
    call_dd2&lt;AA, int&gt;();
    call_dd2&lt;BB, long&gt;();
  }
</code></pre></div></p>
<h3 id="_12"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_12">模版与宏定义、虚函数的区别</a></h3>
<ol>
<li>宏定义在预处理期执行，模板在编译期执行，而虚函数也称动态绑定在运行时执行</li>
<li>宏和模板都将运行时的工作提前了，用编译时间换取运行效率</li>
<li>宏定义没有类型检查，这点模板比较好</li>
<li>模板虽然会延长编译时间，但当编译期实例化类型后，查找模板函数和查找普通函数的速度几乎相同</li>
</ol>
<h3 id="dependent-name"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#dependent-name">待决名dependent name</a></h3>
<ol>
<li>待决名的意思是在定义的地方，类型还不能决断，需要延后到实例化确定时。而非待决名指类型在定义的地方已经确定。  </li>
<li>延后将导致此时无法在定义点进行错误检查，以及消除<code>typename</code>和<code>template</code>歧义，这导致需要在调用点加上template</li>
</ol>
<p>待决名如:
<div class="highlight"><pre><span></span><code>template&lt;typename T&gt;
struct X : B&lt;T&gt; // &quot;B&lt;T&gt;&quot; 取决于 T
{
    typename T::A* pa; // &quot;T::A&quot; 取决于 T
                       // （此 &quot;typename&quot; 的使用的目的见下文）
    void f(B&lt;T&gt;* pb)
    {
        static int i = B&lt;T&gt;::i; // &quot;B&lt;T&gt;::i&quot; 取决于 T
        pb-&gt;j++; // &quot;pb-&gt;j&quot; 取决于 T
    }
};
</code></pre></div></p>
<p>让人吃惊的例子, 这就是非待决名的情况下，立即绑定
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;g(double)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;g&quot; 是非待决名，现在绑定</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;g(int)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 调用 g(int)</span>

<span class="w">    </span><span class="n">S</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// 调用 g(double)</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="typename"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#typename">typename消歧义</a></h4>
<p>在模板（包括别名模版）的声明或定义中，不是当前实例化的成员且取决于某个模板形参的名字不会被认为是类型，<br />
除非使用关键词 typename 或它已经被设立为类型名（例如用 typedef 声明或通过用作基类名）。 </p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// std::vector&lt;T&gt;::const_iterator 是待决名，</span>
<span class="w">    </span><span class="n">typename</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 下列内容因为没有 &#39;typename&#39; 而会被解析成</span>
<span class="w">    </span><span class="c1">// 类型待决的成员变量 &#39;const_iterator&#39; 和某变量 &#39;p&#39; 的乘法。</span>
<span class="w">    </span><span class="c1">// 因为在此处有一个可见的全局 &#39;p&#39;，所以此模板定义能编译。</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">iter_t</span><span class="p">;</span>
<span class="w">    </span><span class="n">iter_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// iter_t 是待决名，但已知它是类型名</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value_t</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前实例化的成员</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value_t</span><span class="w"> </span><span class="n">n</span><span class="p">{};</span><span class="w"> </span><span class="c1">// S&lt;T&gt; 待决，但不需要 &#39;typename&#39;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模板实例化失败：类型 std::vector&lt;int&gt; 中没有</span>
<span class="w">            </span><span class="c1">// 名字是 &#39;const_iterator&#39; 的成员变量</span>
<span class="w">    </span><span class="n">S</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">().</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="template"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#template">template消歧义</a></h4>
<p>与此相似，模板定义中不是当前实例化的成员的待决名同样不被认为是模板名，除非使用消歧义关键词 template，或它已被设立为模板名： </p>
<p><div class="highlight"><pre><span></span><code>template&lt;typename T&gt;
struct S
{
    template&lt;typename U&gt; void foo() {}
};

template&lt;typename T&gt;
void bar()
{
    S&lt;T&gt; s;
    s.foo&lt;T&gt;();          // 错误：&lt; 被解析为小于运算符
    s.template foo&lt;T&gt;(); // OK
}
</code></pre></div>
template 消歧义可以使用
<div class="highlight"><pre><span></span><code>T::template
s.template
this-&gt;template
</code></pre></div></p>
<h3 id="stdforward"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#stdforward">std::forward 转发在模版的使用</a></h3>
<p>为什么完美转发的对象必须是右值引用？</p>
<h4 id="_13"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_13">说明一下右值引用</a></h4>
<div class="highlight"><pre><span></span><code> 引用类型   可以引用的值类型    使用场景
非常量左值   常量左值    非常量右值   常量右值
非常量左值引用     Y   N   N   N   无
常量左值引用  Y   Y   Y   Y   常用于类中构建拷贝构造函数
非常量右值引用     N   N   Y   N   移动语义、完美转发
常量右值引用  N   N   Y   Y   无实际用途
</code></pre></div>
<h3 id="_14"><a class="toclink" href="../../2021/03/04/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/#_14">参考</a></h3>
<p>https://en.cppreference.com/w/cpp/language/parameter_pack
https://en.cppreference.com/w/cpp/language/fold
https://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-02 00:00:00+00:00">2021年3月2日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/">右值, 临时变量与引用</a></h2>
<p>我们说的临时变量通常是指在语句块里定义的短暂生命周期的局部变量, 其存储周期为'auto'，但这里讨论的是c++中'temporary object', 是在老版本c++中
而语句块里定义的变量以及非引用类型参数，并不属于这里的临时变量  </p>
<p>c++中的临时变量出现情况：
* litteral常量, 如1
* 类型转换   // 赋值语句结束后，自动销毁
* 函数返回值 // 赋值语句结束后，自动销毁
* 表达式的值 </p>
<p>而临时变量的定义就是<code>编译器自动创建和销毁的没有名字的变量</code>, 也无法取地址。并且规定：<br />
- 常量类型的引用（<code>reference to const</code>）可以绑定到临时变量
- 非常量类型的引用（<code>reference to non-const</code>）类型不能绑定到临时变量</p>
<p>这个规定的原因是： 因为上面说的<code>编译器自动创建和销毁</code>，所以去修改一个会销毁变量是<code>没有意义的</code></p>
<h3 id="_2"><a class="toclink" href="../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/#_2">什么时候编译器要需要创建临时变量</a></h3>
<table>
<thead>
<tr>
<th>创建原因</th>
<th>销毁时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>Result of expression evaluation</td>
<td>All temporaries created as a result of expression evaluation are destroyed at the end of the expression statement (that is, at the semicolon), or at the end of the controlling expressions for for, if, while, do, and switch statements.</td>
</tr>
<tr>
<td>Initializing const references</td>
<td>If an initializer is not an l-value of the same type as the reference being initialized, a temporary of the underlying object type is created and initialized with the initialization expression. This temporary object is destroyed immediately after the reference object to which it is bound is destroyed.</td>
</tr>
</tbody>
</table>
<p>主要是以下两个地方会需要临时变量：
* 函数接受引用类型参数的时候
* 函数返回的时候
* 类型转换的时候</p>
<p>举例：</p>
<p>函数参数
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 此时创建了临时变量，可以想象成&#39;foo(int _tmp(i));&#39; 而且这个_tmp 不能被修改</span>
</code></pre></div></p>
<p>函数返回值
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(){</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// 此时创建了临时变量， int _tmp = foo(); int i = _tmp;</span>
</code></pre></div></p>
<p>类型转换
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// double _tmp = i; double d = _tmp;</span>
</code></pre></div></p>
<h3 id="_3"><a class="toclink" href="../../2021/03/02/%E5%8F%B3%E5%80%BC-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8/#_3">单独讨论这些似乎意义不大， 但是在实际编写代码的时候，可能会有疑惑</a></h3>
<p>例如如何解释
<div class="highlight"><pre><span></span><code>const int&amp; cr = 1; // ok
int &amp;r = 1; // ng
</code></pre></div>
这里赋值和函数传参一样， 因为1是常数，这里为常量<code>1</code>创建临时变量， 而只有<code>reference to const</code> 才能绑定到临时变量上</p>
<p>还有解释一个经常被引用的例子
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"> </span><span class="c1">// ng</span>
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok</span>
</code></pre></div>
这里虽然i和d都不是常量（不会创建临时变量）， 但是因为类型不同， 发生了类型转换，创建了临时变量。同样地，只有<code>reference to const</code> 才能绑定到临时变量上</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-02-05 00:00:00+00:00">2021年2月5日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">子串查找算法</a></h2>
<p>leetcode的<a href="https://leetcode-cn.com/problems/implement-strstr/">题目</a>, 实现strstr,即查找子字符串</p>
<h3 id="_2"><a class="toclink" href="../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#_2">最简单的算法</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">strStr</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">){</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">needle</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="kmp"><a class="toclink" href="../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#kmp">kmp 算法</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++ program for implementation of KMP pattern searching </span>
<span class="c1">// algorithm </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="c1"> </span>

<span class="kt">void</span><span class="w"> </span><span class="nf">computeLPSArray</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">lps</span><span class="p">);</span><span class="w"> </span>

<span class="c1">// Prints occurrences of txt[] in pat[] </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">KMPSearch</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">txt</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">txt</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// create lps[] that will hold the longest prefix suffix </span>
<span class="w">    </span><span class="c1">// values for pattern </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">M</span><span class="p">];</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Preprocess the pattern (calculate lps[] array) </span>
<span class="w">    </span><span class="n">computeLPSArray</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">lps</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// index for txt[] </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// index for pat[] </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Found pattern at index %d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"> </span>
<span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>

<span class="w">        </span><span class="c1">// mismatch after j matches </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="c1">// Do not match lps[0..lps[j-1]] characters, </span>
<span class="w">            </span><span class="c1">// they will match anyway </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">                </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>

<span class="c1">// Fills lps[] for given patttern pat[0..M-1] </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">computeLPSArray</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">lps</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// length of the previous longest prefix suffix </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// lps[0] is always 0 </span>

<span class="w">    </span><span class="c1">// the loop calculates lps[i] for i = 1 to M-1 </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pat</span><span class="p">[</span><span class="n">len</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">len</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="c1">// (pat[i] != pat[len]) </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="c1">// This is tricky. Consider the example. </span>
<span class="w">            </span><span class="c1">// AAACAAAA and i = 7. The idea is similar </span>
<span class="w">            </span><span class="c1">// to search step. </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lps</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>

<span class="w">                </span><span class="c1">// Also, note that we do not increment </span>
<span class="w">                </span><span class="c1">// i here </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="c1">// if (len == 0) </span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="w">                </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>

<span class="c1">// Driver program to test above function </span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">txt</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABABDABACDABABCABAB&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">pat</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABABCABAB&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">KMPSearch</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span><span class="w"> </span><span class="n">txt</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<h3 id="strstr"><a class="toclink" href="../../2021/02/05/%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#strstr">使用哈希查找和strstr速度比较</a></h3>
<p>hash在查找字符串时，每次偏移1个字节，并计算hash, 为了不重复计算重叠部分，有个算法'Karp-Rabin with Rolling Hash'。 但是速度都不如glibc的 strstr， 因为这里的hash函数没有用到硬件加速，但是strstr用了。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define BASE 256         </span><span class="c1">// Alphabet size (ASCII)</span>
<span class="cp">#define MOD 101          </span><span class="c1">// A prime number to avoid overflow</span>

<span class="c1">// Rolling hash version of strstr()</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">rabin_karp_strstr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">haystack</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">hash_needle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Hash for needle</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Hash for current window in haystack</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The value of h is BASE^(m-1) % MOD</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BASE</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate the hash value of needle and first window</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hash_needle</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash_needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">        </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash_window</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Slide the pattern over text</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hash_needle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_window</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Verify characters to avoid false positive</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Calculate hash for next window</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">hash_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BASE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">hash_window</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="p">])</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hash_window</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">hash_window</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">MOD</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ensure non-negative</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-28 00:00:00+00:00">2021年1月28日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="systemd"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/">创建 systemd 服务</a></h2>
<p>说一个老话， 现在systemd作为linux的启动管理和服务管理已经越来越重要了， 上周考试也遇到用systemd 来管理容器，这里记录一下如何编写systemd服务</p>
<h3 id="systemd_1"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#systemd_1">关于systemd</a></h3>
<p>systemd是只能运行在Linux上的init, 也就是启动后看到的1号进程。 除了启动， systemd还管理着很多东西，例如网络（systemd-networkd）， 域名解析（systemd-resolved），为服务创建socket(systemd.socket) 文件系统挂载，还有系统和用户的服务<br />
systemd太大，说不完，需要查看各种文档</p>
<h3 id="systemd_2"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#systemd_2">systemd 的两种使用模式</a></h3>
<p>systemd 分为system级别和user级别， 对应的unit文件分别在/etc/systemd/ 和 ～/.config/systemd/下， 前者是系统级别，后者是用户级别。 用户只能运行自己设置的服务</p>
<p><div class="highlight"><pre><span></span><code>systemctl start system_service.service
</code></pre></div>
而普通用户只能执行
<div class="highlight"><pre><span></span><code>systemctl --user user_service.service
</code></pre></div></p>
<p>这个name就是文件名称，例如必须'/etc/systemd/system/'下存在'system_service.service'文件，在能执行第一条的命令、 必须在 '~/.config/systemd/user/'下存在'user_service.service'在能执行第二条命令</p>
<h4 id="_1"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#_1">系统服务以其他用户运行服务</a></h4>
<p>系统级别的服务默认会以root来运行服务，但是也可以设置以其他用户来运行来最小化权限，例如音视频服务。也可以以某个用户来执行，那么service unit 文件就变为'system_service@user.service'</p>
<div class="highlight"><pre><span></span><code># system_service@user.service
[Unit]
Description=Watchman for user %i
After=remote-fs.target
Conflicts=shutdown.target

[Service]
ExecStart=/usr/local/bin/watchman --foreground --inetd
ExecStop=pkill -u %i -x watchman
Restart=on-failure
User=%i
Group=users
StandardInput=socket
StandardOutput=syslog
SyslogIdentifier=watchman-%i

[Install]
WantedBy=multi-user.target
</code></pre></div>
<p>上面的服务以下面的socket 单元启动， 前提要这个服务实现接收socket,通过<code>sd_listen_fds(3)</code>
<div class="highlight"><pre><span></span><code># system_service@user.socket

[Unit]
Description=Watchman socket for user %i

[Socket]
ListenStream=/var/facebook/watchman/%i-state/sock
Accept=false
SocketMode=0664
SocketUser=%i
SocketGroup=othergroup

[Install]
WantedBy=sockets.target
</code></pre></div></p>
<h4 id="_2"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#_2">普通用户运行服务</a></h4>
<p>注意， 普通用户因为只会以自己的身份启动，所以不能想系统服务那样指定'User/Group'
<div class="highlight"><pre><span></span><code>[Unit]
Description=tun2socks for vpn
#Requires=ssh_to_alpha.service

[Service]
Type=simple
ExecStart=/usr/bin/badvpn-tun2socks 

[Install]
WantedBy=default.target
</code></pre></div></p>
<p>若希望这个用户自定义服务能自启动， WantedBy需要设置成'default.target'</p>
<h3 id="unit-file"><a class="toclink" href="../../2021/01/28/%E5%88%9B%E5%BB%BA-systemd-%E6%9C%8D%E5%8A%A1/#unit-file">自动创建unit-file</a></h3>
<p>以下命令可以自动在对应目录创建*.service文件
<div class="highlight"><pre><span></span><code>systemctl --user --force --full edit test.service 
</code></pre></div></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-21 00:00:00+00:00">2021年1月21日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="rhel"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/">rhel系列修改密码</a></h2>
<p>考rhce8 栽在改密码了， 现在彻底弄明白</p>
<h3 id="selinux"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#selinux">关于selinux</a></h3>
<p>这是rhel和其他发行版的最大区别，也是我忽略的点。启用selinux 时，改密码后，额外要执行<code>touch /.autorelabel</code>， 新密码才能生效，而平时我使用centos一直是禁用selinux的。</p>
<h3 id="selinux_1"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#selinux_1">启用selinux</a></h3>
<p>selinux 默认状态是enforcing, 禁用时为disable, 通过<code>sestate</code> 查看状态。</p>
<h4 id="etcselinuxconfig"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#etcselinuxconfig">编译'/etc/selinux/config'</a></h4>
<p>修改selinux配置，从disable 到enforcing</p>
<h4 id="_1"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_1">执行两次下面动作</a></h4>
<p>创建这个文件的意义是重新label selinux, 不仅是当修改selinux配置需要做，在重置root密码时也是需要
<div class="highlight"><pre><span></span><code>touch /.autorelabel
reboot
</code></pre></div></p>
<h3 id="_2"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_2">叙说改密</a></h3>
<p>rhel5~8有两种方式重置密码，老版本为给linux启动参数加上'init=/bin/sh', 新版本为加<code>rd.break</code><br />
老版本适用于centos8（已测）, 而新版本应该不支持rhel5，6（未测），下面是完整步骤</p>
<h4 id="_3"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_3">老版本</a></h4>
<ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加'init=/bin/sh'</li>
<li>按ctrl+x继续，系统自动进入内存文件系统的根目录</li>
<li>执行<code>/sbin/load_policy -i</code>来初始化selinux</li>
<li>此时系统处于ro模式，执行<code>mount -oremount,rw /</code> 重新挂载根分区，使系统可写</li>
<li><code>passwd</code> 设置root密码</li>
<li>如果启用了selinux, 额外要执行<code>touch /.autorelabel</code></li>
<li>最后执行<code>exit</code>或者 <code>exec /sbin/reboot</code> 或者<code>exec /sbin/init</code></li>
</ol>
<h4 id="_4"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_4">新版本</a></h4>
<ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加'rd.break'</li>
<li>按ctrl+x继续，系统自动进入root系统，此时真正的文件系统以ro挂载在/sysroot</li>
<li>执行<code>mount -oremount,rw /sysrot</code> 重新挂载</li>
<li>执行<code>chroot /sysroot</code> 进入系统</li>
<li>执行<code>passwd</code>设置root密码</li>
<li>如果启用了selinux, 需要额外创建文件<code>touch /.autorelabel</code></li>
<li>执行<code>exit</code> 退出，然后执行 <code>umount /sysroot</code> 来确保写入</li>
<li>reboot 来重新进入</li>
</ol>
<h3 id="rescue"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#rescue">通过rescue模式改密码</a></h3>
<p>任何发行版都可以通过光盘引导来改密。如果熟悉archlinux安装的方式，就知道进入live os之后可以挂载原系统的磁盘<br />
然后chroot成为root用户，就能直接执行<code>passwd</code>来修改密码</p>
<h3 id="_5"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_5">通过修改镜像改密码</a></h3>
<p>最暴力的方式就是用guestfish工具, 一条命令改密。当然得先获取镜像文件<br />
先切换到root用户，使用guestmount命令挂载分区，-i表示自动挂载
<div class="highlight"><pre><span></span><code>guestmount --add base.raw  -i /tmp/hm
</code></pre></div>
然后chroot到挂载点
<div class="highlight"><pre><span></span><code>chroot /tmp/hm
</code></pre></div>
然后改密
<div class="highlight"><pre><span></span><code>passwd
</code></pre></div></p>
<p>virt提供了简化版本，一条命令就能改密码
<div class="highlight"><pre><span></span><code>virt-customize -a centos8.qcow2 --root-password password:123456
</code></pre></div></p>
<p>可见镜像文件有多么不安全</p>
<h3 id="vmwarekvm"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#vmwarekvm">最后记录一下vmware虚拟机镜像转换kvm镜像</a></h3>
<p>由于收到的vmware镜像，又没有装vmware workstation，所以找到转换镜像的方法，也很方便
<div class="highlight"><pre><span></span><code>qemu-img convert  CentOS\ 5.vmdk  base-000001.raw       
</code></pre></div>
但问题是不支持转换快照文件</p>
<h3 id="_6"><a class="toclink" href="../../2021/01/21/rhel%E7%B3%BB%E5%88%97%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/#_6">引用</a></h3>
<p>https://docs.openstack.org/image-guide/convert-images.html</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-01-19 00:00:00+00:00">2021年1月19日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="weechat"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">weechat 使用方法</a></h2>
<p>weechat 是一个irc客户端， 在终端中运行，不需要gui桌面，非常方便。 这里记录配置方法</p>
<p>主要参考<a href="https://samirparikh.com/blog/setting-up-weechat-commandline-irc-client.html">链接</a></p>
<h3 id="weechat_1"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#weechat_1">安装和运行weechat</a></h3>
<p>安装后，直接在终端运行<code>weechat</code>，就能进入weechat</p>
<h3 id="_1"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_1">配置</a></h3>
<h4 id="server"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#server">添加server</a></h4>
<p>irc有很多server, 常用的是freenode。 另外有darkscience。 添加方法如下，另外weechat里面命令都是以'/' 开头，还能使用tab补全
<div class="highlight"><pre><span></span><code>/server add freenode chat.freenode.net/6697 -ssl
</code></pre></div>
irc 除了有很多服务器url, 每个url 还有多个端口供链接，比如6697</p>
<h4 id="_2"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_2">设置昵称</a></h4>
<p>昵称默认是linux系统的用户名，昵称用来在聊天中显示名称
<div class="highlight"><pre><span></span><code>/nick mynickname
</code></pre></div>
**注意：
手动修改昵称不是简单的事情，特别是当已经连接serer时。 比较方便的办法就是直接改配置文件
<div class="highlight"><pre><span></span><code># ～/.weechat/irc.conf
nicks = &quot;malloy,malloy1,malloy2&quot;
</code></pre></div>
带后缀的昵称用来当malloy占用时的备用，比如网络重连时昵称有冲突就需要备用昵称</p>
<h4 id="_3"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_3">注册昵称</a></h4>
<p>因为有很多聊天室要求注册后才能进入，所以先要使用邮箱注册
<div class="highlight"><pre><span></span><code>/msg nickserv register userpassword example@email
</code></pre></div></p>
<p>然后irc 会提示查收邮件，在邮件里面提示你在irc输入命令完成注册</p>
<h4 id="_4"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_4">加入聊天室</a></h4>
<p>聊天室都是以#开头，例如我使用的 '#archlinuxcn'
<div class="highlight"><pre><span></span><code>/join #weechat
</code></pre></div></p>
<h4 id="_5"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_5">退出聊天室</a></h4>
<p><div class="highlight"><pre><span></span><code>/parted &quot;leave message&quot;
</code></pre></div>
或者
<div class="highlight"><pre><span></span><code>/close
</code></pre></div></p>
<h3 id="_6"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_6">自动设置</a></h3>
<p>设置打开weechat时，自动登陆和自动进入聊天室</p>
<div class="highlight"><pre><span></span><code>/set irc.server.freenode.autoconnect on
/set irc.server.networkname.autojoin &quot;#channel1,#channel2&quot;
</code></pre></div>
<h3 id="_7"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_7">界面设置</a></h3>
<p>先介绍weechat的各名称对应命令 : 
聊天室称为buffer, 切换聊天室命令 <code>/buffer n</code><br />
最左边的聊天列表是bufferlist bar<br />
进入buffer后，最右边的是nicklist bar，一个聊天室界面叫做window， 所以下面的命令设置就与 /bar /windows 有关</p>
<p>隐藏和显示bufferlist
<div class="highlight"><pre><span></span><code>/bar hiden bufferlist 
/bar show bufferlist
/bar toggle bufferlist
</code></pre></div>
分屏显示所有聊天室，水平分屏splith,竖直分屏 splitev
<div class="highlight"><pre><span></span><code>/window splitv 
</code></pre></div>
窗口切换
<div class="highlight"><pre><span></span><code>/window +1
/window -1
</code></pre></div>
窗口合并
<div class="highlight"><pre><span></span><code>/window merge
</code></pre></div></p>
<h3 id="_8"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_8">安全设置</a></h3>
<ol>
<li>上面添加服务器时，已经配置了ssl选项，就表示使用通讯加密了，但irc的聊天记录一般是对外公开的  </li>
<li>设置weechat开启密码， 进入weechat前验密
<div class="highlight"><pre><span></span><code>/secure passphrase superSecretPassphrase
</code></pre></div></li>
</ol>
<h3 id="_9"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_9">自动化设置和鉴权</a></h3>
<p>注册好昵称之后，配置自动化登陆，而不需要手动执行命令</p>
<p>设置irc登陆昵称，作为identify的参数，务必要跟register的保持一致
<div class="highlight"><pre><span></span><code>/secure set networkname_nickname password
</code></pre></div>
设置irc登陆密码，作为identify的参数，务必要跟register的密码保持一致
<div class="highlight"><pre><span></span><code>/secure set networkname_password password
</code></pre></div></p>
<p>设置weechat启动时自动登陆服务器，以及自动加入channel
<div class="highlight"><pre><span></span><code>/set irc.server.libera.autoconnect on
/set irc.server.libera.autojoin &quot;#archlinux-cn,#c,#c++&quot;
</code></pre></div>
以及自动验密
<div class="highlight"><pre><span></span><code>/set irc.server.networkname.command &quot;/msg nickserv identify ${sec.data.networkname_nickname} ${sec.data.network_password}&quot;
</code></pre></div>
其实显而易见地，<code>sec.data.networkname_nickname</code>和<code>sec.data.network_password</code> 都只是保存在sec.data里的变量，其实可以两个变量合成一条也没问题</p>
<h3 id="_10"><a class="toclink" href="../../2021/01/19/weechat-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#_10">更多功能</a></h3>
<p>weechat有很多拓展插件，可以完成很多事情，比如自动回复，远程控制，连接telegram等, <a href="https://weechat.org/scripts/">参考</a></p>
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <a class="md-pagination__link" href="../..">1</a> <span class="md-pagination__dots">..</span> <a class="md-pagination__link" href="../7/">7</a> <a class="md-pagination__link" href="../8/">8</a> <span class="md-pagination__current">9</span> <a class="md-pagination__link" href="../10/">10</a> <a class="md-pagination__link" href="../11/">11</a> <span class="md-pagination__dots">..</span> <a class="md-pagination__link" href="../13/">13</a>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
        
          
          <a href="../../tags/" class="md-footer__link md-footer__link--next" aria-label="下一页: Tags">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                Tags
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.tabs.sticky", "navigation.instant", "navigation.instant.progress", "navigation.footer", "toc.follow", "content.code.copy", "content.action.view"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../js/tex-mml-chtml.js"></script>
      
        <script src="../../js/mermaid.min.js"></script>
      
    
  </body>
</html>