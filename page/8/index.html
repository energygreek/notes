
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/page/8/">
      
      
      
        <link rel="next" href="../../tags/">
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>Welcome - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#welcome" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Welcome
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Welcome

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../archive/2025/" class="md-tabs__link">
          
  
  
    
  
  归档

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    
      
    
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="../.." class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bash" class="md-nav__link">
    <span class="md-ellipsis">
      bash使用技巧收集
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#go" class="md-nav__link">
    <span class="md-ellipsis">
      go 学习笔记
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      c++ 存储周期、链接和作用域
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 调优
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grpc-callback-api" class="md-nav__link">
    <span class="md-ellipsis">
      grpc callback api
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rpc" class="md-nav__link">
    <span class="md-ellipsis">
      rpc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#segfault-in-dmesg" class="md-nav__link">
    <span class="md-ellipsis">
      segfault in dmesg
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      cmake 学习
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      cmake 使用第三方库
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      shell 笔记
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tags
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    归档
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2021/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2021
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2020/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2020
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../archive/2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2019
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bash" class="md-nav__link">
    <span class="md-ellipsis">
      bash使用技巧收集
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#go" class="md-nav__link">
    <span class="md-ellipsis">
      go 学习笔记
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      c++ 存储周期、链接和作用域
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 调优
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grpc-callback-api" class="md-nav__link">
    <span class="md-ellipsis">
      grpc callback api
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rpc" class="md-nav__link">
    <span class="md-ellipsis">
      rpc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#segfault-in-dmesg" class="md-nav__link">
    <span class="md-ellipsis">
      segfault in dmesg
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      cmake 学习
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      cmake 使用第三方库
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      shell 笔记
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="welcome">Welcome<a class="headerlink" href="#welcome" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-05-21 00:00:00+00:00">2021年5月21日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="bash"><a class="toclink" href="../../2021/05/21/bash-learning/">bash使用技巧收集</a></h2>
<p>Linux的命令行是非常强大的生产工具，现实中的问题好多可以不写复杂的编程代码而通过命令来解决, 而且不过几行代码而已  </p>
<h3 id="shell"><a class="toclink" href="../../2021/05/21/bash-learning/#shell">shell 内建命令</a></h3>
<p>当执行which的时候，比如<code>which echo</code> 会输出'shell built-in command'而不是返回路径，就说明这个命令是内建命令<br />
shell在执行内建命令时是直接执行，而非内建命令则fork一个子进程来执行</p>
<h3 id="buffpipedelimiter"><a class="toclink" href="../../2021/05/21/bash-learning/#buffpipedelimiter">命令行的问题很多与缓冲buff、重定向pipe、delimiter分割符有关</a></h3>
<h3 id="_1"><a class="toclink" href="../../2021/05/21/bash-learning/#_1">技巧, 用命令代替编程</a></h3>
<h4 id="xargs"><a class="toclink" href="../../2021/05/21/bash-learning/#xargs">使用xargs创建多进程并发</a></h4>
<p>xargs可以将输入多进程并发处理，配合<code>find</code> 非常厉害。 配合wget就是一个并发爬虫了</p>
<div class="highlight"><pre><span></span><code>EXAMPLES
       find /tmp -name core -type f -print | xargs /bin/rm -f

       Find files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly if there are any filenames containing newlines or spaces.

       find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

       Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing spaces or newlines  are  correctly
       handled.

       find /tmp -depth -name core -type f -delete

       Find  files  named  core in or below the directory /tmp and delete them, but more efficiently than in the previous example (because we avoid the need to use fork(2) and exec(2) to
       launch rm and we don&#39;t need the extra xargs process).

       cut -d: -f1 &lt; /etc/passwd | sort | xargs echo

       Generates a compact listing of all the users on the system.
</code></pre></div>
<h3 id="find-exec"><a class="toclink" href="../../2021/05/21/bash-learning/#find-exec">find -exec 用法</a></h3>
<p><div class="highlight"><pre><span></span><code>find . -exec grep chrome {} \;
find . -exec grep chrome {} +
</code></pre></div>
1. \; 是转义;
2. {} 会替换成 find出的文件名。
2. ; 和 + 的区别是： 当;时，grep命令会在每个文件名上执行一次，grep执行多次， 但+时，所有的文件名会将所有的文件名一次进行grep，grep执行一次。</p>
<h4 id="awk-ors"><a class="toclink" href="../../2021/05/21/bash-learning/#awk-ors">使用awk ORS 分割结果</a></h4>
<p>ls 本来是行分隔的
awk将ls的换行符变为|分割
<div class="highlight"><pre><span></span><code>ls<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span><span class="s1">&#39;{ ORS=&quot;|&quot;; print; }&#39;</span>
</code></pre></div>
而<code>echo $(ls)</code> 则把ls的换行符变为空格</p>
<h4 id="declare"><a class="toclink" href="../../2021/05/21/bash-learning/#declare">使用declare 声明变量的类型和属性</a></h4>
<p>declare可以指定变量的类型'-i'为整形，'-r'制度(等同shell的readonly)，'-g'全局变量
shell默认是字符串，使用'-i'后，数学运算不需要<code>let</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">#retry=0</span>
<span class="nb">declare</span><span class="w"> </span>-i<span class="w"> </span><span class="nv">retry</span><span class="o">=</span><span class="m">0</span>
<span class="k">while</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="nv">$retry</span><span class="w"> </span>-lt<span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
ps<span class="w"> </span>aux<span class="w"> </span>--cols<span class="o">=</span><span class="m">1024</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>xxx
<span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="nv">$?</span><span class="w"> </span>-eq<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
<span class="k">fi</span>
sleep<span class="w"> </span><span class="m">1</span>
<span class="c1">#let retry=$retry+1</span>
<span class="nv">retry</span><span class="o">=</span><span class="nv">$retry</span>+1
<span class="k">done</span>
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-05-21 00:00:00+00:00">2021年5月21日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="go"><a class="toclink" href="../../2021/05/21/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">go 学习笔记</a></h2>
<h3 id="go_1"><a class="toclink" href="../../2021/05/21/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#go_1">go为什么要指针和什么时候必须用指针</a></h3>
<ol>
<li>传递waitgroup时</li>
<li>获取命令行参数</li>
</ol>
<h3 id="_1"><a class="toclink" href="../../2021/05/21/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#_1">全局变量和多变量赋值问题</a></h3>
<p>因为很多函数需要处理error, 当存在全局变量时，可能会覆盖全局变量</p>
<p><div class="highlight"><pre><span></span><code>var global_var int = 1
func foo(){
  // 此时覆盖了全局变量
  global_var, err := os.OpenFile(&quot;file&quot;)
}
</code></pre></div>
应改为
<div class="highlight"><pre><span></span><code>var global_var int = 1
func foo(){
  var err error
  global_var, error = os.OpenFile(&quot;file&quot;)
}
</code></pre></div></p>
<h3 id="slice"><a class="toclink" href="../../2021/05/21/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#slice">数组和slice的区别</a></h3>
<p>数组和slice使用上如同c++里的std::array和std::vector, 数组的长度固定，slice长度可以2倍扩容<br />
但有传参上有大区别: golang中数组是值传递，相当于将整个数组复制一遍，而slice是引用传递，所以slice用得多，map同理  </p>
<p>定义数组和slice:
<div class="highlight"><pre><span></span><code><span class="c1">// 数组</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span>
<span class="nx">arr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">array2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">}</span>
<span class="nx">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1">// 省略长度</span>
<span class="nx">q2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="mi">99</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="c1">// 前99项为0,第100个元素是-1</span>

<span class="c1">// slice</span>
<span class="nx">s1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">  </span><span class="c1">//a是数组</span>
<span class="nx">s2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span><span class="w">         </span>
<span class="nx">s3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span>
</code></pre></div></p>
<h3 id="var-make"><a class="toclink" href="../../2021/05/21/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#var-make">var 和 := 区别, 以及哪些类型需要make</a></h3>
<p>两者很多时候可以相互替换，但是在不同类型上，有区别</p>
<p>对于基本类型string, int, boolean, 数组，var<code>声明</code>即初始化
<div class="highlight"><pre><span></span><code>var str string // 自动初始化为空字符串
var inter int // 自动初始化为0
var bo bool // 自动初始化为false

// 可以直接使用
fmt.Printf(&quot;%s %d %t&quot;, str, inter, bo) 
</code></pre></div></p>
<p>而对于slice, map, chann类型而言, 使用<code>var m map[int]string</code>只是声明，需要再用<code>make</code>来获得内存和初始化
<div class="highlight"><pre><span></span><code>var m map[int] string // 此时不能使用m
m = make(map[int] string){1:&quot;a&quot;,2:&quot;b&quot;}
fmt.Println(m[1])
</code></pre></div>
而上面的步骤可以简化成
<div class="highlight"><pre><span></span><code>m := make(map[int] string){1:&quot;a&quot;, 2:&quot;b&quot;}
</code></pre></div>
或直接
<div class="highlight"><pre><span></span><code>m := map[int] string{1:&quot;a&quot;, 2:&quot;b&quot;}
</code></pre></div></p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-29 00:00:00+00:00">2021年4月29日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="c"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/">c++ 存储周期、链接和作用域</a></h2>
<h3 id="c_1"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#c_1">c++中变量和函数的三个重要属性</a></h3>
<p>存储周期类型： 有关变量的创建和销毁
链接类型： 有关变量函数的内存位置
作用域: 有关变量函数的可见范围</p>
<p>本文讨论的标识符，包括变量和函数</p>
<h3 id="_1"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#_1">存储说明符</a></h3>
<p><code>存储说明符</code>控制变量何时分配和释放，有以下几种</p>
<ul>
<li>automatic</li>
<li>thread_local</li>
<li>static </li>
<li>register</li>
<li>mutable</li>
<li>extern</li>
</ul>
<p>说明
- automatic: 最常见的局部变量，且没有声明为static或者thread_local，位于栈上, 随着代码块的执行和结束而自动分配和销毁
- static: 静态变量, 在程序启动和结束时创建和销毁，但初始化是在第一次执行初始化代码时执行
- thread: 在线程开始和结束时分配和销毁
- dynamic: 最常见的堆上的变量, 需要执行new和delete, </p>
<p>auto 在c++11中不是声明存储周期，而是类型推导符, 但这种存储周期类型的依然存在（局部变量）  </p>
<h3 id="_2"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#_2">初始化的时机</a></h3>
<ul>
<li>automatic: 必须手动初始化，换句话说局部变量必须初始化，否则值为不确定</li>
<li>static: 在执行时初始化，且初始化一次，特殊情况下在执行前初始化</li>
<li>thread: 因为thread_local变量自带static性质，所以认为其同于static</li>
<li>dynamic: 在new时初始化</li>
</ul>
<h3 id="linkage"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#linkage">Linkage</a></h3>
<p>标识符（变量&amp;函数）用一块内存里的值或者函数体来表示的， 而linkage决定其他相同的标识符是否指向同一块内存。c/c++有3种linkage, no-linkage, internal linkage和external linkage</p>
<ul>
<li>no linkage 局部变量没有linkage, 所以两个a是独立的，后面的a会覆盖前面的a，不相干。此时linkage与可见域(scope)类似</li>
<li>internal linkage 表示只能在文件内部访问(file scope)，换句话就是不会暴露给链接器， 用修饰符<code>static</code>声明internal linkage，所以允许在不同文件声明两个名称&amp;类型相同的internal linkage 标识符，他们指向不同的内存单元。 </li>
<li>external linkage 表示可以在程序所有地方访问，包括外部文件(global scope)，所以是真“全局”（scope&amp;linkage）， 所有标识符指向独一份内存。</li>
</ul>
<h4 id="_3"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#_3">修饰符</a></h4>
<ul>
<li>全局const变量和全局constexpr变量默认具备internal linkage, 再加上<code>static</code>没有影响</li>
<li>全局非const变量默认是external linkage， 故再加上extern没有影响。在其他文件使用<code>extern</code>声明这个变量，就能使用指向同一内存的变量</li>
<li>函数默认external linkage，故再加上extern没有影响。 在其他文件使用<code>extern</code>声明这个函数（可省），就能使用指向同一内存的函数</li>
<li>使用extern修饰全局const变量和constexpr变量可以使起具备external linkage</li>
</ul>
<p>可见<code>static</code>和<code>extern</code>即表示存储周期，又表示linkage， static相对简单，extern则比较复杂，如以下情况
<div class="highlight"><pre><span></span><code>int g_x = 1; // 定义有初始化的全局变量（可加可不加extern）
int g_x; // 定义没有初始化的全局变量（不可加extern），可选初始化
extern int g_x; // 前置声明一个全局变量，不可初始化

extern const int g_y { 1 }; // 定义全局常量，const必须初始化
extern const int g_y; // 前置声明全局常量，不可初始化
</code></pre></div></p>
<p>所以若是定义未初始化的全局变量，不能加extern，不然就成了前置声明了。</p>
<h4 id="constexpr"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#constexpr">constexpr 特殊情况</a></h4>
<p>虽然通过给constexpr添加<code>extern</code>修饰符来让其具备external属性，但不能在其他文件前置声明。因为constexpr是在编译期替换的，编译器（compile)的可见域限定在文件内，所以编译期无法知道constexpr的值，所以在编译期无法获取到其内存单元的值， 也就无法在其他文件进行声明，只能定义。</p>
<h3 id="file-scopeglobal-scope"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#file-scopeglobal-scope">file scope和global scope</a></h3>
<p>局部变量的scope、no-linkage以及duration相同，从<code>{</code>开始到<code>}</code>结束。 理论上global scope涵盖了file scope。而linkage来规定其是否能在其他文件里使用。</p>
<h3 id="local-class"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#local-class">local class</a></h3>
<p>local class 不允许有static data member</p>
<h3 id="_4"><a class="toclink" href="../../2021/04/29/c-%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/#_4">参考</a></h3>
<p>https://en.cppreference.com/w/cpp/language/storage_duration</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-15 00:00:00+00:00">2021年4月15日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="linux"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/">Linux 调优</a></h2>
<p>系统原厂商是不喜欢讨论系统调优的，一方面说起来没完没了，二来比较复杂，而且私以为调优即说明系统默认不够好？</p>
<p>而且SUSE的原厂<a href="https://www.suse.com/support/handbook/#donotsupport">规定</a>:</p>
<p>原理机制的介绍及系统调优并不在我们的技术支持范畴</p>
<p>这里是一点相关介绍</p>
<h3 id="buffercache"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#buffercache">buffer/cache 的作用和区别</a></h3>
<p>buffer是用于存放将要输出到disk（块设备）的数据，而cache是存放从disk上读出的数据。二者都是为提高IO性能而设计的。                                                                                                                                                       <br />
- buffer：缓冲将数据缓冲下来，解决速度慢和快的交接问题；速度快的需要通过缓冲区将数据一点一点传给速度慢的区域。                                                                               <br />
例如：从内存中将数据往硬盘中写入，并不是直接写入，而是缓冲到一定大小之后刷入硬盘中。                                                                                                         <br />
A buffer is something that has yet to be "written" to disk.                                                                                                                                    </p>
<ul>
<li>cache：缓存实现数据的重复使用，速度慢的设备需要通过缓存将经常要用到的数据缓存起来，缓存下来的数据可以提供高速的传输速度给速度快的设备。                                                    <br />
例如：将硬盘中的数据读取出来放在内存的缓存区中，这样以后再次访问同一个资源，速度会快很多。                                                                                                   <br />
A cache is something that has been "read" from the disk and stored for later use.                                                           </li>
</ul>
<p>总之buff和cache都是内存和硬盘之间的过渡，前者是写入磁盘方向，而后者是写入内存方向</p>
<h4 id="cache"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#cache">回收cache</a></h4>
<p><div class="highlight"><pre><span></span><code>drop_caches回收一下。
#sync;sync;sync
#echo 3 &gt; /proc/sys/vm/drop_caches    
</code></pre></div>
free增加300M</p>
<h3 id="swap"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#swap">swap 介绍</a></h3>
<p>Swap意思是交换分区，是硬盘中的一个分区。内核将内存Page移出内存到swap分区(swap out)</p>
<p>swap通过 vm.swappiness 这个内核参数控制，默认值是60。<code>cat /proc/sys/vm/swappiness</code> 可以查看当前值<br />
这个参数控制内核使用swap的优先级。该参数从0到100。</p>
<p>设置该参数为0，表示只要有可能就尽力避免交换进程移出物理内存；                                                            <br />
设置该参数为100，这告诉内核疯狂的将swapout物理内存移到swap分区。
注意：设置该参数为0，并不代表禁用swap分区，只是告诉内核，能少用到swap分区就尽量少用到，设置vm.swappiness=100的话，则表示尽量使用swap分区。                                                    </p>
<p>这里面涉及到当然还涉swappiness及到复杂的算法。如果以为所有物理内在用完之后，再使用swap, 实事并不是这样。以前曾经遇到过，物理内存只剩下10M了，但是依然没有使用Swap交换空间，另外一台服务器，物理内存还剩下15G，居然用了一点点Swap交换空间。
其实少量使用Swap交换空间是不会影响性能，只有当内存资源出现瓶颈或者内存泄露，进程异常时导致频繁、大量使用交换分区才会导致严重性能问题。             </p>
<h4 id="swap_1"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#swap_1">问题：何时使用swap</a></h4>
<p>这个问题如上面说的，比较难说，理论上是当物理内存不够用的时候，又需要读入内存时，会将一些长时间不用的程序的内存Page 交换出去。                     <br />
但是很多时候会发现，内核即使在内存充足的情况下也是使用到swap</p>
<h4 id="swap_2"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#swap_2">问题: 那些东西被swap了？</a></h4>
<p>可以看下面的测试</p>
<h4 id="swap_3"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#swap_3">回收swap</a></h4>
<p>swapoff 之后执行<code>sudo sysctl vm.swappiness=0</code> 临时让内核不用swapout</p>
<p><div class="highlight"><pre><span></span><code>并把swap的数据加载内存，并重启swap 
#swapoff -a
#swapon -a
</code></pre></div>
即把swap分区清空,  自测效果如下，内核版本<code>5.10.0-8-amd64</code></p>
<div class="highlight"><pre><span></span><code>               total        used        free      shared  buff/cache   available
Mem:        12162380     4911564     5605744      459364     1645072     6466572
Swap:        1000444      763040      237404
</code></pre></div>
<p>重启swap后
<div class="highlight"><pre><span></span><code>               total        used        free      shared  buff/cache   available
Mem:        12162380     5605800     4843176      524984     1713404     5707112
Swap:        1000444           0     1000444
</code></pre></div></p>
<p>可见，停用swap后，swap的used大部分到了mem的<code>used</code>，小部分到了Mem的shared</p>
<h3 id="_1"><a class="toclink" href="../../2021/04/15/buffer-cache-too-high/#_1">调优的一些有效工具</a></h3>
<p>perf + flame火焰图: 查看运行耗时，可以查看函数调用耗时，如果是自己的程序，可以知道哪些函数需要优化
vmstat 查看磁盘io情况，使用<code>vmstat -t 3</code>命令，如果b状态的数字一直很大，那么说明磁盘阻塞严重，可能是磁盘坏了，可能是程序设计不合理</p>
<p>还有top，iperf等等</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-13 00:00:00+00:00">2021年4月13日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 13 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="grpc-callback-api"><a class="toclink" href="../../2021/04/13/grpc-callback-api/">grpc callback api</a></h2>
<h3 id="c-callback-based-asynchronous-api"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#c-callback-based-asynchronous-api">C++ callback-based asynchronous API</a></h3>
<ul>
<li>Author(s): vjpai, sheenaqotj, yang-g, zhouyihaiding</li>
<li>Approver: markdroth</li>
<li>Status: Proposed</li>
<li>Implemented in: https://github.com/grpc/grpc/projects/12</li>
<li>Last updated: March 22, 2021</li>
<li>Discussion at https://groups.google.com/g/grpc-io/c/rXLdWWiosWg</li>
</ul>
<h3 id="abstract"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#abstract">Abstract</a></h3>
<p>Provide an asynchronous gRPC API for C++ in which the completion of RPC actions in the library will result in callbacks to user code,</p>
<h3 id="background"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#background">Background</a></h3>
<p>Since its initial release, gRPC has provided two C++ APIs:</p>
<ul>
<li>Synchronous API</li>
<li>All RPC actions (such as unary calls, streaming reads, streaming writes, etc.) block for completion</li>
<li>Library provides a thread-pool so that each incoming server RPC executes its method handler in its own thread</li>
<li>Completion-queue-based (aka CQ-based) asynchronous API</li>
<li>Application associates each RPC action that it initiates with a tag</li>
<li>The library performs each RPC action</li>
<li>The library posts the tag of a completed action onto a completion queue</li>
<li>The application must poll the completion queue to determine which asynchronously-initiated actions have completed</li>
<li>The application must provide and manage its own threads</li>
<li>Server RPCs don't have any library-invoked method handler; instead the application is responsible for executing the actions for an RPC once it is notified of an incoming RPC via the completion queue</li>
</ul>
<p>The goal of the synchronous version is to be easy to program. However, this comes at the cost of high thread-switching overhead and high thread storage for systems with many concurrent RPCs. On the other hand, the asynchronous API allows the application full control over its threading and thus can scale further. The biggest problem with the asynchronous API is that it is just difficult to use. Server RPCs must be explicitly requested, RPC polling must be explicitly controlled by the application, lifetime management is complicated, etc. These have proved sufficiently difficult that the full features of the asynchronous API are basically never used by applications. Even if one can use the async API correctly, it also presents challenges in deciding how many completion queues to use and how many threads to use for polling them, as one can either optimize for reducing thread hops, avoiding stranding, reducing CQ contention, or improving locality. These goals are often in conflict and require substantial tuning.</p>
<h4 id="related-proposals"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#related-proposals">Related proposals</a></h4>
<ul>
<li>The C++ callback API has an implementation that is built on top of a new <a href="https://github.com/grpc/proposal/pull/181">callback completion queue in core</a>. There is also another implementation, discussed <a href="../../2021/04/13/grpc-callback-api/#implementation">below</a>.</li>
<li>The API structure has substantial similarities to the gRPC-Node and gRPC-Java APIs.</li>
</ul>
<h3 id="proposal"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#proposal">Proposal</a></h3>
<p>The callback API is designed to have the performance and thread scalability of an asynchronous API without the burdensome programming model of the completion-queue-based model. In particular, the following are fundamental guiding principles of the API:</p>
<ul>
<li>Library directly calls user-specified code at the completion of RPC actions. This user code is run from the library's own threads, so it is very important that it must not wait for completion of any blocking operations (e.g., condition variable waits, invoking synchronous RPCs, blocking file I/O).</li>
<li>No explicit polling required for notification of completion of RPC actions.</li>
<li>In practice, these requirements mean that there must be a library-controlled poller for monitoring such actions. This is discussed in more detail in the <a href="../../2021/04/13/grpc-callback-api/#implementation">Implementation</a> section below.</li>
<li>As in the synchronous API, server RPCs have an application-defined method handler function as part of their service definition. The library invokes this method handler when a new server RPC starts.</li>
<li>Like the synchronous API and unlike the completion-queue-based asynchronous API, there is no need for the application to "request" new server RPCs. Server RPC context structures will be allocated and have their resources allocated as and when RPCs arrive at the server.</li>
</ul>
<h4 id="reactor-model"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#reactor-model">Reactor model</a></h4>
<p>The most general form of the callback API is built around a <em>reactor</em> model. Each type of RPC has a reactor base class provided by the library. These types are:</p>
<ul>
<li><code>ClientUnaryReactor</code> and <code>ServerUnaryReactor</code> for unary RPCs</li>
<li><code>ClientBidiReactor</code> and <code>ServerBidiReactor</code> for bidi-streaming RPCs</li>
<li><code>ClientReadReactor</code> and <code>ServerWriteReactor</code> for server-streaming RPCs</li>
<li><code>ClientWriteReactor</code> and <code>ServerReadReactor</code> for client-streaming RPCs</li>
</ul>
<p>Client RPC invocations from a stub provide a reactor pointer as one of their arguments, and the method handler of a server RPC must return a reactor pointer.</p>
<p>These base classes provide three types of methods:</p>
<ol>
<li>Operation-initiation methods: start an asynchronous activity in the RPC. These are methods provided by the class and are not virtual. These are invoked by the application logic. All of these have a <code>void</code> return type. The <code>ReadMessageType</code> below is the request type for a server RPC and the response type for a client RPC; the <code>WriteMessageType</code> is the response type for a server RPC or the request type for a client RPC.</li>
<li><code>void StartCall()</code>: (<em>Client only</em>) Initiates the operations of a call from the client, including sending any client-side initial metadata associated with the RPC. Must be called exactly once. No reads or writes will actually be started until this is called (i.e., any previous calls to <code>StartRead</code>, <code>StartWrite</code>, or <code>StartWritesDone</code> will be queued until <code>StartCall</code> is invoked). This operation is not needed at the server side since streaming operations at the server are released from backlog automatically by the library as soon as the application returns a reactor from the method handler, and because there is a separate method just for sending initial metadata.</li>
<li><code>void StartSendInitialMetadata()</code>: (<em>Server only</em>) Sends server-side initial metadata. To be used in cases where initial metadata should be sent without sending a message. Optional; if not called, initial metadata will be sent when <code>StartWrite</code> or <code>Finish</code> is called. May not be invoked more than once or after <code>StartWrite</code> or <code>Finish</code> has been called. This does not exist at the client because sending initial metadata is part of <code>StartCall</code>.</li>
<li><code>void StartRead(ReadMessageType*)</code>: Starts a read of a message into the object pointed to by the argument. <code>OnReadDone</code> will be invoked when the read is complete. Only one read may be outstanding at any given time for an RPC (though a read and a write can be concurrent with each other). If this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void StartWrite(const WriteMessageType*)</code>: Starts a write of the object pointed to by the argument. <code>OnWriteDone</code> will be invoked when the write is complete. Only one write may be outstanding at any given time for an RPC (though a read and a write can be concurrent with each other).  As with <code>StartRead</code>, if this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void StartWritesDone()</code>: (<em>Client only</em>) For client RPCs to indicate that there are no more writes coming in this stream.  <code>OnWritesDoneDone</code> will be invoked when this operation is complete. This causes future read operations on the server RPC to indicate that there is no more data available. Highly recommended but technically optional; may not be called more than once per call.  As with <code>StartRead</code> and <code>StartWrite</code>, if this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void Finish(Status)</code>: (<em>Server only</em>) Sends completion status to the client, asynchronously. Must be called exactly once for all server RPCs, even for those that have already been cancelled. No further operation-initiation methods may be invoked after <code>Finish</code>.</li>
<li>Operation-completion reaction methods: notification of completion of asynchronous RPC activity. These are all virtual methods that default to an empty function (i.e., <code>{}</code>) but may be overridden by the application's reactor definition. These are invoked by the library. All of these have a <code>void</code> return type. Most take a <code>bool ok</code> argument to indicate whether the operation completed "normally," as explained below.</li>
<li><code>void OnReadInitialMetadataDone(bool ok)</code>: (<em>Client only</em>) Invoked by the library to notify that the server has sent an initial metadata response to a client RPC. If <code>ok</code> is true, then the RPC received initial metadata normally. If it is false, there is no initial metadata either because the call has failed or because the call received a trailers-only response (which means that there was no actual message and that any information normally sent in initial metadata has been dispatched instead to trailing metadata, which is allowed in the gRPC HTTP/2 transport protocol). This reaction is automatically invoked by the library for RPCs of all varieties; it is uncommonly used as an application-defined reaction however.</li>
<li><code>void OnReadDone(bool ok)</code>: Invoked by the library in response to a <code>StartRead</code> operation. The <code>ok</code> argument indicates whether a message was read as expected. A false <code>ok</code> could mean a failed RPC (e.g., cancellation) or a case where no data is possible because the other side has already ended its writes (e.g., seen at the server-side after the client has called <code>StartWritesDone</code>).</li>
<li><code>void OnWriteDone(bool ok)</code>: Invoked by the library in response to a <code>StartWrite</code> operation. The <code>ok</code> argument that indicates whether the write was successfully sent; a false value indicates an RPC failure.</li>
<li><code>void OnWritesDoneDone(bool ok)</code>: (<em>Client only</em>) Invoked by the library in response to a <code>StartWritesDone</code> operation. The bool <code>ok</code> argument that indicates whether the writes-done operation was successfully completed; a false value indicates an RPC failure.</li>
<li><code>void OnCancel()</code>: (<em>Server only</em>) Invoked by the library if an RPC is canceled before it has a chance to successfully send status to the client side. The reaction may be used for any cleanup associated with cancellation or to guide the behavior of other parts of the system (e.g., by setting a flag in the service logic associated with this RPC to stop further processing since the RPC won't be able to send outbound data anyway). Note that servers must call <code>Finish</code> even for RPCs that have already been canceled as this is required to cleanup all their library state and move them to a state that allows for calling <code>OnDone</code>.</li>
<li><code>void OnDone(const Status&amp;)</code> at the client, <code>void OnDone()</code> at the server: Invoked by the library when all outstanding and required RPC operations are completed for a given RPC. For the client-side, it additionally provides the status of the RPC (either as sent by the server with its <code>Finish</code> call or as provided by the library to indicate a failure), in which case the signature is <code>void OnDone(const Status&amp;)</code>. The server version has no argument, and thus has a signature of <code>void OnDone()</code>. Should be used for any application-level RPC-specific cleanup.</li>
<li><em>Thread safety</em>: the above calls may take place concurrently, except that <code>OnDone</code> will always take place after all other reactions. No further RPC operations are permitted to be issued after <code>OnDone</code> is invoked.</li>
<li><strong>IMPORTANT USAGE NOTE</strong> : code in any reaction must not block for an arbitrary amount of time since reactions are executed on a finite-sized, library-controlled threadpool. If any long-term blocking operations (like sleeps, file I/O, synchronous RPCs, or waiting on a condition variable) must be invoked as part of the application logic, then it is important to push that outside the reaction so that the reaction can complete in a timely fashion. One way of doing this is to push that code to a separate application-controlled thread.</li>
<li>RPC completion-prevention methods. These are methods provided by the class and are not virtual. They are only present at the client-side because the completion of a server RPC is clearly requested when the application invokes <code>Finish</code>. These methods are invoked by the application logic. All of these have a <code>void</code> return type.</li>
<li><code>void AddHold()</code>: (<em>Client only</em>) This prevents the RPC from being considered complete (ready for <code>OnDone</code>) until each <code>AddHold</code> on an RPC's reactor is matched to a corresponding <code>RemoveHold</code>. An application uses this operation before it performs any  <em>extra-reaction flows</em>, which refers to streaming operations initiated from outside a reaction method. Note that an RPC cannot complete before <code>StartCall</code>, so holds are not needed for any extra-reaction flows that take place before <code>StartCall</code>. As long as there are any holds present on an RPC, though, it may not have <code>OnDone</code> called on it, even if it has already received server status and has no other operations outstanding. May be called 0 or more times on any client RPC.</li>
<li><code>void AddMultipleHolds(int holds)</code>: (<em>Client only</em>) Shorthand for <code>holds</code> invocations of <code>AddHold</code> .</li>
<li><code>void RemoveHold()</code>: (<em>Client only</em>) Removes a hold reference on this client RPC. Must be called exactly as many times as <code>AddHold</code> was called on the RPC, and may not be called more times than <code>AddHold</code> has been called so far for any RPC. Once all holds have been removed, the server has provided status, and all outstanding or required operations have completed for an RPC, the library will invoke <code>OnDone</code> for that RPC.</li>
</ol>
<p>Examples are provided in <a href="https://github.com/grpc/grpc/pull/25728">the PR to de-experimentalize the callback API</a>.</p>
<h4 id="unary-rpc-shortcuts"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#unary-rpc-shortcuts">Unary RPC shortcuts</a></h4>
<p>As a shortcut, client-side unary RPCs <em>may</em> bypass the reactor model by directly providing a <code>std::function</code> for the library to call at completion rather than a reactor object pointer. This is passed as the final argument to the stub call, just as the reactor would be in the more general case. This is semantically equivalent to a reactor in which the <code>OnDone</code> function simply invokes the specified function (but can be implemented in a slightly faster way since such an RPC will definitely not wait separately for initial metadata from the server) and all other reactions are left empty. In practice, this is the common and recommended model for client-side unary RPCs, unless they have a specific need to wait for initial metadata before getting their full response message. As in the reactor model, the function provided as a callback may not include operations that block for an arbitrary amount of time.</p>
<p>Server-side unary RPCs have the option of returning a library-provided default reactor when their method handler is invoked. This is provided by calling <a href="../../2021/04/13/grpc-callback-api/#servercontext-extensions"><code>DefaultReactor</code> on the <code>CallbackServerContext</code></a>. This default reactor provides a <code>Finish</code> method, but does not provide a user callback for <code>OnCancel</code> and <code>OnDone</code>. In practice, this is the common and recommended model for most server-side unary RPCs unless they specifically need to react to an <code>OnCancel</code> callback or do cleanup work after the RPC fully completes.</p>
<h4 id="servercontext-extensions"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#servercontext-extensions">ServerContext extensions</a></h4>
<p><code>ServerContext</code> is now made a derived class of <code>ServerContextBase</code>. There is a new derived class of <code>ServerContextBase</code> called <code>CallbackServerContext</code> which provides a few additional functions:</p>
<ul>
<li><code>ServerUnaryReactor* DefaultReactor()</code> may be used by a method handler to return a default reactor from a unary RPC.</li>
<li><code>RpcAllocatorState* GetRpcAllocatorState</code>: see advanced topics section</li>
</ul>
<p>Additionally, the <code>AsyncNotifyWhenDone</code> function is not present in the <code>CallbackServerContext</code>.</p>
<p>All method handler functions for the callback API take a <code>CallbackServerContext*</code> as their first argument. <code>ServerContext</code> (used for the sync and CQ-based async APIs) and <code>CallbackServerContext</code> (used for the callback API) actually use the same underlying structure and thus their object pointers are meaningfully convertible to each other via a <code>static_cast</code> to <code>ServerContextBase*</code>. We recommend that any helper functions that need to work across API variants should use a <code>ServerContextBase</code> pointer or reference as their argument rather than a <code>ServerContext</code> or <code>CallbackServerContext</code> pointer or reference. For example, <code>ClientContext::FromServerContext</code> now uses a <code>ServerContextBase*</code> as its argument; this is not a breaking API change since the argument is now a parent class of the previous argument's class.</p>
<h4 id="advanced-topics"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#advanced-topics">Advanced topics</a></h4>
<h5 id="application-managed-server-memory-allocation"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#application-managed-server-memory-allocation">Application-managed server memory allocation</a></h5>
<p>Callback services must allocate an object for the <code>CallbackServerContext</code> and for the request and response objects of a unary call.  Applications can supply a per-method custom memory allocator for gRPC server to use to allocate and deallocate the request and response messages, as well as a per-server custom memory allocator for context objects. These can be used for purposes like early or delayed release, freelist-based allocation, or arena-based allocation. For each unary RPC method, there is a generated method in the server called <code>SetMessageAllocatorFor_*MethodName*</code> . For each server, there is a method called <code>SetContextAllocator</code>. Each of these has numerous classes involved, and the best examples for how to use these features lives in the gRPC tests directory.</p>
<ul>
<li><a href="https://github.com/grpc/grpc/blob/master/test/cpp/end2end/message_allocator_end2end_test.cc">Message allocator usage example</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/test/cpp/end2end/context_allocator_end2end_test.cc">Context allocator usage example</a></li>
</ul>
<h5 id="generic-non-code-generated-services"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#generic-non-code-generated-services">Generic (non-code-generated) services</a></h5>
<p><code>RegisterCallbackGenericService</code> is a new method of <code>ServerBuilder</code> to allow for processing of generic (unparsed) RPCs. This is similar to the pre-existing <code>RegisterAsyncGenericService</code> but uses the callback API and reactors rather than the CQ-based async API. It is expected to be used primarily for generic gRPC proxies where the exact serialization format or list of supported methods is unknown.</p>
<h5 id="per-method-specification"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#per-method-specification">Per-method specification</a></h5>
<p>Just as with async services, callback services may also be specified on a method-by-method basis (using the syntax <code>WithCallbackMethod_*MethodName*</code>), with any unlisted methods being treated as sync RPCs. The shorthand <code>CallbackService</code> declares every method as being processed by the callback API. For example:</p>
<ul>
<li><code>Foo::Service</code> -- purely synchronous service</li>
<li><code>Foo::CallbackService</code> -- purely callback service</li>
<li><code>Foo::WithCallbackMethod_Bar&lt;Service&gt;</code> -- synchronous service except for callback method <code>Bar</code></li>
<li><code>Foo::WithCallbackMethod_Bar&lt;WithCallbackMethod_Baz&lt;Service&gt;&gt;</code> -- synchronous service except for callback methods <code>Bar</code> and <code>Baz</code></li>
</ul>
<h3 id="rationale"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#rationale">Rationale</a></h3>
<p>Besides the content described in the background section, the rationale also includes early and consistent user demand for this feature as well as the fact that many users were simply spinning up a callback model on top of gRPC's completion queue-based asynchronous model.</p>
<h3 id="implementation"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#implementation">Implementation</a></h3>
<p>There is more than one mechanism available for implementing the background polling required by the C++ callback API. One has been implemented <a href="https://github.com/grpc/grpc/pull/25169">on top of the C++ completion queue API</a>. In this approach, the callback API uses a number of library-owned threads to call <code>Next</code> on an async CQ that is owned by the internal implementation. Currently, the thread count is automatically selected by the library with no user input and is set to half the system's core count, but no less than 2 and no more than 16. This selection is subject to change in the future based on our team's ongoing performance analysis and tuning efforts. Despite being built on the CQ-based async API, the developer using the callback API does not need to consider any of the CQ details (e.g., shutdown, polling, or even the existence of a CQ).</p>
<p>It is the gRPC team's intention that that implementation is only a temporary solution. A new structure called an <code>EventEngine</code> is being developed to provide the background threads needed for polling, and this sytem is also intended to provide a direct API for application use. This event engine would also allow the direct use of the <a href="https://github.com/grpc/proposal/blob/master/L68-core-callback-api.md">core callback API</a> that is currently only used by the Python async implementation. If this solution is adopted, there will be a new gRFC for it. This new implementation will not change the callback API at all but rather will only affect its performance. The C++ code for the callback API already has <code>if</code> branches in place to support the use of a poller that directly supplies the background threads, so the callback API will naturally layer on top of the <code>EventEngine</code> without further development effort.</p>
<h3 id="open-issues-if-applicable"><a class="toclink" href="../../2021/04/13/grpc-callback-api/#open-issues-if-applicable">Open issues (if applicable)</a></h3>
<p>N/A. The gRPC C++ callback API has been used internally at Google for two years now, and the code and API have evolved substantially during that period.</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-13 00:00:00+00:00">2021年4月13日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 4 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="rpc"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/">rpc</a></h2>
<p>rpc 意为<code>远程过程调用</code>, http, grpc 广义上讲都是rpc。
而且还有个项目叫<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>, 可以将grpc通过http的方式暴露。</p>
<h2 id="grpc"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc">grpc</a></h2>
<p>grpc 是rpc的一种实现，由google开源，其他还有thrift, sogorpc 等等。 并且grpc使用的http/2协议</p>
<h3 id="http11-http2"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#http11-http2">http/1.1 与 http/2 的区别</a></h3>
<ul>
<li>2使用二进制，而1.1使用文本，提高效率</li>
<li>2将相同的tcp连接合并为一个请求，提高性能,而1.1则为每个请求创建tcp连接</li>
<li>2的客户端使用流，这样可以多次请求</li>
<li>2含有trailers，也就是尾部消息，可以用来发送body的checksume等, 当然也可以直接放到body里
...</li>
</ul>
<p>而1.1中也已经实现服务端到客户端的流,使用'Transfer-Encoding=chunked'来替代'Content-Length'，详见<a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2">rfc</a>
<div class="highlight"><pre><span></span><code> A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.
</code></pre></div></p>
<h3 id="proto"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#proto">认识proto文件</a></h3>
<h4 id="proto-serviceservice"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#proto-serviceservice">proto 文件中多个service和单个service 区别</a></h4>
<p>在同一个service里的方法会codegen到同一个类，但这个类比较鸡肋。
由于RPC调用是RESTful的，所以多次调用或者多个rpc方法无法通过同一个service来共享数据，这需要使用者借助其他办法来解决。</p>
<p>service 还可以用以隔离相同名称的rpc， 如 
- service1/helloworld
- service2/helloworld</p>
<p>而方法和方法通过<code>RpcServiceMethod</code>来保存，而通过index来调用
<div class="highlight"><pre><span></span><code>::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
</code></pre></div></p>
<h4 id="rpc-unarycallstreamingcall"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#rpc-unarycallstreamingcall">rpc 声明UnaryCall&amp;StreamingCall</a></h4>
<p>非流调用也称为<code>UnaryCall</code>，指发送或接受的消息大小是固定的。
流调用称为<code>StreamingCall</code>，可以多次发送或者接收，所以消息大小并不固定。</p>
<p>StreamCall 可以多次调用，直到发送<code>WriteDone/Finish</code>，所以在接受的一端总是
<div class="highlight"><pre><span></span><code>while(read stream){}
</code></pre></div></p>
<p>grpc支持客户端流服务端非流、客户端非流、服务端流以及双向流，而普通的就是客户端和服务端都不流NORMAL_RPC(unary call)
- grpc::internal::RpcMethod::NORMAL_RPC
- grpc::internal::RpcMethod::RpcType::SERVER_STREAMING
- grpc::internal::RpcMethod::RpcType::CLIENT_STREAMING
- grpc::internal::RpcMethod::RpcType::BIDI_STREAMING</p>
<h4 id="pbhgrpcpbh"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#pbhgrpcpbh">认识pb.h和grpc.pb.h文件</a></h4>
<p>protoc 调用<code>grpc_cpp_plugin</code> 插件生成grpc.pb.{h,cc}文件，生成rpc方法的实现  </p>
<p>pb.{h,cc}则是定义了protobuf消息的序列化和反序列化方法</p>
<h5 id="_1"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_1">反射、序列化和反序列化的实现</a></h5>
<p>pb.h 实现grpc的请求参数和返回参数的特定语言的解析，还有pb的通用方法，
例如: <code>has_xx</code>(版本3里只有自定义类型才支持), <code>class XXX_CPP_API</code></p>
<p>生成的class都继承自<code>google::protobuf::Message</code>
<div class="highlight"><pre><span></span><code>class HelloRequest PROTOBUF_FINAL :
      public ::PROTOBUF_NAMESPACE_ID::Message

#define PROTOBUF_NAMESPACE &quot;google::protobuf&quot;
#define PROTOBUF_NAMESPACE_ID google::protobuf 
</code></pre></div>
而在<code>message</code>中有注释说明, 关键函数是<code>SerializeToString</code>和<code>ParseFromString</code>，还有个array版本<code>SerializeToArray</code>,<br />
还有一个反射函数<code>GetDescriptor()</code>用来动态获取指定槽位的数据
<div class="highlight"><pre><span></span><code>// Example usage:
  //
  // Say you have a message defined as:
  //
  //   message Foo {
  //     optional string text = 1;
  //     repeated int32 numbers = 2;
  //   }
  //
  // Then, if you used the protocol compiler to generate a class from the above
  // definition, you could use it like so:
  //
  //   std::string data;  // Will store a serialized version of the message.
  //
  //   {
  //     // Create a message and serialize it.
  //     Foo foo;
  //     foo.set_text(&quot;Hello World!&quot;);
  //     foo.add_numbers(1);
  //     foo.add_numbers(5);
  //     foo.add_numbers(42);
  //
  //     foo.SerializeToString(&amp;data);
  //   }
  //
  //   {
  //     // Parse the serialized message and check that it contains the
  //     // correct data.
  //     Foo foo;
  //     foo.ParseFromString(data);
  //
  //     assert(foo.text() == &quot;Hello World!&quot;);
  //     assert(foo.numbers_size() == 3);
  //     assert(foo.numbers(0) == 1);
  //     assert(foo.numbers(1) == 5);
  //     assert(foo.numbers(2) == 42);
  //   }
</code></pre></div></p>
<p>如下可以将Message转换为基本类型
<div class="highlight"><pre><span></span><code>int size = reqMsg.ByteSizeLong();
char* array = new char[size];
reqMsg.SerializeToArray(array, size);
</code></pre></div></p>
<div class="highlight"><pre><span></span><code>std::string bytes = reqMsg.SerializeAsString();
const char* array = bytes.data();
int size = bytes.size();
</code></pre></div>
<p>进一步看<code>protobuf::message</code>继承自<code>protobuf::message_lite</code>, 后者实现了<code>SerializeAsString</code>和<code>SerializeToArray</code>
<div class="highlight"><pre><span></span><code>inline uint8* SerializeToArrayImpl(const MessageLite&amp; msg, uint8* target,
                                     int size) {
    constexpr bool debug = false;
    if (debug) {
      // Force serialization to a stream with a block size of 1, which forces
      // all writes to the stream to cross buffers triggering all fallback paths
      // in the unittests when serializing to string / array.
      io::ArrayOutputStream stream(target, size, 1);
      uint8* ptr;
      io::EpsCopyOutputStream out(
          &amp;stream, io::CodedOutputStream::IsDefaultSerializationDeterministic(),
          &amp;ptr);
      ptr = msg._InternalSerialize(ptr, &amp;out);
      out.Trim(ptr);
      GOOGLE_DCHECK(!out.HadError() &amp;&amp; stream.ByteCount() == size);
      return target + size;
    } else {
      io::EpsCopyOutputStream out(
          target, size,
          io::CodedOutputStream::IsDefaultSerializationDeterministic());
实际调用-&gt;    auto res = msg._InternalSerialize(target, &amp;out);
      GOOGLE_DCHECK(target + size == res);
      return res;
    }
  }
</code></pre></div>
可见，其实序列化最终调用的是pb.h文件里定义的<code>_InternalSerialize</code>, 举例官方例子<code>HelloRequest</code>
<div class="highlight"><pre><span></span><code> ::PROTOBUF_NAMESPACE_ID::uint8* HelloRequest::_InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream*   stream) const {
    // @@protoc_insertion_point(serialize_to_array_start:helloworld.HelloRequest)
    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    (void) cached_has_bits;

    // string name = 1;
    if (this-&gt;name().size() &gt; 0) {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        this-&gt;_internal_name().data(), static_cast&lt;int&gt;(this-&gt;_internal_name().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        &quot;helloworld.HelloRequest.name&quot;);
      target = stream-&gt;WriteStringMaybeAliased(
          1, this-&gt;_internal_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToA  rray(
         _internal_metadata_.unknown_fields&lt;::PROTOBUF_NAMESPACE_ID::UnknownFieldSet&gt;(::PROTOB  UF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
    }
    // @@protoc_insertion_point(serialize_to_array_end:helloworld.HelloRequest)
    return target;
  }
</code></pre></div></p>
<h5 id="grpcpbrpc"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpcpbrpc">grpc.pb生成的代码实现rpc调用</a></h5>
<p>生成的框架代码用来继承实现Service和获取stub来发起rpc call。实际上这些代码并不是必须的<br />
在下面讲了如何使用几个工厂类来创建Stub，还有直接<code>new</code>出Service</p>
<div class="highlight"><pre><span></span><code>class XXXServer {
        // 客户端使用的桩
    class Stub
        // base 
    class Service
    // 各种版本的rpc包装，但都继承自base
        class WithAsyncMethod_XXX
        typedef WithAsyncMethod_XXX&lt;Service &gt; AsyncService;
    typedef ExperimentalWithCallbackMethod_XXX&lt;Service &gt; CallbackService;
    class WithGenericMethod_XXX
    class WithRawMethod_XXX
    typedef WithStreamedUnaryMethod_XXX&lt;Service &gt; StreamedUnaryService;
}
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_2">同步与异步</a></h3>
<p>grpc 的异步即为使用cq事件驱动（cq-based），使用tag标记事件。另外还有callback方式</p>
<h4 id="_3"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_3">对于客户端</a></h4>
<p>同步时，通过调用'::grpc::internal::BlockingUnaryCall'<br />
异步时，创建'ClientAsyncResponseReader'(非流), 然后通过调用'ClientAsyncResponseReader'的write和finish，并等待tag
当存在流时分别是
- ::grpc::ClientAsyncReader
- ::grpc::ClientAsyncWriter
- ::grpc::ClientAsyncReaderWriter</p>
<p>这些类型可用对应的工厂类来创建, 生成代码的stub也是这么用的
<div class="highlight"><pre><span></span><code>class ClientReaderFactory 
class ClientWriterFactory 
class ClientReaderWriterFactory 
</code></pre></div></p>
<h4 id="_4"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_4">对于服务端</a></h4>
<p>同步时，通过'AddMethod'来注册，生成代码会在父类构造时执行。注册后由grpc调用
<div class="highlight"><pre><span></span><code>Greeter::Service::Service() {
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Greeter_method_names[0],
        ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler&lt; Greeter::Service, ::helloworld::HelloRequest, ::helloworld::HelloReply&gt;(
            [](Greeter::Service* service,
               ::grpc_impl::ServerContext* ctx,
               const ::helloworld::HelloRequest* req,
               ::helloworld::HelloReply* resp) {
                 return service-&gt;SayHello(ctx, req, resp);
               }, this)));
  }
</code></pre></div></p>
<p>异步时，类似客户端
- grpc::ServerAsyncReaderWriter
- grpc::ServerAsyncReader
- grpc::ServerAsyncWriter</p>
<p>可见服务端是直接new出来的，异步时这些io操作对象也是直接new出来的, 在调用以下时传入
<div class="highlight"><pre><span></span><code>RequestAsyncBidiStreaming
RequestAsyncClientStreaming
RequestAsyncServerStreaming
</code></pre></div></p>
<h3 id="grpc-callback"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc-callback">grpc callback</a></h3>
<p>只在客户端使用，callback方式的请求可以传入一个lambda, 在请求完成时调用
<div class="highlight"><pre><span></span><code>    stub_-&gt;async()-&gt;SayHello(&amp;context, &amp;request, &amp;reply,
                             [&amp;mu, &amp;cv, &amp;done, &amp;status](Status s) {
                               status = std::move(s);
                               std::lock_guard&lt;std::mutex&gt; lock(mu);
                               done = true;
                               cv.notify_one();
                             });
</code></pre></div></p>
<p>新版本的grpc已经将实验性的标记去除，说明此方式成熟了
<div class="highlight"><pre><span></span><code>    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
</code></pre></div></p>
<h3 id="grpc_1"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_1">grpc异步流</a></h3>
<p>官方仓库的示例代码没有异步且流的, 在实际项目中用到异步流,使用大概方法
1. 手动创建writereader
2. 启动时，调用'grpc::Service::RequestAsyncBidiStreaming' 和 'grpc::Service::RequestAsyncClientStreaming' 以及'RequestAsyncServerStreaming', 向cq塞请求new_connection事件
3. 收到'new_connection'事件返回后，再调用read事件。</p>
<p>一共有5个类型
<div class="highlight"><pre><span></span><code>new_connection, read, write, finish, done
</code></pre></div>
我写了一个demo <a href="https://github.com/energygreek/grpcstreamhelloworld">grpcstreamhelloworld</a></p>
<h3 id="grpc_2"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_2">grpc 消息大小</a></h3>
<p>老版本的grpc中，发送端是支持无限大小的，但接受端只能是4M
<div class="highlight"><pre><span></span><code>#define GRPC_DEFAULT_MAX_SEND_MESSAGE_LENGTH -1
#define GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH (4 * 1024 * 1024)
</code></pre></div>
服务端代码
<div class="highlight"><pre><span></span><code>std::unique_ptr&lt;Server&gt; ServerBuilder::BuildAndStart() {
    if (max_receive_message_size_ &gt;= 0) {
      args.SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, max_receive_message_size_);
    }
</code></pre></div></p>
<p>但在新版grpc中变了</p>
<div class="highlight"><pre><span></span><code>  std::unique_ptr&lt;grpc::Server&gt; ServerBuilder::BuildAndStart() {
    grpc::ChannelArguments args;
    if (max_receive_message_size_ &gt;= -1) {
      args.SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, max_receive_message_size_);
    }
    if (max_send_message_size_ &gt;= -1) {
      args.SetInt(GRPC_ARG_MAX_SEND_MESSAGE_LENGTH, max_send_message_size_);
    }
</code></pre></div>
<h3 id="grpc_3"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_3">grpc 编译安装的问题</a></h3>
<p>https://github.com/grpc/grpc/issues/13841</p>
<h3 id="grpc_4"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_4">grpc异步存在问题</a></h3>
<p>因为异步服务端通过completionqueue来通知rpc执行结果和执行下次调用，通常使用多queue和多线程的方式提高处理效率
1. 通常情况是多queue, 即每个service对应一个queue, 而每个service又有多个rpc，线程去轮询这个complete_queue。这样导致高线程切换开销，而且complete_queue也占用大量内存
2. 多线程，queue可以用多个线程去轮询，但0.13版本可能出现bug</p>
<h3 id="grpc_5"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_5">grpc异步流存在的问题</a></h3>
<p>grpc区别与其他框架很大一个优势是支持异步流，即可以多次请求和多次回复。异步是基于cq的事件驱动，所以必须等待tag回调, 连续两次发送会异常。
而真正的请求一般在业务模块处理, 不知道tag的状态即不知道是否正在发送， 那么如何在cq回调外发送消息呢？ </p>
<p>办法是维护一个发送队列，消息先存队列里，等待cq回调时取出发送。 另外由于流同步需要显式发送结束标记(服务端调Stream::Finish, 客户端调用WriteDown和Finish), 
所以需要有一个特殊消息加以区分，通常用空指针，也可以设置结束标志。另外由于发送代码会同时被业务调用和cq回调，需要对发送代码加锁</p>
<h3 id="grpc_6"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#grpc_6">调试grpc</a></h3>
<p>通过设置环境变量，让grpc向控制台打印详细信息
<div class="highlight"><pre><span></span><code>export GRPC_VERBOSITY=DEBUG
bash-5.0# ./build/bin/hasync slave  stdin stdout @127.0.0.1:7615
D1026 08:27:44.142802149   24658 ev_posix.cc:174]            Using polling engine: epollex
D1026 08:27:44.143406685   24658 dns_resolver_ares.cc:490]   Using ares dns resolver
I1026 08:27:44.158115785   24658 server_builder.cc:332]      Synchronous server. Num CQs: 1, Min pollers: 1, Max Pollers: 2, CQ timeout (msec): 10000
</code></pre></div></p>
<h3 id="_5"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_5">项目实践</a></h3>
<p>项目使用客户端异步/同步，服务端全异步， 可以兼容四种传输方式</p>
<h3 id="_6"><a class="toclink" href="../../2021/04/13/grpc-%E5%AD%A6%E4%B9%A0/#_6">引用</a></h3>
<p>https://grpc.github.io/grpc/cpp/grpcpp_2impl_2codegen_2sync__stream_8h_source.html
https://grpc.github.io/grpc/cpp/grpcpp_2impl_2codegen_2byte__buffer_8h_source.html
https://grpc.github.io/grpc/cpp/call__op__set_8h_source.html</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-12 00:00:00+00:00">2021年4月12日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="segfault-in-dmesg"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/">segfault in dmesg</a></h2>
<p>偶尔看到自己或者客户的/var/log/message 日志出现segfault, 查询了一下相关信息
<div class="highlight"><pre><span></span><code>Apr  6 09:43:37 icm kernel: rhsm-icon[13402]: segfault at 12b0000 ip 0000003c89845c00 sp 00007ffce18396e0 error 4 in libglib-2.0.so.0.2800.8[3c89800000+115000]
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/#_1">解释</a></h3>
<ul>
<li>address (after the at) - the location in memory the code is trying to access (it's likely that 10 and 11 are offsets from a pointer we expect to be set to a valid value but which is instead pointing to 0)</li>
<li>ip - instruction pointer, ie. where the code which is trying to do this lives</li>
<li>sp - stack pointer</li>
<li>error - An error code for page faults; see below for what this means on x86.
<div class="highlight"><pre><span></span><code>/*
 * Page fault error code bits:
 *
 *   bit 0 ==    0: no page found       1: protection fault
 *   bit 1 ==    0: read access         1: write access
 *   bit 2 ==    0: kernel-mode access  1: user-mode access
 *   bit 3 ==                           1: use of reserved bit detected
 *   bit 4 ==                           1: fault was an instruction fetch
 */
</code></pre></div></li>
</ul>
<h3 id="message"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/#message">message日志</a></h3>
<p>使用<code>dmesg</code>打印ring buffer的内容，关于硬件和i/o的信息</p>
<h3 id="coredump"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/#coredump">coredump</a></h3>
<div class="highlight"><pre><span></span><code> A core file is an image of a process that has crashed It contains all process information pertinent to debugging: contents of hardware registers, process status, and process data. Gdb will allow you use this file to determine where your program crashed. 
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/#_2">复现</a></h3>
<div class="highlight"><pre><span></span><code>void foo(){
    int *p = 0;
    *p = 100;
}

int main(){
  foo();
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>[ 5902.293905] a.out[6085]: segfault at 0 ip 000055c0eddca129 sp 00007ffe65372110 error 6 in a.out[55c0eddca000+1000]
[ 5902.293916] Code: 00 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa e9 67 ff ff ff 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 64 00 00 00 90 5d c3 55 48 89 e5 b8 00 00 00 00 e8 d9 ff ff
</code></pre></div>
<div class="highlight"><pre><span></span><code>(gdb) info registers 
rax            0x0                 0
rbx            0x55c0eddca150      94287112741200
rcx            0x7faa085eb598      140368261592472
rdx            0x7ffe65372228      140730596532776
rsi            0x7ffe65372218      140730596532760
rdi            0x1                 1
rbp            0x7ffe65372110      0x7ffe65372110
rsp            0x7ffe65372110      0x7ffe65372110
r8             0x0                 0
r9             0x7faa08621070      140368261812336
r10            0x69682ac           110527148
r11            0x202               514
r12            0x55c0eddca020      94287112740896
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x55c0eddca129      0x55c0eddca129 &lt;foo+16&gt;
eflags         0x10246             [ PF ZF IF RF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
</code></pre></div>
<h3 id="addr2line"><a class="toclink" href="../../2021/04/12/segfault-in-dmesg/#addr2line">addr2line</a></h3>
<div class="highlight"><pre><span></span><code>addr2line -e yourSegfaultingProgram 00007f9bebcca90d
</code></pre></div>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-07 00:00:00+00:00">2021年4月7日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="cmake"><a class="toclink" href="../../2021/04/07/cmake-learning/">cmake 学习</a></h2>
<h3 id="add_custom_command"><a class="toclink" href="../../2021/04/07/cmake-learning/#add_custom_command">add_custom_command 用法</a></h3>
<p>用来定义自定义的方法, 而且有2套签名或者说触发规则 </p>
<h4 id="add_custom_target"><a class="toclink" href="../../2021/04/07/cmake-learning/#add_custom_target">与 <code>add_custom_target</code> 配合使用, 用于生成文件</a></h4>
<p>这种情况下，<code>add_custom_target</code> 续要在<code>add_custom_command</code>之后出现。
语法
<div class="highlight"><pre><span></span><code>add_custom_command(OUTPUT output1 [output2 ...]
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [MAIN_DEPENDENCY depend]
                   [DEPENDS [depends...]]
                   [BYPRODUCTS [files...]]
                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1
                                    [&lt;lang2&gt; depend2] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [DEPFILE depfile]
                   [JOB_POOL job_pool]
                   [VERBATIM] [APPEND] [USES_TERMINAL]
                   [COMMAND_EXPAND_LISTS])
</code></pre></div></p>
<p>类似make的语法规则
<div class="highlight"><pre><span></span><code>target:dependency
  command
</code></pre></div>
如果<code>dependency</code>不存在，就去找生成依赖本身的规则，没有也生成依赖的规则，那么make会停止。 </p>
<p>如下的例子
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="p">)</span>
<span class="w"> </span><span class="nb">project</span><span class="p">(</span><span class="s">test</span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="w"> </span><span class="s">main.c</span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_custom_command</span><span class="p">(</span><span class="s">OUTPUT</span><span class="w"> </span><span class="s">printout</span><span class="w"> </span>
<span class="w">                    </span><span class="s">COMMAND</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span><span class="w"> </span><span class="s">-E</span><span class="w"> </span><span class="s">echo</span><span class="w"> </span><span class="s">compile</span><span class="w"> </span><span class="s">finish</span>
<span class="w">                    </span><span class="s">VERBATIM</span>
<span class="w">                   </span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_custom_target</span><span class="p">(</span><span class="s">finish</span>
<span class="w">                   </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">printout</span>
<span class="w">                   </span><span class="p">)</span>
</code></pre></div></p>
<p>finish 依赖 printout, 而<code>add_custom_command</code>定义了printout的规则，printout即为下面的command执行的输出   </p>
<p>所以当生成finish目标的时候会触发上面的<code>add_custom_command</code> </p>
<p>其实这种情况下， 直接将<code>add_custome_command</code>的command写到<code>add_custome_target</code>中也是一样的效果</p>
<h4 id="command-line-tool"><a class="toclink" href="../../2021/04/07/cmake-learning/#command-line-tool">command-line-tool</a></h4>
<p>以上<code>add_cunstom_command</code>的两种用法都使用了<code>COMMAND ${CMAKE_COMMAND} -E</code>，这是使用了cmake内置的[命令]{https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool}    </p>
<h5 id="_1"><a class="toclink" href="../../2021/04/07/cmake-learning/#_1">运用</a></h5>
<p>例如生成protobuf的文件, 需要自定义方法</p>
<div class="highlight"><pre><span></span><code>    # output files:
    FOREACH (src ${proto_srcs})
        get_filename_component(base_name ${src} NAME_WE)
        get_filename_component(path_name ${src} PATH)

        set(src &quot;${base_name}.proto&quot;)
        set(cpp &quot;${base_name}.pb.cc&quot;)
        set(hpp &quot;${base_name}.pb.h&quot;)
        set(grpc_cpp &quot;${base_name}.grpc.pb.cc&quot;)
        set(grpc_hpp &quot;${base_name}.grpc.pb.h&quot;)

        # custom command.
        add_custom_command(
            OUTPUT ${proto_cpp_dist}/${cpp} ${proto_cpp_dist}/${hpp} ${proto_hpp_dist}/${hpp}
              ${proto_cpp_dist}/${grpc_cpp} ${proto_cpp_dist}/${grpc_hpp}
            COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
            ARGS ${OUTPUT_PATH}
              --grpc_out ${proto_cpp_dist}
              --plugin=protoc-gen-grpc=${GRPC_CPP_PLUGIN}
              ${src} 
            DEPENDS ${src}
            COMMAND ${CMAKE_COMMAND}
            ARGS -E copy_if_different ${proto_cpp_dist}/${hpp} ${proto_hpp_dist}/${hpp}
            COMMAND ${CMAKE_COMMAND}
            ARGS -E copy_if_different  ${proto_cpp_dist}/${grpc_hpp} ${proto_hpp_dist}/${grpc_hpp}
            WORKING_DIRECTORY ${path_name}
            COMMENT &quot;${PROTOBUF_PROTOC_EXECUTABLE} --cpp_out=${proto_cpp_dist} ${src}&quot;
            )

        LIST(APPEND output ${proto_cpp_dist}/${cpp})
    ENDFOREACH()
</code></pre></div>
<h4 id="_2"><a class="toclink" href="../../2021/04/07/cmake-learning/#_2">单独使用, 编译触发</a></h4>
<p>这个是当项目中有<code>add_library</code>或者<code>add_excutable</code>目标时可以在编译目标文件前/链接前/编译后触发
<div class="highlight"><pre><span></span><code><span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span><span class="w"> </span><span class="s">&lt;target&gt;</span>
<span class="w">                   </span><span class="s">PRE_BUILD</span><span class="w"> </span><span class="s">|</span><span class="w"> </span><span class="s">PRE_LINK</span><span class="w"> </span><span class="s">|</span><span class="w"> </span><span class="s">POST_BUILD</span>
<span class="w">                   </span><span class="s">COMMAND</span><span class="w"> </span><span class="s">command1</span><span class="w"> </span><span class="s">[ARGS]</span><span class="w"> </span><span class="s">[args1...]</span>
<span class="w">                   </span><span class="s">[COMMAND</span><span class="w"> </span><span class="s">command2</span><span class="w"> </span><span class="s">[ARGS]</span><span class="w"> </span><span class="s">[args2...]</span><span class="w"> </span><span class="s">...]</span>
<span class="w">                   </span><span class="s">[BYPRODUCTS</span><span class="w"> </span><span class="s">[files...]]</span>
<span class="w">                   </span><span class="s">[WORKING_DIRECTORY</span><span class="w"> </span><span class="s">dir]</span>
<span class="w">                   </span><span class="s">[COMMENT</span><span class="w"> </span><span class="s">comment]</span>
<span class="w">                   </span><span class="s">[VERBATIM]</span><span class="w"> </span><span class="s">[USES_TERMINAL]</span>
<span class="w">                   </span><span class="s">[COMMAND_EXPAND_LISTS]</span><span class="p">)</span>
</code></pre></div></p>
<h3 id="cmake_1"><a class="toclink" href="../../2021/04/07/cmake-learning/#cmake_1">cmake 逻辑表达式</a></h3>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-02 00:00:00+00:00">2021年4月2日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="cmake"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">cmake 使用第三方库</a></h2>
<p>在项目中链接第三方库的方法都是'target_include_directories' 和 'target_link_library', 前提引入第三方包. 而查找可以使用<code>find_package</code></p>
<h3 id="find_package"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#find_package">find_package找包</a></h3>
<p>find_package分为Module和Config两种方式</p>
<h4 id="module"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#module">Module方式</a></h4>
<p>find_package先在'/usr/share/cmake/Modules/Find/'下添加FindXXX.cmake文件，以及自定义路径(CMAKE_MODULE_PATH)下查找
然后在项目的CMakeList.txt中使用find_package(), 然后可以在链接的时候使用第三方库</p>
<div class="highlight"><pre><span></span><code><span class="nb">find_package</span><span class="p">()</span>
</code></pre></div>
<h4 id="config"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#config">Config模式</a></h4>
<p>当find_package找不到FindXXX.cmake文件，则会找
- <LibraryName>Config.cmake
- <lower-case-package-name>-config.cmake</p>
<p>如果第三方项目支持cmake, 那么先通过cmake编译和安装到环境或者docker环境，这时会在'/usr/lib/cmake/<LibraryName>/'下添加上述文件</p>
<h4 id="findxxxcmake"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#findxxxcmake">安装FindXXX.cmake文件</a></h4>
<p>当没有FindXXX.cmake时，可以使用安装包管理工具安装cmake-extra包, 可能找到需要的
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>pacman<span class="w"> </span>-S<span class="w"> </span>extra-cmake-modules
</code></pre></div></p>
<p>然后执行下面的命令，可以看到大量的'Find*.cmake'文件
<div class="highlight"><pre><span></span><code>ls /usr/share/cmake-3.20/Modules/
</code></pre></div></p>
<h4 id="findxxxcmake_1"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#findxxxcmake_1">自定义FindXXX.cmake文件</a></h4>
<p>如果上述方式都不行，那么需要自己写FindXXX.cmake，放到CMAKE_MODULE_PATH下<br />
例如在项目根目录创建文件夹<code>cmake_module</code>, 再使用<code>set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake_module)</code>来指定module的路径 <br />
最后在'cmake_module'下创建FindXXX.cmake结尾的文件，这个文件用来写找header和lib规则, 内容大致为</p>
<div class="highlight"><pre><span></span><code>find_path(Grpc_INCLUDE_DIR grpc++/grpc++.h)
mark_as_advanced(Grpc_INCLUDE_DIR)

find_library(Grpc++_LIBRARY NAMES grpc++ grpc++-1-dll)
mark_as_advanced(Grpc++_LIBRARY)
</code></pre></div>
<p>有这个文件之后，可以在项目的cmake中直接使用<code>find_package()</code></p>
<h3 id="_1"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#_1">源代码编译链接</a></h3>
<p>将第三方库源码放到项目指定目录如third</p>
<ol>
<li>放到third目录并可以使用<code>git submodule</code>管理</li>
<li>在thrid目录添加CMakeList.txt，在其中添加目标，已备在项目中链接
<div class="highlight"><pre><span></span><code># for gsl-lite target
add_library(gsl-lite INTERFACE)
target_include_directories(gsl-lite SYSTEM INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/gsl-lite/include)
</code></pre></div></li>
</ol>
<h3 id="fetchcontent"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#fetchcontent">FetchContent 自动源代码链接</a></h3>
<p>cmake3.11之后，可以使用这个办法来自动拉取网上的库，并可以直接在自己的项目中使用</p>
<div class="highlight"><pre><span></span><code><span class="c"># NOTE: This example uses cmake version 3.14 (FetchContent_MakeAvailable).</span>
<span class="c"># Since it streamlines the FetchContent process</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.14</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>

<span class="c"># In this example we are picking a specific tag.</span>
<span class="c"># You can also pick a specific commit, if you need to.</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span><span class="s">GSL</span>
<span class="w">    </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s2">&quot;https://github.com/microsoft/GSL&quot;</span>
<span class="w">    </span><span class="s">GIT_TAG</span><span class="w"> </span><span class="s2">&quot;v3.1.0&quot;</span>
<span class="p">)</span>

<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">GSL</span><span class="p">)</span>

<span class="c"># Now you can link against the GSL interface library</span>
<span class="nb">add_executable</span><span class="p">(</span><span class="s">foobar</span><span class="p">)</span>

<span class="c"># Link against the interface library (IE header only library)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">foobar</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">GSL</span><span class="p">)</span>
</code></pre></div>
<h3 id="cmakeopenssl"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#cmakeopenssl">cmake使用openssl存在问题</a></h3>
<p>因为openssl不用cmake,也就没有.cmake文件, 导致项目配置失败 
<div class="highlight"><pre><span></span><code> Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the
  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_LIBRARIES
  OPENSSL_INCLUDE_DIR)
</code></pre></div>
后面发现它是使用package_config方式
<div class="highlight"><pre><span></span><code>#/usr/local/lib/pkgconfig/openssl.pc
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

Name: OpenSSL
Description: Secure Sockets Layer and cryptography libraries and tools
Version: 1.1.1k
Requires: libssl libcrypto
</code></pre></div></p>
<p>这种情况除了通过cmake_module来解决之外，还可以通过指定pc文件的路径
<div class="highlight"><pre><span></span><code>cmake -DOPENSSL_ROOT_DIR=/usr/local/ 
</code></pre></div></p>
<h3 id="externalproject_add"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#externalproject_add">ExternalProject_Add</a></h3>
<p>这个不常用</p>
<h3 id="find_package-find_library"><a class="toclink" href="../../2021/04/02/cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#find_package-find_library">find_package 和 find_library 区别</a></h3>
<p>find_library 是cmake的底层方法，在find_path指定的目录下查找库文件 <br />
而find_package 使用了find_library的来找库文件，而且find_package在找到目标后，会定义一些变量，如下面的'Findlibproxy.cmake'文件头</p>
<div class="highlight"><pre><span></span><code># - Try to find libproxy
# Once done this will define
#
#  LIBPROXY_FOUND - system has libproxy
#  LIBPROXY_INCLUDE_DIR - the libproxy include directory
#  LIBPROXY_LIBRARIES - libproxy library
#
# Copyright (c) 2010, Dominique Leuenberger
#
# Redistribution and use is allowed according the license terms
# of libproxy, which this file is integrated part of.

# Find proxy.h and the corresponding library (libproxy.so)
FIND_PATH(LIBPROXY_INCLUDE_DIR proxy.h )
FIND_LIBRARY(LIBPROXY_LIBRARIES NAMES proxy )
</code></pre></div>
<p>当找到libproxy.so的时候，LIBPROXY_FOUND被设置为TRUE等</p>
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-31 00:00:00+00:00">2021年3月31日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="shell"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/">shell 笔记</a></h2>
<p>shell 是unix-like系统下，用户与系统交互的媒介，用来解析用户的输入并调用系统函数。 
而shell的实现有常见的bash,zsh,ksh等, 他们实现有很多差别，但bash最为通用</p>
<h3 id="bash"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/#bash">bash 模式拓展</a></h3>
<h3 id="bash_1"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/#bash_1">bash 字符串操作</a></h3>
<h3 id="bash_2"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/#bash_2">bash 数组操作</a></h3>
<h3 id="_1"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/#_1">环境变量</a></h3>
<p>测试程序定时获取和打印环境变量
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;TEST_ENV&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;env: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="p">);</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>通过bash来修改环境变量
<div class="highlight"><pre><span></span><code><span class="c1">#test.sh</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">TEST_ENV</span><span class="o">=</span>TEST
./a.out
<span class="nb">export</span><span class="w"> </span><span class="nv">TEST_ENV</span><span class="o">=</span>NNN
</code></pre></div></p>
<p>执行<code>test.sh</code>，c程序没有更新环境变量, 所以环境变量不会变化。</p>
<div class="highlight"><pre><span></span><code>env: TEST
env: TEST
env: TEST
</code></pre></div>
<div class="highlight"><pre><span></span><code>#include &lt;stdio.h&gt;

extern char **environ;

int main() {
  char **var;
  for (var = environ; *var != NULL; ++var) {
    printf(&quot;%s\n&quot;, *var);
  }
}
</code></pre></div>
<h3 id="set-unset"><a class="toclink" href="../../2021/03/31/shell-%E7%AC%94%E8%AE%B0/#set-unset">set unset</a></h3>
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <a class="md-pagination__link" href="../..">1</a> <span class="md-pagination__dots">..</span> <a class="md-pagination__link" href="../6/">6</a> <a class="md-pagination__link" href="../7/">7</a> <span class="md-pagination__current">8</span> <a class="md-pagination__link" href="../9/">9</a> <a class="md-pagination__link" href="../10/">10</a> <span class="md-pagination__dots">..</span> <a class="md-pagination__link" href="../13/">13</a>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
        
          
          <a href="../../tags/" class="md-footer__link md-footer__link--next" aria-label="下一页: Tags">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                Tags
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.tabs.sticky", "navigation.instant", "navigation.instant.progress", "navigation.footer", "toc.follow", "content.code.copy", "content.action.view"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../js/tex-mml-chtml.js"></script>
      
        <script src="../../js/mermaid.min.js"></script>
      
    
  </body>
</html>