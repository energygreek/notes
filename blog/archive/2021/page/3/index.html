
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://energygreek.github.io/notes/blog/archive/2021/page/3/">
      
      
        <link rel="prev" href="../../../2022/">
      
      
        <link rel="next" href="../../../2020/">
      
      
        
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS 订阅" href="../../../../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="已更新内容的 RSS 订阅" href="../../../../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>2021 - Some Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#2021" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../../../.." title="Some Notes" class="md-header__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../../../../assets/bird.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Some Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2021
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="gray" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../../../" class="md-tabs__link">
          
  
  
    
  
  Blog

        </a>
      </li>
    
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../../tags/" class="md-tabs__link">
        
  
  
    
  
  Tag

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="Some Notes" class="md-nav__button md-logo" aria-label="Some Notes" data-md-component="logo">
      
  <img src="../../../../../assets/bird.png" alt="logo">

    </a>
    Some Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    
  
    Blog
  

    
  </span>
  
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1" id="__nav_1_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Blog
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1_2" checked>
        
          
          <label class="md-nav__link" for="__nav_1_2" id="__nav_1_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    归档
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_1_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    归档
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2025
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2024
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2023
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2022
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
      
    
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    2021
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="../../" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    2021
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#grpc-callback-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        grpc callback api
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rpc" class="md-nav__link">
    <span class="md-ellipsis">
      
        rpc
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#segfault-in-dmesg" class="md-nav__link">
    <span class="md-ellipsis">
      
        segfault in dmesg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      
        cmake 学习
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      
        cmake 使用第三方库
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      
        shell 笔记
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#urxvt" class="md-nav__link">
    <span class="md-ellipsis">
      
        urxvt配置
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static-compile-warning-if-namespace-resolving-function-used" class="md-nav__link">
    <span class="md-ellipsis">
      
        static compile warning if namespace resolving function used
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        智能指针
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avahi" class="md-nav__link">
    <span class="md-ellipsis">
      
        使用avahi将传统打印机支持无线打印
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2020/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2020
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../2019/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2019
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tag
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#grpc-callback-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        grpc callback api
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rpc" class="md-nav__link">
    <span class="md-ellipsis">
      
        rpc
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#segfault-in-dmesg" class="md-nav__link">
    <span class="md-ellipsis">
      
        segfault in dmesg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      
        cmake 学习
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cmake" class="md-nav__link">
    <span class="md-ellipsis">
      
        cmake 使用第三方库
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      
        shell 笔记
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#urxvt" class="md-nav__link">
    <span class="md-ellipsis">
      
        urxvt配置
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static-compile-warning-if-namespace-resolving-function-used" class="md-nav__link">
    <span class="md-ellipsis">
      
        static compile warning if namespace resolving function used
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        智能指针
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avahi" class="md-nav__link">
    <span class="md-ellipsis">
      
        使用avahi将传统打印机支持无线打印
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content" data-md-component="content">
    <div class="md-content__inner">
      <header class="md-typeset">
        <h1 id="2021">2021<a class="headerlink" href="#2021" title="Permanent link">&para;</a></h1>
      </header>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-13 00:00:00+00:00">2021年4月13日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 13 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="grpc-callback-api"><a class="toclink" href="../../../../grpc-callback-api/">grpc callback api</a></h2>
<h3 id="c-callback-based-asynchronous-api"><a class="toclink" href="../../../../grpc-callback-api/#c-callback-based-asynchronous-api">C++ callback-based asynchronous API</a></h3>
<ul>
<li>Author(s): vjpai, sheenaqotj, yang-g, zhouyihaiding</li>
<li>Approver: markdroth</li>
<li>Status: Proposed</li>
<li>Implemented in: https://github.com/grpc/grpc/projects/12</li>
<li>Last updated: March 22, 2021</li>
<li>Discussion at https://groups.google.com/g/grpc-io/c/rXLdWWiosWg</li>
</ul>
<h3 id="abstract"><a class="toclink" href="../../../../grpc-callback-api/#abstract">Abstract</a></h3>
<p>Provide an asynchronous gRPC API for C++ in which the completion of RPC actions in the library will result in callbacks to user code,</p>
<h3 id="background"><a class="toclink" href="../../../../grpc-callback-api/#background">Background</a></h3>
<p>Since its initial release, gRPC has provided two C++ APIs:</p>
<ul>
<li>Synchronous API</li>
<li>All RPC actions (such as unary calls, streaming reads, streaming writes, etc.) block for completion</li>
<li>Library provides a thread-pool so that each incoming server RPC executes its method handler in its own thread</li>
<li>Completion-queue-based (aka CQ-based) asynchronous API</li>
<li>Application associates each RPC action that it initiates with a tag</li>
<li>The library performs each RPC action</li>
<li>The library posts the tag of a completed action onto a completion queue</li>
<li>The application must poll the completion queue to determine which asynchronously-initiated actions have completed</li>
<li>The application must provide and manage its own threads</li>
<li>Server RPCs don't have any library-invoked method handler; instead the application is responsible for executing the actions for an RPC once it is notified of an incoming RPC via the completion queue</li>
</ul>
<p>The goal of the synchronous version is to be easy to program. However, this comes at the cost of high thread-switching overhead and high thread storage for systems with many concurrent RPCs. On the other hand, the asynchronous API allows the application full control over its threading and thus can scale further. The biggest problem with the asynchronous API is that it is just difficult to use. Server RPCs must be explicitly requested, RPC polling must be explicitly controlled by the application, lifetime management is complicated, etc. These have proved sufficiently difficult that the full features of the asynchronous API are basically never used by applications. Even if one can use the async API correctly, it also presents challenges in deciding how many completion queues to use and how many threads to use for polling them, as one can either optimize for reducing thread hops, avoiding stranding, reducing CQ contention, or improving locality. These goals are often in conflict and require substantial tuning.</p>
<h4 id="related-proposals"><a class="toclink" href="../../../../grpc-callback-api/#related-proposals">Related proposals</a></h4>
<ul>
<li>The C++ callback API has an implementation that is built on top of a new <a href="https://github.com/grpc/proposal/pull/181">callback completion queue in core</a>. There is also another implementation, discussed <a href="../../../../grpc-callback-api/#implementation">below</a>.</li>
<li>The API structure has substantial similarities to the gRPC-Node and gRPC-Java APIs.</li>
</ul>
<h3 id="proposal"><a class="toclink" href="../../../../grpc-callback-api/#proposal">Proposal</a></h3>
<p>The callback API is designed to have the performance and thread scalability of an asynchronous API without the burdensome programming model of the completion-queue-based model. In particular, the following are fundamental guiding principles of the API:</p>
<ul>
<li>Library directly calls user-specified code at the completion of RPC actions. This user code is run from the library's own threads, so it is very important that it must not wait for completion of any blocking operations (e.g., condition variable waits, invoking synchronous RPCs, blocking file I/O).</li>
<li>No explicit polling required for notification of completion of RPC actions.</li>
<li>In practice, these requirements mean that there must be a library-controlled poller for monitoring such actions. This is discussed in more detail in the <a href="../../../../grpc-callback-api/#implementation">Implementation</a> section below.</li>
<li>As in the synchronous API, server RPCs have an application-defined method handler function as part of their service definition. The library invokes this method handler when a new server RPC starts.</li>
<li>Like the synchronous API and unlike the completion-queue-based asynchronous API, there is no need for the application to "request" new server RPCs. Server RPC context structures will be allocated and have their resources allocated as and when RPCs arrive at the server.</li>
</ul>
<h4 id="reactor-model"><a class="toclink" href="../../../../grpc-callback-api/#reactor-model">Reactor model</a></h4>
<p>The most general form of the callback API is built around a <em>reactor</em> model. Each type of RPC has a reactor base class provided by the library. These types are:</p>
<ul>
<li><code>ClientUnaryReactor</code> and <code>ServerUnaryReactor</code> for unary RPCs</li>
<li><code>ClientBidiReactor</code> and <code>ServerBidiReactor</code> for bidi-streaming RPCs</li>
<li><code>ClientReadReactor</code> and <code>ServerWriteReactor</code> for server-streaming RPCs</li>
<li><code>ClientWriteReactor</code> and <code>ServerReadReactor</code> for client-streaming RPCs</li>
</ul>
<p>Client RPC invocations from a stub provide a reactor pointer as one of their arguments, and the method handler of a server RPC must return a reactor pointer.</p>
<p>These base classes provide three types of methods:</p>
<ol>
<li>Operation-initiation methods: start an asynchronous activity in the RPC. These are methods provided by the class and are not virtual. These are invoked by the application logic. All of these have a <code>void</code> return type. The <code>ReadMessageType</code> below is the request type for a server RPC and the response type for a client RPC; the <code>WriteMessageType</code> is the response type for a server RPC or the request type for a client RPC.</li>
<li><code>void StartCall()</code>: (<em>Client only</em>) Initiates the operations of a call from the client, including sending any client-side initial metadata associated with the RPC. Must be called exactly once. No reads or writes will actually be started until this is called (i.e., any previous calls to <code>StartRead</code>, <code>StartWrite</code>, or <code>StartWritesDone</code> will be queued until <code>StartCall</code> is invoked). This operation is not needed at the server side since streaming operations at the server are released from backlog automatically by the library as soon as the application returns a reactor from the method handler, and because there is a separate method just for sending initial metadata.</li>
<li><code>void StartSendInitialMetadata()</code>: (<em>Server only</em>) Sends server-side initial metadata. To be used in cases where initial metadata should be sent without sending a message. Optional; if not called, initial metadata will be sent when <code>StartWrite</code> or <code>Finish</code> is called. May not be invoked more than once or after <code>StartWrite</code> or <code>Finish</code> has been called. This does not exist at the client because sending initial metadata is part of <code>StartCall</code>.</li>
<li><code>void StartRead(ReadMessageType*)</code>: Starts a read of a message into the object pointed to by the argument. <code>OnReadDone</code> will be invoked when the read is complete. Only one read may be outstanding at any given time for an RPC (though a read and a write can be concurrent with each other). If this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void StartWrite(const WriteMessageType*)</code>: Starts a write of the object pointed to by the argument. <code>OnWriteDone</code> will be invoked when the write is complete. Only one write may be outstanding at any given time for an RPC (though a read and a write can be concurrent with each other).  As with <code>StartRead</code>, if this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void StartWritesDone()</code>: (<em>Client only</em>) For client RPCs to indicate that there are no more writes coming in this stream.  <code>OnWritesDoneDone</code> will be invoked when this operation is complete. This causes future read operations on the server RPC to indicate that there is no more data available. Highly recommended but technically optional; may not be called more than once per call.  As with <code>StartRead</code> and <code>StartWrite</code>, if this operation is invoked by a client before calling <code>StartCall</code> or by a server before returning from the method handler, it will be queued until one of those events happens and will not actually trigger any activity or reactions until it is thereby released from the queue.</li>
<li><code>void Finish(Status)</code>: (<em>Server only</em>) Sends completion status to the client, asynchronously. Must be called exactly once for all server RPCs, even for those that have already been cancelled. No further operation-initiation methods may be invoked after <code>Finish</code>.</li>
<li>Operation-completion reaction methods: notification of completion of asynchronous RPC activity. These are all virtual methods that default to an empty function (i.e., <code>{}</code>) but may be overridden by the application's reactor definition. These are invoked by the library. All of these have a <code>void</code> return type. Most take a <code>bool ok</code> argument to indicate whether the operation completed "normally," as explained below.</li>
<li><code>void OnReadInitialMetadataDone(bool ok)</code>: (<em>Client only</em>) Invoked by the library to notify that the server has sent an initial metadata response to a client RPC. If <code>ok</code> is true, then the RPC received initial metadata normally. If it is false, there is no initial metadata either because the call has failed or because the call received a trailers-only response (which means that there was no actual message and that any information normally sent in initial metadata has been dispatched instead to trailing metadata, which is allowed in the gRPC HTTP/2 transport protocol). This reaction is automatically invoked by the library for RPCs of all varieties; it is uncommonly used as an application-defined reaction however.</li>
<li><code>void OnReadDone(bool ok)</code>: Invoked by the library in response to a <code>StartRead</code> operation. The <code>ok</code> argument indicates whether a message was read as expected. A false <code>ok</code> could mean a failed RPC (e.g., cancellation) or a case where no data is possible because the other side has already ended its writes (e.g., seen at the server-side after the client has called <code>StartWritesDone</code>).</li>
<li><code>void OnWriteDone(bool ok)</code>: Invoked by the library in response to a <code>StartWrite</code> operation. The <code>ok</code> argument that indicates whether the write was successfully sent; a false value indicates an RPC failure.</li>
<li><code>void OnWritesDoneDone(bool ok)</code>: (<em>Client only</em>) Invoked by the library in response to a <code>StartWritesDone</code> operation. The bool <code>ok</code> argument that indicates whether the writes-done operation was successfully completed; a false value indicates an RPC failure.</li>
<li><code>void OnCancel()</code>: (<em>Server only</em>) Invoked by the library if an RPC is canceled before it has a chance to successfully send status to the client side. The reaction may be used for any cleanup associated with cancellation or to guide the behavior of other parts of the system (e.g., by setting a flag in the service logic associated with this RPC to stop further processing since the RPC won't be able to send outbound data anyway). Note that servers must call <code>Finish</code> even for RPCs that have already been canceled as this is required to cleanup all their library state and move them to a state that allows for calling <code>OnDone</code>.</li>
<li><code>void OnDone(const Status&amp;)</code> at the client, <code>void OnDone()</code> at the server: Invoked by the library when all outstanding and required RPC operations are completed for a given RPC. For the client-side, it additionally provides the status of the RPC (either as sent by the server with its <code>Finish</code> call or as provided by the library to indicate a failure), in which case the signature is <code>void OnDone(const Status&amp;)</code>. The server version has no argument, and thus has a signature of <code>void OnDone()</code>. Should be used for any application-level RPC-specific cleanup.</li>
<li><em>Thread safety</em>: the above calls may take place concurrently, except that <code>OnDone</code> will always take place after all other reactions. No further RPC operations are permitted to be issued after <code>OnDone</code> is invoked.</li>
<li><strong>IMPORTANT USAGE NOTE</strong> : code in any reaction must not block for an arbitrary amount of time since reactions are executed on a finite-sized, library-controlled threadpool. If any long-term blocking operations (like sleeps, file I/O, synchronous RPCs, or waiting on a condition variable) must be invoked as part of the application logic, then it is important to push that outside the reaction so that the reaction can complete in a timely fashion. One way of doing this is to push that code to a separate application-controlled thread.</li>
<li>RPC completion-prevention methods. These are methods provided by the class and are not virtual. They are only present at the client-side because the completion of a server RPC is clearly requested when the application invokes <code>Finish</code>. These methods are invoked by the application logic. All of these have a <code>void</code> return type.</li>
<li><code>void AddHold()</code>: (<em>Client only</em>) This prevents the RPC from being considered complete (ready for <code>OnDone</code>) until each <code>AddHold</code> on an RPC's reactor is matched to a corresponding <code>RemoveHold</code>. An application uses this operation before it performs any  <em>extra-reaction flows</em>, which refers to streaming operations initiated from outside a reaction method. Note that an RPC cannot complete before <code>StartCall</code>, so holds are not needed for any extra-reaction flows that take place before <code>StartCall</code>. As long as there are any holds present on an RPC, though, it may not have <code>OnDone</code> called on it, even if it has already received server status and has no other operations outstanding. May be called 0 or more times on any client RPC.</li>
<li><code>void AddMultipleHolds(int holds)</code>: (<em>Client only</em>) Shorthand for <code>holds</code> invocations of <code>AddHold</code> .</li>
<li><code>void RemoveHold()</code>: (<em>Client only</em>) Removes a hold reference on this client RPC. Must be called exactly as many times as <code>AddHold</code> was called on the RPC, and may not be called more times than <code>AddHold</code> has been called so far for any RPC. Once all holds have been removed, the server has provided status, and all outstanding or required operations have completed for an RPC, the library will invoke <code>OnDone</code> for that RPC.</li>
</ol>
<p>Examples are provided in <a href="https://github.com/grpc/grpc/pull/25728">the PR to de-experimentalize the callback API</a>.</p>
<h4 id="unary-rpc-shortcuts"><a class="toclink" href="../../../../grpc-callback-api/#unary-rpc-shortcuts">Unary RPC shortcuts</a></h4>
<p>As a shortcut, client-side unary RPCs <em>may</em> bypass the reactor model by directly providing a <code>std::function</code> for the library to call at completion rather than a reactor object pointer. This is passed as the final argument to the stub call, just as the reactor would be in the more general case. This is semantically equivalent to a reactor in which the <code>OnDone</code> function simply invokes the specified function (but can be implemented in a slightly faster way since such an RPC will definitely not wait separately for initial metadata from the server) and all other reactions are left empty. In practice, this is the common and recommended model for client-side unary RPCs, unless they have a specific need to wait for initial metadata before getting their full response message. As in the reactor model, the function provided as a callback may not include operations that block for an arbitrary amount of time.</p>
<p>Server-side unary RPCs have the option of returning a library-provided default reactor when their method handler is invoked. This is provided by calling <a href="../../../../grpc-callback-api/#servercontext-extensions"><code>DefaultReactor</code> on the <code>CallbackServerContext</code></a>. This default reactor provides a <code>Finish</code> method, but does not provide a user callback for <code>OnCancel</code> and <code>OnDone</code>. In practice, this is the common and recommended model for most server-side unary RPCs unless they specifically need to react to an <code>OnCancel</code> callback or do cleanup work after the RPC fully completes.</p>
<h4 id="servercontext-extensions"><a class="toclink" href="../../../../grpc-callback-api/#servercontext-extensions">ServerContext extensions</a></h4>
<p><code>ServerContext</code> is now made a derived class of <code>ServerContextBase</code>. There is a new derived class of <code>ServerContextBase</code> called <code>CallbackServerContext</code> which provides a few additional functions:</p>
<ul>
<li><code>ServerUnaryReactor* DefaultReactor()</code> may be used by a method handler to return a default reactor from a unary RPC.</li>
<li><code>RpcAllocatorState* GetRpcAllocatorState</code>: see advanced topics section</li>
</ul>
<p>Additionally, the <code>AsyncNotifyWhenDone</code> function is not present in the <code>CallbackServerContext</code>.</p>
<p>All method handler functions for the callback API take a <code>CallbackServerContext*</code> as their first argument. <code>ServerContext</code> (used for the sync and CQ-based async APIs) and <code>CallbackServerContext</code> (used for the callback API) actually use the same underlying structure and thus their object pointers are meaningfully convertible to each other via a <code>static_cast</code> to <code>ServerContextBase*</code>. We recommend that any helper functions that need to work across API variants should use a <code>ServerContextBase</code> pointer or reference as their argument rather than a <code>ServerContext</code> or <code>CallbackServerContext</code> pointer or reference. For example, <code>ClientContext::FromServerContext</code> now uses a <code>ServerContextBase*</code> as its argument; this is not a breaking API change since the argument is now a parent class of the previous argument's class.</p>
<h4 id="advanced-topics"><a class="toclink" href="../../../../grpc-callback-api/#advanced-topics">Advanced topics</a></h4>
<h5 id="application-managed-server-memory-allocation"><a class="toclink" href="../../../../grpc-callback-api/#application-managed-server-memory-allocation">Application-managed server memory allocation</a></h5>
<p>Callback services must allocate an object for the <code>CallbackServerContext</code> and for the request and response objects of a unary call.  Applications can supply a per-method custom memory allocator for gRPC server to use to allocate and deallocate the request and response messages, as well as a per-server custom memory allocator for context objects. These can be used for purposes like early or delayed release, freelist-based allocation, or arena-based allocation. For each unary RPC method, there is a generated method in the server called <code>SetMessageAllocatorFor_*MethodName*</code> . For each server, there is a method called <code>SetContextAllocator</code>. Each of these has numerous classes involved, and the best examples for how to use these features lives in the gRPC tests directory.</p>
<ul>
<li><a href="https://github.com/grpc/grpc/blob/master/test/cpp/end2end/message_allocator_end2end_test.cc">Message allocator usage example</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/test/cpp/end2end/context_allocator_end2end_test.cc">Context allocator usage example</a></li>
</ul>
<h5 id="generic-non-code-generated-services"><a class="toclink" href="../../../../grpc-callback-api/#generic-non-code-generated-services">Generic (non-code-generated) services</a></h5>
<p><code>RegisterCallbackGenericService</code> is a new method of <code>ServerBuilder</code> to allow for processing of generic (unparsed) RPCs. This is similar to the pre-existing <code>RegisterAsyncGenericService</code> but uses the callback API and reactors rather than the CQ-based async API. It is expected to be used primarily for generic gRPC proxies where the exact serialization format or list of supported methods is unknown.</p>
<h5 id="per-method-specification"><a class="toclink" href="../../../../grpc-callback-api/#per-method-specification">Per-method specification</a></h5>
<p>Just as with async services, callback services may also be specified on a method-by-method basis (using the syntax <code>WithCallbackMethod_*MethodName*</code>), with any unlisted methods being treated as sync RPCs. The shorthand <code>CallbackService</code> declares every method as being processed by the callback API. For example:</p>
<ul>
<li><code>Foo::Service</code> -- purely synchronous service</li>
<li><code>Foo::CallbackService</code> -- purely callback service</li>
<li><code>Foo::WithCallbackMethod_Bar&lt;Service&gt;</code> -- synchronous service except for callback method <code>Bar</code></li>
<li><code>Foo::WithCallbackMethod_Bar&lt;WithCallbackMethod_Baz&lt;Service&gt;&gt;</code> -- synchronous service except for callback methods <code>Bar</code> and <code>Baz</code></li>
</ul>
<h3 id="rationale"><a class="toclink" href="../../../../grpc-callback-api/#rationale">Rationale</a></h3>
<p>Besides the content described in the background section, the rationale also includes early and consistent user demand for this feature as well as the fact that many users were simply spinning up a callback model on top of gRPC's completion queue-based asynchronous model.</p>
<h3 id="implementation"><a class="toclink" href="../../../../grpc-callback-api/#implementation">Implementation</a></h3>
<p>There is more than one mechanism available for implementing the background polling required by the C++ callback API. One has been implemented <a href="https://github.com/grpc/grpc/pull/25169">on top of the C++ completion queue API</a>. In this approach, the callback API uses a number of library-owned threads to call <code>Next</code> on an async CQ that is owned by the internal implementation. Currently, the thread count is automatically selected by the library with no user input and is set to half the system's core count, but no less than 2 and no more than 16. This selection is subject to change in the future based on our team's ongoing performance analysis and tuning efforts. Despite being built on the CQ-based async API, the developer using the callback API does not need to consider any of the CQ details (e.g., shutdown, polling, or even the existence of a CQ).</p>
<p>It is the gRPC team's intention that that implementation is only a temporary solution. A new structure called an <code>EventEngine</code> is being developed to provide the background threads needed for polling, and this sytem is also intended to provide a direct API for application use. This event engine would also allow the direct use of the <a href="https://github.com/grpc/proposal/blob/master/L68-core-callback-api.md">core callback API</a> that is currently only used by the Python async implementation. If this solution is adopted, there will be a new gRFC for it. This new implementation will not change the callback API at all but rather will only affect its performance. The C++ code for the callback API already has <code>if</code> branches in place to support the use of a poller that directly supplies the background threads, so the callback API will naturally layer on top of the <code>EventEngine</code> without further development effort.</p>
<h3 id="open-issues-if-applicable"><a class="toclink" href="../../../../grpc-callback-api/#open-issues-if-applicable">Open issues (if applicable)</a></h3>
<p>N/A. The gRPC C++ callback API has been used internally at Google for two years now, and the code and API have evolved substantially during that period.</p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-13 00:00:00+00:00">2021年4月13日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 4 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="rpc"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/">rpc</a></h2>
<p>rpc 意为<code>远程过程调用</code>, http, grpc 广义上讲都是rpc。
而且还有个项目叫<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>, 可以将grpc通过http的方式暴露。</p>
<h2 id="grpc"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc">grpc</a></h2>
<p>grpc 是rpc的一种实现，由google开源，其他还有thrift, sogorpc 等等。 并且grpc使用的http/2协议</p>
<h3 id="http11-http2"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#http11-http2">http/1.1 与 http/2 的区别</a></h3>
<ul>
<li>2使用二进制，而1.1使用文本，提高效率</li>
<li>2将相同的tcp连接合并为一个请求，提高性能,而1.1则为每个请求创建tcp连接</li>
<li>2的客户端使用流，这样可以多次请求</li>
<li>2含有trailers，也就是尾部消息，可以用来发送body的checksume等, 当然也可以直接放到body里
...</li>
</ul>
<p>而1.1中也已经实现服务端到客户端的流,使用'Transfer-Encoding=chunked'来替代'Content-Length'，详见<a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2">rfc</a>
<div class="highlight"><pre><span></span><code> A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.
</code></pre></div></p>
<h3 id="proto"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#proto">认识proto文件</a></h3>
<h4 id="proto-serviceservice"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#proto-serviceservice">proto 文件中多个service和单个service 区别</a></h4>
<p>在同一个service里的方法会codegen到同一个类，但这个类比较鸡肋。
由于RPC调用是RESTful的，所以多次调用或者多个rpc方法无法通过同一个service来共享数据，这需要使用者借助其他办法来解决。</p>
<p>service 还可以用以隔离相同名称的rpc， 如 
- service1/helloworld
- service2/helloworld</p>
<p>而方法和方法通过<code>RpcServiceMethod</code>来保存，而通过index来调用
<div class="highlight"><pre><span></span><code>::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
</code></pre></div></p>
<h4 id="rpc-unarycallstreamingcall"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#rpc-unarycallstreamingcall">rpc 声明UnaryCall&amp;StreamingCall</a></h4>
<p>非流调用也称为<code>UnaryCall</code>，指发送或接受的消息大小是固定的。
流调用称为<code>StreamingCall</code>，可以多次发送或者接收，所以消息大小并不固定。</p>
<p>StreamCall 可以多次调用，直到发送<code>WriteDone/Finish</code>，所以在接受的一端总是
<div class="highlight"><pre><span></span><code>while(read stream){}
</code></pre></div></p>
<p>grpc支持客户端流服务端非流、客户端非流、服务端流以及双向流，而普通的就是客户端和服务端都不流NORMAL_RPC(unary call)
- grpc::internal::RpcMethod::NORMAL_RPC
- grpc::internal::RpcMethod::RpcType::SERVER_STREAMING
- grpc::internal::RpcMethod::RpcType::CLIENT_STREAMING
- grpc::internal::RpcMethod::RpcType::BIDI_STREAMING</p>
<h4 id="pbhgrpcpbh"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#pbhgrpcpbh">认识pb.h和grpc.pb.h文件</a></h4>
<p>protoc 调用<code>grpc_cpp_plugin</code> 插件生成grpc.pb.{h,cc}文件，生成rpc方法的实现  </p>
<p>pb.{h,cc}则是定义了protobuf消息的序列化和反序列化方法</p>
<h5 id="_1"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_1">反射、序列化和反序列化的实现</a></h5>
<p>pb.h 实现grpc的请求参数和返回参数的特定语言的解析，还有pb的通用方法，
例如: <code>has_xx</code>(版本3里只有自定义类型才支持), <code>class XXX_CPP_API</code></p>
<p>生成的class都继承自<code>google::protobuf::Message</code>
<div class="highlight"><pre><span></span><code>class HelloRequest PROTOBUF_FINAL :
      public ::PROTOBUF_NAMESPACE_ID::Message

#define PROTOBUF_NAMESPACE &quot;google::protobuf&quot;
#define PROTOBUF_NAMESPACE_ID google::protobuf 
</code></pre></div>
而在<code>message</code>中有注释说明, 关键函数是<code>SerializeToString</code>和<code>ParseFromString</code>，还有个array版本<code>SerializeToArray</code>,<br />
还有一个反射函数<code>GetDescriptor()</code>用来动态获取指定槽位的数据
<div class="highlight"><pre><span></span><code>// Example usage:
  //
  // Say you have a message defined as:
  //
  //   message Foo {
  //     optional string text = 1;
  //     repeated int32 numbers = 2;
  //   }
  //
  // Then, if you used the protocol compiler to generate a class from the above
  // definition, you could use it like so:
  //
  //   std::string data;  // Will store a serialized version of the message.
  //
  //   {
  //     // Create a message and serialize it.
  //     Foo foo;
  //     foo.set_text(&quot;Hello World!&quot;);
  //     foo.add_numbers(1);
  //     foo.add_numbers(5);
  //     foo.add_numbers(42);
  //
  //     foo.SerializeToString(&amp;data);
  //   }
  //
  //   {
  //     // Parse the serialized message and check that it contains the
  //     // correct data.
  //     Foo foo;
  //     foo.ParseFromString(data);
  //
  //     assert(foo.text() == &quot;Hello World!&quot;);
  //     assert(foo.numbers_size() == 3);
  //     assert(foo.numbers(0) == 1);
  //     assert(foo.numbers(1) == 5);
  //     assert(foo.numbers(2) == 42);
  //   }
</code></pre></div></p>
<p>如下可以将Message转换为基本类型
<div class="highlight"><pre><span></span><code>int size = reqMsg.ByteSizeLong();
char* array = new char[size];
reqMsg.SerializeToArray(array, size);
</code></pre></div></p>
<div class="highlight"><pre><span></span><code>std::string bytes = reqMsg.SerializeAsString();
const char* array = bytes.data();
int size = bytes.size();
</code></pre></div>
<p>进一步看<code>protobuf::message</code>继承自<code>protobuf::message_lite</code>, 后者实现了<code>SerializeAsString</code>和<code>SerializeToArray</code>
<div class="highlight"><pre><span></span><code>inline uint8* SerializeToArrayImpl(const MessageLite&amp; msg, uint8* target,
                                     int size) {
    constexpr bool debug = false;
    if (debug) {
      // Force serialization to a stream with a block size of 1, which forces
      // all writes to the stream to cross buffers triggering all fallback paths
      // in the unittests when serializing to string / array.
      io::ArrayOutputStream stream(target, size, 1);
      uint8* ptr;
      io::EpsCopyOutputStream out(
          &amp;stream, io::CodedOutputStream::IsDefaultSerializationDeterministic(),
          &amp;ptr);
      ptr = msg._InternalSerialize(ptr, &amp;out);
      out.Trim(ptr);
      GOOGLE_DCHECK(!out.HadError() &amp;&amp; stream.ByteCount() == size);
      return target + size;
    } else {
      io::EpsCopyOutputStream out(
          target, size,
          io::CodedOutputStream::IsDefaultSerializationDeterministic());
实际调用-&gt;    auto res = msg._InternalSerialize(target, &amp;out);
      GOOGLE_DCHECK(target + size == res);
      return res;
    }
  }
</code></pre></div>
可见，其实序列化最终调用的是pb.h文件里定义的<code>_InternalSerialize</code>, 举例官方例子<code>HelloRequest</code>
<div class="highlight"><pre><span></span><code> ::PROTOBUF_NAMESPACE_ID::uint8* HelloRequest::_InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream*   stream) const {
    // @@protoc_insertion_point(serialize_to_array_start:helloworld.HelloRequest)
    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    (void) cached_has_bits;

    // string name = 1;
    if (this-&gt;name().size() &gt; 0) {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        this-&gt;_internal_name().data(), static_cast&lt;int&gt;(this-&gt;_internal_name().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        &quot;helloworld.HelloRequest.name&quot;);
      target = stream-&gt;WriteStringMaybeAliased(
          1, this-&gt;_internal_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToA  rray(
         _internal_metadata_.unknown_fields&lt;::PROTOBUF_NAMESPACE_ID::UnknownFieldSet&gt;(::PROTOB  UF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
    }
    // @@protoc_insertion_point(serialize_to_array_end:helloworld.HelloRequest)
    return target;
  }
</code></pre></div></p>
<h5 id="grpcpbrpc"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpcpbrpc">grpc.pb生成的代码实现rpc调用</a></h5>
<p>生成的框架代码用来继承实现Service和获取stub来发起rpc call。实际上这些代码并不是必须的<br />
在下面讲了如何使用几个工厂类来创建Stub，还有直接<code>new</code>出Service</p>
<div class="highlight"><pre><span></span><code>class XXXServer {
        // 客户端使用的桩
    class Stub
        // base 
    class Service
    // 各种版本的rpc包装，但都继承自base
        class WithAsyncMethod_XXX
        typedef WithAsyncMethod_XXX&lt;Service &gt; AsyncService;
    typedef ExperimentalWithCallbackMethod_XXX&lt;Service &gt; CallbackService;
    class WithGenericMethod_XXX
    class WithRawMethod_XXX
    typedef WithStreamedUnaryMethod_XXX&lt;Service &gt; StreamedUnaryService;
}
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_2">同步与异步</a></h3>
<p>grpc 的异步即为使用cq事件驱动（cq-based），使用tag标记事件。另外还有callback方式</p>
<h4 id="_3"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_3">对于客户端</a></h4>
<p>同步时，通过调用'::grpc::internal::BlockingUnaryCall'<br />
异步时，创建'ClientAsyncResponseReader'(非流), 然后通过调用'ClientAsyncResponseReader'的write和finish，并等待tag
当存在流时分别是
- ::grpc::ClientAsyncReader
- ::grpc::ClientAsyncWriter
- ::grpc::ClientAsyncReaderWriter</p>
<p>这些类型可用对应的工厂类来创建, 生成代码的stub也是这么用的
<div class="highlight"><pre><span></span><code>class ClientReaderFactory 
class ClientWriterFactory 
class ClientReaderWriterFactory 
</code></pre></div></p>
<h4 id="_4"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_4">对于服务端</a></h4>
<p>同步时，通过'AddMethod'来注册，生成代码会在父类构造时执行。注册后由grpc调用
<div class="highlight"><pre><span></span><code>Greeter::Service::Service() {
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Greeter_method_names[0],
        ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler&lt; Greeter::Service, ::helloworld::HelloRequest, ::helloworld::HelloReply&gt;(
            [](Greeter::Service* service,
               ::grpc_impl::ServerContext* ctx,
               const ::helloworld::HelloRequest* req,
               ::helloworld::HelloReply* resp) {
                 return service-&gt;SayHello(ctx, req, resp);
               }, this)));
  }
</code></pre></div></p>
<p>异步时，类似客户端
- grpc::ServerAsyncReaderWriter
- grpc::ServerAsyncReader
- grpc::ServerAsyncWriter</p>
<p>可见服务端是直接new出来的，异步时这些io操作对象也是直接new出来的, 在调用以下时传入
<div class="highlight"><pre><span></span><code>RequestAsyncBidiStreaming
RequestAsyncClientStreaming
RequestAsyncServerStreaming
</code></pre></div></p>
<h3 id="grpc-callback"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc-callback">grpc callback</a></h3>
<p>只在客户端使用，callback方式的请求可以传入一个lambda, 在请求完成时调用
<div class="highlight"><pre><span></span><code>    stub_-&gt;async()-&gt;SayHello(&amp;context, &amp;request, &amp;reply,
                             [&amp;mu, &amp;cv, &amp;done, &amp;status](Status s) {
                               status = std::move(s);
                               std::lock_guard&lt;std::mutex&gt; lock(mu);
                               done = true;
                               cv.notify_one();
                             });
</code></pre></div></p>
<p>新版本的grpc已经将实验性的标记去除，说明此方式成熟了
<div class="highlight"><pre><span></span><code>    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
</code></pre></div></p>
<h3 id="grpc_1"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_1">grpc异步流</a></h3>
<p>官方仓库的示例代码没有异步且流的, 在实际项目中用到异步流,使用大概方法
1. 手动创建writereader
2. 启动时，调用'grpc::Service::RequestAsyncBidiStreaming' 和 'grpc::Service::RequestAsyncClientStreaming' 以及'RequestAsyncServerStreaming', 向cq塞请求new_connection事件
3. 收到'new_connection'事件返回后，再调用read事件。</p>
<p>一共有5个类型
<div class="highlight"><pre><span></span><code>new_connection, read, write, finish, done
</code></pre></div>
我写了一个demo <a href="https://github.com/energygreek/grpcstreamhelloworld">grpcstreamhelloworld</a></p>
<h3 id="grpc_2"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_2">grpc 消息大小</a></h3>
<p>老版本的grpc中，发送端是支持无限大小的，但接受端只能是4M
<div class="highlight"><pre><span></span><code>#define GRPC_DEFAULT_MAX_SEND_MESSAGE_LENGTH -1
#define GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH (4 * 1024 * 1024)
</code></pre></div>
服务端代码
<div class="highlight"><pre><span></span><code>std::unique_ptr&lt;Server&gt; ServerBuilder::BuildAndStart() {
    if (max_receive_message_size_ &gt;= 0) {
      args.SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, max_receive_message_size_);
    }
</code></pre></div></p>
<p>但在新版grpc中变了</p>
<div class="highlight"><pre><span></span><code>  std::unique_ptr&lt;grpc::Server&gt; ServerBuilder::BuildAndStart() {
    grpc::ChannelArguments args;
    if (max_receive_message_size_ &gt;= -1) {
      args.SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, max_receive_message_size_);
    }
    if (max_send_message_size_ &gt;= -1) {
      args.SetInt(GRPC_ARG_MAX_SEND_MESSAGE_LENGTH, max_send_message_size_);
    }
</code></pre></div>
<h3 id="grpc_3"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_3">grpc 编译安装的问题</a></h3>
<p>https://github.com/grpc/grpc/issues/13841</p>
<h3 id="grpc_4"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_4">grpc异步存在问题</a></h3>
<p>因为异步服务端通过completionqueue来通知rpc执行结果和执行下次调用，通常使用多queue和多线程的方式提高处理效率
1. 通常情况是多queue, 即每个service对应一个queue, 而每个service又有多个rpc，线程去轮询这个complete_queue。这样导致高线程切换开销，而且complete_queue也占用大量内存
2. 多线程，queue可以用多个线程去轮询，但0.13版本可能出现bug</p>
<h3 id="grpc_5"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_5">grpc异步流存在的问题</a></h3>
<p>grpc区别与其他框架很大一个优势是支持异步流，即可以多次请求和多次回复。异步是基于cq的事件驱动，所以必须等待tag回调, 连续两次发送会异常。
而真正的请求一般在业务模块处理, 不知道tag的状态即不知道是否正在发送， 那么如何在cq回调外发送消息呢？ </p>
<p>办法是维护一个发送队列，消息先存队列里，等待cq回调时取出发送。 另外由于流同步需要显式发送结束标记(服务端调Stream::Finish, 客户端调用WriteDown和Finish), 
所以需要有一个特殊消息加以区分，通常用空指针，也可以设置结束标志。另外由于发送代码会同时被业务调用和cq回调，需要对发送代码加锁</p>
<h3 id="grpc_6"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#grpc_6">调试grpc</a></h3>
<p>通过设置环境变量，让grpc向控制台打印详细信息
<div class="highlight"><pre><span></span><code>export GRPC_VERBOSITY=DEBUG
bash-5.0# ./build/bin/hasync slave  stdin stdout @127.0.0.1:7615
D1026 08:27:44.142802149   24658 ev_posix.cc:174]            Using polling engine: epollex
D1026 08:27:44.143406685   24658 dns_resolver_ares.cc:490]   Using ares dns resolver
I1026 08:27:44.158115785   24658 server_builder.cc:332]      Synchronous server. Num CQs: 1, Min pollers: 1, Max Pollers: 2, CQ timeout (msec): 10000
</code></pre></div></p>
<h3 id="_5"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_5">项目实践</a></h3>
<p>项目使用客户端异步/同步，服务端全异步， 可以兼容四种传输方式</p>
<h3 id="_6"><a class="toclink" href="../../../../grpc-%E5%AD%A6%E4%B9%A0/#_6">引用</a></h3>
<p>https://grpc.github.io/grpc/cpp/grpcpp_2impl_2codegen_2sync__stream_8h_source.html
https://grpc.github.io/grpc/cpp/grpcpp_2impl_2codegen_2byte__buffer_8h_source.html
https://grpc.github.io/grpc/cpp/call__op__set_8h_source.html</p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-12 00:00:00+00:00">2021年4月12日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="segfault-in-dmesg"><a class="toclink" href="../../../../segfault-in-dmesg/">segfault in dmesg</a></h2>
<p>偶尔看到自己或者客户的/var/log/message 日志出现segfault, 查询了一下相关信息
<div class="highlight"><pre><span></span><code>Apr  6 09:43:37 icm kernel: rhsm-icon[13402]: segfault at 12b0000 ip 0000003c89845c00 sp 00007ffce18396e0 error 4 in libglib-2.0.so.0.2800.8[3c89800000+115000]
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../../../segfault-in-dmesg/#_1">解释</a></h3>
<ul>
<li>address (after the at) - the location in memory the code is trying to access (it's likely that 10 and 11 are offsets from a pointer we expect to be set to a valid value but which is instead pointing to 0)</li>
<li>ip - instruction pointer, ie. where the code which is trying to do this lives</li>
<li>sp - stack pointer</li>
<li>error - An error code for page faults; see below for what this means on x86.
<div class="highlight"><pre><span></span><code>/*
 * Page fault error code bits:
 *
 *   bit 0 ==    0: no page found       1: protection fault
 *   bit 1 ==    0: read access         1: write access
 *   bit 2 ==    0: kernel-mode access  1: user-mode access
 *   bit 3 ==                           1: use of reserved bit detected
 *   bit 4 ==                           1: fault was an instruction fetch
 */
</code></pre></div></li>
</ul>
<h3 id="message"><a class="toclink" href="../../../../segfault-in-dmesg/#message">message日志</a></h3>
<p>使用<code>dmesg</code>打印ring buffer的内容，关于硬件和i/o的信息</p>
<h3 id="coredump"><a class="toclink" href="../../../../segfault-in-dmesg/#coredump">coredump</a></h3>
<div class="highlight"><pre><span></span><code> A core file is an image of a process that has crashed It contains all process information pertinent to debugging: contents of hardware registers, process status, and process data. Gdb will allow you use this file to determine where your program crashed. 
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../../../segfault-in-dmesg/#_2">复现</a></h3>
<div class="highlight"><pre><span></span><code>void foo(){
    int *p = 0;
    *p = 100;
}

int main(){
  foo();
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>[ 5902.293905] a.out[6085]: segfault at 0 ip 000055c0eddca129 sp 00007ffe65372110 error 6 in a.out[55c0eddca000+1000]
[ 5902.293916] Code: 00 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa e9 67 ff ff ff 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 64 00 00 00 90 5d c3 55 48 89 e5 b8 00 00 00 00 e8 d9 ff ff
</code></pre></div>
<div class="highlight"><pre><span></span><code>(gdb) info registers 
rax            0x0                 0
rbx            0x55c0eddca150      94287112741200
rcx            0x7faa085eb598      140368261592472
rdx            0x7ffe65372228      140730596532776
rsi            0x7ffe65372218      140730596532760
rdi            0x1                 1
rbp            0x7ffe65372110      0x7ffe65372110
rsp            0x7ffe65372110      0x7ffe65372110
r8             0x0                 0
r9             0x7faa08621070      140368261812336
r10            0x69682ac           110527148
r11            0x202               514
r12            0x55c0eddca020      94287112740896
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x55c0eddca129      0x55c0eddca129 &lt;foo+16&gt;
eflags         0x10246             [ PF ZF IF RF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
</code></pre></div>
<h3 id="addr2line"><a class="toclink" href="../../../../segfault-in-dmesg/#addr2line">addr2line</a></h3>
<div class="highlight"><pre><span></span><code>addr2line -e yourSegfaultingProgram 00007f9bebcca90d
</code></pre></div>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-07 00:00:00+00:00">2021年4月7日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="cmake"><a class="toclink" href="../../../../cmake-learning/">cmake 学习</a></h2>
<h3 id="add_custom_command"><a class="toclink" href="../../../../cmake-learning/#add_custom_command">add_custom_command 用法</a></h3>
<p>用来定义自定义的方法, 而且有2套签名或者说触发规则 </p>
<h4 id="add_custom_target"><a class="toclink" href="../../../../cmake-learning/#add_custom_target">与 <code>add_custom_target</code> 配合使用, 用于生成文件</a></h4>
<p>这种情况下，<code>add_custom_target</code> 续要在<code>add_custom_command</code>之后出现。
语法
<div class="highlight"><pre><span></span><code>add_custom_command(OUTPUT output1 [output2 ...]
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [MAIN_DEPENDENCY depend]
                   [DEPENDS [depends...]]
                   [BYPRODUCTS [files...]]
                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1
                                    [&lt;lang2&gt; depend2] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [DEPFILE depfile]
                   [JOB_POOL job_pool]
                   [VERBATIM] [APPEND] [USES_TERMINAL]
                   [COMMAND_EXPAND_LISTS])
</code></pre></div></p>
<p>类似make的语法规则
<div class="highlight"><pre><span></span><code>target:dependency
  command
</code></pre></div>
如果<code>dependency</code>不存在，就去找生成依赖本身的规则，没有也生成依赖的规则，那么make会停止。 </p>
<p>如下的例子
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="p">)</span>
<span class="w"> </span><span class="nb">project</span><span class="p">(</span><span class="s">test</span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="w"> </span><span class="s">main.c</span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_custom_command</span><span class="p">(</span><span class="s">OUTPUT</span><span class="w"> </span><span class="s">printout</span><span class="w"> </span>
<span class="w">                    </span><span class="s">COMMAND</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span><span class="w"> </span><span class="s">-E</span><span class="w"> </span><span class="s">echo</span><span class="w"> </span><span class="s">compile</span><span class="w"> </span><span class="s">finish</span>
<span class="w">                    </span><span class="s">VERBATIM</span>
<span class="w">                   </span><span class="p">)</span>
<span class="w"> </span><span class="nb">add_custom_target</span><span class="p">(</span><span class="s">finish</span>
<span class="w">                   </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">printout</span>
<span class="w">                   </span><span class="p">)</span>
</code></pre></div></p>
<p>finish 依赖 printout, 而<code>add_custom_command</code>定义了printout的规则，printout即为下面的command执行的输出   </p>
<p>所以当生成finish目标的时候会触发上面的<code>add_custom_command</code> </p>
<p>其实这种情况下， 直接将<code>add_custome_command</code>的command写到<code>add_custome_target</code>中也是一样的效果</p>
<h4 id="command-line-tool"><a class="toclink" href="../../../../cmake-learning/#command-line-tool">command-line-tool</a></h4>
<p>以上<code>add_cunstom_command</code>的两种用法都使用了<code>COMMAND ${CMAKE_COMMAND} -E</code>，这是使用了cmake内置的[命令]{https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool}    </p>
<h5 id="_1"><a class="toclink" href="../../../../cmake-learning/#_1">运用</a></h5>
<p>例如生成protobuf的文件, 需要自定义方法</p>
<div class="highlight"><pre><span></span><code>    # output files:
    FOREACH (src ${proto_srcs})
        get_filename_component(base_name ${src} NAME_WE)
        get_filename_component(path_name ${src} PATH)

        set(src &quot;${base_name}.proto&quot;)
        set(cpp &quot;${base_name}.pb.cc&quot;)
        set(hpp &quot;${base_name}.pb.h&quot;)
        set(grpc_cpp &quot;${base_name}.grpc.pb.cc&quot;)
        set(grpc_hpp &quot;${base_name}.grpc.pb.h&quot;)

        # custom command.
        add_custom_command(
            OUTPUT ${proto_cpp_dist}/${cpp} ${proto_cpp_dist}/${hpp} ${proto_hpp_dist}/${hpp}
              ${proto_cpp_dist}/${grpc_cpp} ${proto_cpp_dist}/${grpc_hpp}
            COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
            ARGS ${OUTPUT_PATH}
              --grpc_out ${proto_cpp_dist}
              --plugin=protoc-gen-grpc=${GRPC_CPP_PLUGIN}
              ${src} 
            DEPENDS ${src}
            COMMAND ${CMAKE_COMMAND}
            ARGS -E copy_if_different ${proto_cpp_dist}/${hpp} ${proto_hpp_dist}/${hpp}
            COMMAND ${CMAKE_COMMAND}
            ARGS -E copy_if_different  ${proto_cpp_dist}/${grpc_hpp} ${proto_hpp_dist}/${grpc_hpp}
            WORKING_DIRECTORY ${path_name}
            COMMENT &quot;${PROTOBUF_PROTOC_EXECUTABLE} --cpp_out=${proto_cpp_dist} ${src}&quot;
            )

        LIST(APPEND output ${proto_cpp_dist}/${cpp})
    ENDFOREACH()
</code></pre></div>
<h4 id="_2"><a class="toclink" href="../../../../cmake-learning/#_2">单独使用, 编译触发</a></h4>
<p>这个是当项目中有<code>add_library</code>或者<code>add_excutable</code>目标时可以在编译目标文件前/链接前/编译后触发
<div class="highlight"><pre><span></span><code><span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span><span class="w"> </span><span class="s">&lt;target&gt;</span>
<span class="w">                   </span><span class="s">PRE_BUILD</span><span class="w"> </span><span class="s">|</span><span class="w"> </span><span class="s">PRE_LINK</span><span class="w"> </span><span class="s">|</span><span class="w"> </span><span class="s">POST_BUILD</span>
<span class="w">                   </span><span class="s">COMMAND</span><span class="w"> </span><span class="s">command1</span><span class="w"> </span><span class="s">[ARGS]</span><span class="w"> </span><span class="s">[args1...]</span>
<span class="w">                   </span><span class="s">[COMMAND</span><span class="w"> </span><span class="s">command2</span><span class="w"> </span><span class="s">[ARGS]</span><span class="w"> </span><span class="s">[args2...]</span><span class="w"> </span><span class="s">...]</span>
<span class="w">                   </span><span class="s">[BYPRODUCTS</span><span class="w"> </span><span class="s">[files...]]</span>
<span class="w">                   </span><span class="s">[WORKING_DIRECTORY</span><span class="w"> </span><span class="s">dir]</span>
<span class="w">                   </span><span class="s">[COMMENT</span><span class="w"> </span><span class="s">comment]</span>
<span class="w">                   </span><span class="s">[VERBATIM]</span><span class="w"> </span><span class="s">[USES_TERMINAL]</span>
<span class="w">                   </span><span class="s">[COMMAND_EXPAND_LISTS]</span><span class="p">)</span>
</code></pre></div></p>
<h3 id="cmake_1"><a class="toclink" href="../../../../cmake-learning/#cmake_1">cmake 逻辑表达式</a></h3>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-04-02 00:00:00+00:00">2021年4月2日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="cmake"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">cmake 使用第三方库</a></h2>
<p>在项目中链接第三方库的方法都是'target_include_directories' 和 'target_link_library', 前提引入第三方包. 而查找可以使用<code>find_package</code></p>
<h3 id="find_package"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#find_package">find_package找包</a></h3>
<p>find_package分为Module和Config两种方式</p>
<h4 id="module"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#module">Module方式</a></h4>
<p>find_package先在'/usr/share/cmake/Modules/Find/'下添加FindXXX.cmake文件，以及自定义路径(CMAKE_MODULE_PATH)下查找
然后在项目的CMakeList.txt中使用find_package(), 然后可以在链接的时候使用第三方库</p>
<div class="highlight"><pre><span></span><code><span class="nb">find_package</span><span class="p">()</span>
</code></pre></div>
<h4 id="config"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#config">Config模式</a></h4>
<p>当find_package找不到FindXXX.cmake文件，则会找
- <LibraryName>Config.cmake
- <lower-case-package-name>-config.cmake</p>
<p>如果第三方项目支持cmake, 那么先通过cmake编译和安装到环境或者docker环境，这时会在'/usr/lib/cmake/<LibraryName>/'下添加上述文件</p>
<h4 id="findxxxcmake"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#findxxxcmake">安装FindXXX.cmake文件</a></h4>
<p>当没有FindXXX.cmake时，可以使用安装包管理工具安装cmake-extra包, 可能找到需要的
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>pacman<span class="w"> </span>-S<span class="w"> </span>extra-cmake-modules
</code></pre></div></p>
<p>然后执行下面的命令，可以看到大量的'Find*.cmake'文件
<div class="highlight"><pre><span></span><code>ls /usr/share/cmake-3.20/Modules/
</code></pre></div></p>
<h4 id="findxxxcmake_1"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#findxxxcmake_1">自定义FindXXX.cmake文件</a></h4>
<p>如果上述方式都不行，那么需要自己写FindXXX.cmake，放到CMAKE_MODULE_PATH下<br />
例如在项目根目录创建文件夹<code>cmake_module</code>, 再使用<code>set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake_module)</code>来指定module的路径 <br />
最后在'cmake_module'下创建FindXXX.cmake结尾的文件，这个文件用来写找header和lib规则, 内容大致为</p>
<div class="highlight"><pre><span></span><code>find_path(Grpc_INCLUDE_DIR grpc++/grpc++.h)
mark_as_advanced(Grpc_INCLUDE_DIR)

find_library(Grpc++_LIBRARY NAMES grpc++ grpc++-1-dll)
mark_as_advanced(Grpc++_LIBRARY)
</code></pre></div>
<p>有这个文件之后，可以在项目的cmake中直接使用<code>find_package()</code></p>
<h3 id="_1"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#_1">源代码编译链接</a></h3>
<p>将第三方库源码放到项目指定目录如third</p>
<ol>
<li>放到third目录并可以使用<code>git submodule</code>管理</li>
<li>在thrid目录添加CMakeList.txt，在其中添加目标，已备在项目中链接
<div class="highlight"><pre><span></span><code># for gsl-lite target
add_library(gsl-lite INTERFACE)
target_include_directories(gsl-lite SYSTEM INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/gsl-lite/include)
</code></pre></div></li>
</ol>
<h3 id="fetchcontent"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#fetchcontent">FetchContent 自动源代码链接</a></h3>
<p>cmake3.11之后，可以使用这个办法来自动拉取网上的库，并可以直接在自己的项目中使用</p>
<div class="highlight"><pre><span></span><code><span class="c"># NOTE: This example uses cmake version 3.14 (FetchContent_MakeAvailable).</span>
<span class="c"># Since it streamlines the FetchContent process</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.14</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>

<span class="c"># In this example we are picking a specific tag.</span>
<span class="c"># You can also pick a specific commit, if you need to.</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span><span class="s">GSL</span>
<span class="w">    </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s2">&quot;https://github.com/microsoft/GSL&quot;</span>
<span class="w">    </span><span class="s">GIT_TAG</span><span class="w"> </span><span class="s2">&quot;v3.1.0&quot;</span>
<span class="p">)</span>

<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">GSL</span><span class="p">)</span>

<span class="c"># Now you can link against the GSL interface library</span>
<span class="nb">add_executable</span><span class="p">(</span><span class="s">foobar</span><span class="p">)</span>

<span class="c"># Link against the interface library (IE header only library)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">foobar</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">GSL</span><span class="p">)</span>
</code></pre></div>
<h3 id="cmakeopenssl"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#cmakeopenssl">cmake使用openssl存在问题</a></h3>
<p>因为openssl不用cmake,也就没有.cmake文件, 导致项目配置失败 
<div class="highlight"><pre><span></span><code> Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the
  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_LIBRARIES
  OPENSSL_INCLUDE_DIR)
</code></pre></div>
后面发现它是使用package_config方式
<div class="highlight"><pre><span></span><code>#/usr/local/lib/pkgconfig/openssl.pc
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

Name: OpenSSL
Description: Secure Sockets Layer and cryptography libraries and tools
Version: 1.1.1k
Requires: libssl libcrypto
</code></pre></div></p>
<p>这种情况除了通过cmake_module来解决之外，还可以通过指定pc文件的路径
<div class="highlight"><pre><span></span><code>cmake -DOPENSSL_ROOT_DIR=/usr/local/ 
</code></pre></div></p>
<h3 id="externalproject_add"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#externalproject_add">ExternalProject_Add</a></h3>
<p>这个不常用</p>
<h3 id="find_package-find_library"><a class="toclink" href="../../../../cmake-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#find_package-find_library">find_package 和 find_library 区别</a></h3>
<p>find_library 是cmake的底层方法，在find_path指定的目录下查找库文件 <br />
而find_package 使用了find_library的来找库文件，而且find_package在找到目标后，会定义一些变量，如下面的'Findlibproxy.cmake'文件头</p>
<div class="highlight"><pre><span></span><code># - Try to find libproxy
# Once done this will define
#
#  LIBPROXY_FOUND - system has libproxy
#  LIBPROXY_INCLUDE_DIR - the libproxy include directory
#  LIBPROXY_LIBRARIES - libproxy library
#
# Copyright (c) 2010, Dominique Leuenberger
#
# Redistribution and use is allowed according the license terms
# of libproxy, which this file is integrated part of.

# Find proxy.h and the corresponding library (libproxy.so)
FIND_PATH(LIBPROXY_INCLUDE_DIR proxy.h )
FIND_LIBRARY(LIBPROXY_LIBRARIES NAMES proxy )
</code></pre></div>
<p>当找到libproxy.so的时候，LIBPROXY_FOUND被设置为TRUE等</p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-31 00:00:00+00:00">2021年3月31日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 1 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="shell"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/">shell 笔记</a></h2>
<p>shell 是unix-like系统下，用户与系统交互的媒介，用来解析用户的输入并调用系统函数。 
而shell的实现有常见的bash,zsh,ksh等, 他们实现有很多差别，但bash最为通用</p>
<h3 id="bash"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/#bash">bash 模式拓展</a></h3>
<h3 id="bash_1"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/#bash_1">bash 字符串操作</a></h3>
<h3 id="bash_2"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/#bash_2">bash 数组操作</a></h3>
<h3 id="_1"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/#_1">环境变量</a></h3>
<p>测试程序定时获取和打印环境变量
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;TEST_ENV&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;env: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="p">);</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>通过bash来修改环境变量
<div class="highlight"><pre><span></span><code><span class="c1">#test.sh</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">TEST_ENV</span><span class="o">=</span>TEST
./a.out
<span class="nb">export</span><span class="w"> </span><span class="nv">TEST_ENV</span><span class="o">=</span>NNN
</code></pre></div></p>
<p>执行<code>test.sh</code>，c程序没有更新环境变量, 所以环境变量不会变化。</p>
<div class="highlight"><pre><span></span><code>env: TEST
env: TEST
env: TEST
</code></pre></div>
<div class="highlight"><pre><span></span><code>#include &lt;stdio.h&gt;

extern char **environ;

int main() {
  char **var;
  for (var = environ; *var != NULL; ++var) {
    printf(&quot;%s\n&quot;, *var);
  }
}
</code></pre></div>
<h3 id="set-unset"><a class="toclink" href="../../../../shell-%E7%AC%94%E8%AE%B0/#set-unset">set unset</a></h3>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-25 00:00:00+00:00">2021年3月25日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="urxvt"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/">urxvt配置</a></h2>
<p>自使用arch以来，一直在用urxvt, 它简洁，轻量，但不可否认的有问题，比如中文输入模式长时间时会无法输入中文，配置麻烦, 需要在启动脚本配置.xresource<br />
这里要记一下自己的urxvt的配置以做备份  </p>
<h3 id="urxvt_1"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/#urxvt_1">使用urxvt的主要功能</a></h3>
<p>urxvt 非常简洁的tab功能,支持多路复用以及右键菜单格式化字符串，而且支持假透明，非常轻量。</p>
<p>urxvt不够现代化，不是开箱即用的，需要如下修改： 
* tab功能需要修改perl的包，因为默认情况下不支持切换tab
* 不支持icon, 需要在配置文件手动指定icon的位置
* tab功能需要额外启动参数，所以顺便编一个desktop启动文件</p>
<h3 id="perl"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/#perl">perl修改</a></h3>
<p>复制/usr/lib/perl/ext/tabbed到用户目录~/.urxvt/ext/, 修改<code>tab_key_press</code>函数如下</p>
<div class="highlight"><pre><span></span><code><span class="c1"># if ($keysym == 0xff51 || $keysym == 0xff53)  表示使用ctrl+shift 和方向键来移动tab</span>
<span class="k">sub</span><span class="w"> </span><span class="nf">tab_key_press</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="p">,</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="nv">$event</span><span class="p">,</span><span class="w"> </span><span class="nv">$keysym</span><span class="p">,</span><span class="w"> </span><span class="nv">$str</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">@_</span><span class="p">;</span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ShiftMask</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ControlMask</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">grep</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$_</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="nv">$#</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="w">         </span><span class="o">--</span><span class="nv">$idx</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="p">;</span>
<span class="w">         </span><span class="o">++</span><span class="nv">$idx</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">;</span>

<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">make_current</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx</span><span class="w"> </span><span class="nv">%</span><span class="w"> </span><span class="err">@</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}}]);</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">elsif</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff54</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">new_tab</span><span class="p">;</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span><span class="k">elsif</span><span class="w"> </span><span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ControlMask</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">$event</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">state</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nn">urxvt::</span><span class="n">ShiftMask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff53</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">my</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">grep</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$_</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$tab</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="nv">$#</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<span class="w">         </span><span class="k">my</span><span class="w">  </span><span class="nv">$idx2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nv">$idx1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nv">$keysym</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xff51</span><span class="w"> </span><span class="p">?</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="nv">%</span><span class="w"> </span><span class="err">@</span><span class="p">{</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="w">         </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx1</span><span class="p">],</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">])</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">],</span><span class="w"> </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx1</span><span class="p">]);</span>

<span class="w">         </span><span class="nv">$self</span><span class="o">-&gt;</span><span class="n">make_current</span><span class="w"> </span><span class="p">(</span><span class="nv">$self</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">tabs</span><span class="p">}[</span><span class="nv">$idx2</span><span class="p">]);</span>

<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="urxvt_2"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/#urxvt_2">urxvt 启动文件</a></h3>
<p>创建启动文件，使其默认为tab模式 '.local/share/applications/urxvtq.desktop'
<div class="highlight"><pre><span></span><code>[Desktop Entry]
Version=1.0
Name=urxvtq
Comment=An unicode capable rxvt clone
Exec=urxvt -pe tabbed
Icon=utilities-terminal
Terminal=false
Type=Application
Categories=System;TerminalEmulator;
</code></pre></div></p>
<h3 id="urxvt_3"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/#urxvt_3">urxvt 配置</a></h3>
<p>创建如下的文件，并要在合适的启动脚本里添加一行<code>[ -f "$HOME/.Xresources" ] &amp;&amp;  xrdb -merge "$HOME/.Xresources"</code>
<div class="highlight"><pre><span></span><code>!!$HOME/.Xresources

!! dbi
Xft.dpi:98

/* Couleurs Tango */

!! 下划线色
URxvt.colorUL:  #87afd7
URxvt.colorBD:  white
URxvt.colorIT:  green

!! tab 配色
URxvt.tabbed.tabbar-fg: 2
URxvt.tabbed.tabbar-bg: 0
URxvt.tabbed.tab-fg:    3
URxvt.tabbed.tab-bg:    2
URxvt.tabbed.tabren-bg: 3
URxvt.tabbed.tabdiv-fg: 8
URxvt.tabbed.tabsel-fg: 1
URxvt.tabbed.tabsel-bg: 8

!! fake transparent
URxvt.transparent: true
URxvt.shading:     10
URxvt.fading:      40
!! font
URxvt.font:        xft:Monospace,xft:Awesome:pixelsize=14
URxvt.boldfont:    xft:Monospace,xft:Awesome:style=Bold:pixelsize=16

!! scroll behavior
URxvt.scrollBar:         false
URxvt.scrollTtyOutput:   false
URxvt.scrollWithBuffer:  true
URxvt.scrollTtyKeypress: true

!! addtional
URxvt.internalBorder:     0
URxvt.cursorBlink: true
URxvt.saveLines:          2000
URxvt.mouseWheelScrollPage:             false

! Restore Ctrl+Shift+(c|v)
URxvt.keysym.Shift-Control-V: eval:paste_clipboard
URxvt.keysym.Shift-Control-C: eval:selection_to_clipboard
URxvt.iso14755: false
URxvt.iso14755_52: false

! alt+s 搜索
URxvt.perl-ext:   default,matcher,searchable-scrollback
URxvt.keysym.M-s: searchable-scrollback:start

! url match 问题是tab模式下不支持跳转浏览器
URxvt.url-launcher:       /usr/bin/firefox
URxvt.matcher.button:     1


URxvt.termName:         xterm-256color
URxvt.iconFile:     /usr/share/icons/gnome/32x32/apps/gnome-terminal-icon.png
! fast key
URxvt.keysym.Control-Up:     \033[1;5A
URxvt.keysym.Control-Down:   \033[1;5B
URxvt.keysym.Control-Left:   \033[1;5D
URxvt.keysym.Control-Right:  \033[1;5C
</code></pre></div></p>
<h3 id="_1"><a class="toclink" href="../../../../urxvt%E9%85%8D%E7%BD%AE/#_1">最后</a></h3>
<p>用了kitty就不会有输入法的问题，字体也很丰富, 推荐现代化模拟终端kitty</p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-17 00:00:00+00:00">2021年3月17日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="static-compile-warning-if-namespace-resolving-function-used"><a class="toclink" href="../../../../static-compile-warning-if-namespace-resolving-function-used/">static compile warning if namespace resolving function used</a></h2>
<p>当程序里面有使用到解析函数的时候， 静态编译程序会报warning</p>
<h3 id="_1"><a class="toclink" href="../../../../static-compile-warning-if-namespace-resolving-function-used/#_1">现象</a></h3>
<div class="highlight"><pre><span></span><code>../../lib/libhacore.a(File.cpp.o): In function `_ZN2ha4core9gid2groupB5cxx11Ej&#39;:
/tmp/src/ha/core/File.cpp:213: warning: Using &#39;getgrgid_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `ha::core::group2gid(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned int&amp;)&#39;:
/tmp/src/ha/core/File.cpp:291: warning: Using &#39;getgrnam_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `ha::core::username2uid(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned int&amp;)&#39;:
/tmp/src/ha/core/File.cpp:271: warning: Using &#39;getpwnam_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
../../lib/libhacore.a(File.cpp.o): In function `_ZN2ha4core12uid2usernameB5cxx11Ej&#39;:
/tmp/src/ha/core/File.cpp:194: warning: Using &#39;getpwuid_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
CMakeFiles/hasync-exec.dir/main.cpp.o: In function `boost::asio::detail::socket_ops::getaddrinfo(char const*, char const*, addrinfo const&amp;, addrinfo**, boost::system::error_code&amp;)&#39;:
/usr/local/include/boost/asio/detail/impl/socket_ops.ipp:3348: warning: Using &#39;getaddrinfo&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcrypto.a(b_sock.o): In function `BIO_gethostbyname&#39;:
b_sock.c:(.text+0x51): warning: Using &#39;gethostbyname&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcares.a(libcares_la-ares_getaddrinfo.o): In function `ares_getaddrinfo&#39;:
ares_getaddrinfo.c:(.text+0x73f): warning: Using &#39;getservbyname&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/local/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib64/libcares.a(libcares_la-ares_getnameinfo.o): In function `lookup_service.part.0.constprop.2&#39;:
ares_getnameinfo.c:(.text+0x32d): warning: Using &#39;getservbyport_r&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
</code></pre></div>
<h3 id="_2"><a class="toclink" href="../../../../static-compile-warning-if-namespace-resolving-function-used/#_2">结论</a></h3>
<p>即使静态链接glibc, glibc内部在运行时依旧要调用<code>动态库</code>，这些库函数多与域名解析有关, 所以要求运行时的库版本要与编译时相同， 当然基于容器化部署就不用担心了  </p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-15 00:00:00+00:00">2021年3月15日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="_1"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></h2>
<p>智能指针是c++11加入的特性，包括shared_ptr和unique_ptr，weak_ptr，以及make_shared函数，但make_unique是c++14才出来<br />
不过c++11可以通过模版来实现make_unique</p>
<h3 id="_2"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_2">普通指针和智能指针的区别</a></h3>
<p>shared_ptr和unique_ptr都是异常安全的(exception-safe)，而普通指针不是，举例如下
<div class="highlight"><pre><span></span><code>void nonsafe_call(T1* t1, T2* t2);
void safe_call(unique_ptr&lt;T1&gt; t1, unique_ptr&lt;T2&gt; t2);

nonsafe_call(new T1, new T2);
safe_call(make_unique&lt;T1&gt;, make_unique&lt;T2&gt;);
</code></pre></div></p>
<h4 id="_3"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_3">引用计数</a></h4>
<p><img alt="shared_ptr.png" src="../../../../img/shared_ptr.png" /></p>
<h4 id="_4"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_4">当形参为普通指针时</a></h4>
<p>虽然new是安全的，会先申请内存再构造对象t1。 如果t1的构造函数抛异常，申请的内存会自动释放，不会内存泄漏<br />
但当两个new作为函数参数时，情况不同。 因为参数必须在调用函数前决断，所以步骤如下
<div class="highlight"><pre><span></span><code>1. 为t1申请内存
2. 构造t1
3. 为t2申请内存
4. 构造t2
5. 调用函数
</code></pre></div></p>
<ul>
<li>当执行到2失败时，不会泄漏，new会释放t1的内存</li>
<li>当执行到4失败是，会泄漏t1，因为t1已经构造完成，不会释放内存</li>
</ul>
<h4 id="_5"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_5">当形参为智能指针时</a></h4>
<p>步骤为
<div class="highlight"><pre><span></span><code>1. t1 = make_unique&lt;T1&gt;()
2. t2 = make_unique&lt;T2&gt;()
3. 调用函数
</code></pre></div>
如果2失败，t1的对象由unique_ptr管理，当t1释放时，会释放内存，所以无论t1构造失败还是t2构造失败，都能正确释放内存，不会导致泄漏<br />
就因为unique_ptr和shared_ptr是内存安全的</p>
<h4 id="_6"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_6">但以普通指针构造智能指针的方式不是异常安全的</a></h4>
<p>即<code>foo(std::unique_ptr&lt;T1&gt;(new T1()), std::unique_ptr&lt;T2&gt;(new T2()));</code> 不是异常安全的</p>
<p>此时步骤可能如下
<div class="highlight"><pre><span></span><code>1. 为t1申请内存
2. 构造t1
3. 为t2申请内存
4. 构造t2
5. 构造unique_ptr&lt;T1&gt;
6. 构造unique_ptr&lt;T2&gt;
7. 调用函数
</code></pre></div>
当步骤4发生异常时，t1并未被unique_ptr管理，所以不会去释放t1的内存，故发生内存泄漏</p>
<h3 id="_7"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_7">智能指针的构造</a></h3>
<p>shared_ptr对应的函数是make_shared<T><br />
但c++11中没有make_unique, 可以使用模版实现如下</p>
<p><div class="highlight"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span><span class="w"> </span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
那为什么这样就能异常安全呢？因为调用make_uniqe时，可以确保t1的内存被unique_ptr管理了 </p>
<h3 id="make_sharednew"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#make_sharednew">make_shared创建智能指针和用new创建智能指针的区别</a></h3>
<p>除了上面说所的make_shared/make_unique是异常安全，而unique_ptr<T>(new T()) 不是异常安全外，其构造的智能指针也不同  </p>
<p>智能指针之所以会释放内存，是因为智能指针本身也是一个对象，在其生命周期结束后会调用dtor, 并在那里释放内存<br />
所以智能指针的对象内存即包含了T，也包含了智能指针本身，而make_shared<T>() 和 shared_ptr<T>(new T)的区别在于<code>前者是两个部分的地址连续，而后者并不一定连续</code></p>
<h3 id="unique_ptr"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#unique_ptr">unique_ptr的区别</a></h3>
<p>unique_ptr和shared_ptr不同，后者为了多变量同时拥有资源的访问，而unique_ptr表示任何时刻，只有一个变量能访问资源和释放资源，比如打开的文件设备, 
而且通常为管理的资源设置析构函数，比如指定析构时关闭文件和设备</p>
<p>如下代码，当fp析构时，自动关闭文件
<div class="highlight"><pre><span></span><code>// helper function for the custom deleter demo below
void close_file(std::FILE* fp)
{
    std::fclose(fp);
}
using unique_file_t = std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt;;
unique_file_t fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file);
</code></pre></div></p>
<p>unique_ptr要配合move使用，当move之后，原对象不拥有指针资源</p>
<h3 id="_8"><a class="toclink" href="../../../../%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#_8">总结</a></h3>
<p>为了避免多参数决断时，导致已经决断的参数内存泄漏，应尽可能使用智能指针来管理内存</p>
    
    
  </div>
</article>
      
        <article class="md-post md-post--excerpt">
  <header class="md-post__header">
    
    <div class="md-post__meta md-meta">
      <ul class="md-meta__list">
        <li class="md-meta__item">
          <time datetime="2021-03-10 00:00:00+00:00">2021年3月10日</time></li>
        
        
          
          <li class="md-meta__item">
            
              需要 2 分钟阅读时间
            
          </li>
        
        
      </ul>
      
    </div>
  </header>
  <div class="md-post__content md-typeset">
    <h2 id="avahi"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/">使用avahi将传统打印机支持无线打印</a></h2>
<p>自从知道mdns之后，发现它非常方便，例如可以找到lan下有哪些ftp服务，ssh服务等。甚至我配置好的打印机服务。</p>
<h3 id="mdns"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#mdns">mdns介绍</a></h3>
<p>有别于dns, mdns专门用来解析链路域名（TLD为*.local）， 且不需要域名服务器（nameserver）。 <br />
原理是同一个lan里的主机通过avahi或zeroconfig类似的工具，向lan广播自己的ip信息和服务</p>
<h3 id="avahi_1"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#avahi_1">avahi 介绍</a></h3>
<p>avahi是zeroconfig的开源实现，在linux下还有systemd-resolve 同样可以实现mdns解析，但是avahi依旧是linux预装的软件。</p>
<h4 id="avahi_2"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#avahi_2">avahi 配置</a></h4>
<p>主要修改<code>/etc/avahi/avahi-daemon.conf</code>, 这里使用了br0和wlan0两个网卡，avahi就可以访问两个网络
<div class="highlight"><pre><span></span><code>use-ipv4=yes
allow-interfaces=br0,wlan0
</code></pre></div>
再设置自启动</p>
<h4 id="nss"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#nss">nss 配置</a></h4>
<p>要让主机能解析到*.local 域名，需要修改配置文件<code>/etc/nsswitch.conf</code> 
<div class="highlight"><pre><span></span><code><span class="gd">- hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns</span>
<span class="gi">+ hosts: files mymachines myhostname mdns_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] dns</span>
</code></pre></div>
这样，在主机请求解析域名的时候， 会先去请求avahi解析，如果avahi解析失败（说明不是一个local域名）才会去查找域名解析（dns）</p>
<h3 id="systemd-resolved"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#systemd-resolved">使用systemd-resolved</a></h3>
<p>对于使用systemd-resoved来管理dns解析时，可以直接用<code>sudo systemd-resolve --set-mdns=yes --interface=eth0</code>启动eth0端口的mdns广播。</p>
<p>顺便提一下，用systemd-networkd配置dns服务器和用systemd-resolved配置dns的区别，前者为每个以太网口单独配置，而systemd-resoved会读取每个以太网口配置，另外还有一个全局的dns配置。</p>
<h4 id="_1"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_1">测试</a></h4>
<p>首先可以ping 本地local域名
<div class="highlight"><pre><span></span><code>~<span class="w"> </span>&gt;<span class="w"> </span>ping<span class="w"> </span>hst.local<span class="w">                                                                                                                                                                                      </span>
PING<span class="w"> </span>hst.local<span class="o">(</span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">))</span><span class="w"> </span><span class="m">56</span><span class="w"> </span>data<span class="w"> </span>bytes
<span class="m">64</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">)</span>:<span class="w"> </span><span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">ttl</span><span class="o">=</span><span class="m">64</span><span class="w"> </span><span class="nv">time</span><span class="o">=</span><span class="m">0</span>.113<span class="w"> </span>ms
<span class="m">64</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span>hst<span class="w"> </span><span class="o">(</span>fe80::3e9c:fff:fe8c:69c3%wlan0<span class="o">)</span>:<span class="w"> </span><span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="nv">ttl</span><span class="o">=</span><span class="m">64</span><span class="w"> </span><span class="nv">time</span><span class="o">=</span><span class="m">0</span>.144<span class="w"> </span>ms
</code></pre></div></p>
<p>然后执行<code>avahi-discover-standalone</code> 可以查找到很多*.local的地址，特别是在公司网络里</p>
<h3 id="_2"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_2">广告自己的服务</a></h3>
<p>配置好了avahi, 就可以向外界发布自己的服务，让其他人知道，也可以选择不发布<br />
例如要广告我的ssh服务, 只需要将预设的配置文件拷贝到avahi的配置目录下
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>cp<span class="w"> </span>/usr/share/doc/avahi/ssh.service<span class="w"> </span>/etc/avahi/services
</code></pre></div>
这样，别人就能发现我的ssh服务了</p>
<h3 id="_3"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_3">配置打印机</a></h3>
<p>linux的打印功能依赖CUPS这个软件，先安装CUPS，设置自启动，然后就可以访问CUPS的网页版管理界面<code>http://localhost:631</code><br />
在这个网页中添加网络打印机或者本地打印机，然后测试打印是否正常</p>
<h3 id="_4"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_4">最后，配置无线功能</a></h3>
<p>上一部添加的打印机可能是有线网络打印机，也可能是串口打印机，都不能让我们的手机直接使用。  </p>
<p>但是通过cups + avahi 就可以将你的有线打印机变成无线打印机了<br />
首先在cups里配置，勾选<code>Share This Printer</code>， 
<img alt="cups shares printer" src="../../../../img/cups_share.png" /></p>
<p>然后像刚才添加ssh服务一样， 添加打印服务<br />
在<code>/etc/avahi/services/</code> 创建一个service后缀的文件<code>airprint.service</code></p>
<p><div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; standalone=&#39;no&#39;?&gt;</span><span class="cm">&lt;!--*-nxml-*--&gt;</span>
<span class="cp">&lt;!DOCTYPE service-group SYSTEM &quot;avahi-service.dtd&quot;&gt;</span>
<span class="nt">&lt;service-group&gt;</span>
<span class="w">  </span><span class="nt">&lt;name&gt;</span>Printer<span class="nt">&lt;/name&gt;</span>
<span class="w">  </span><span class="nt">&lt;service&gt;</span>
<span class="w">    </span><span class="nt">&lt;type&gt;</span>_ipp._tcp<span class="nt">&lt;/type&gt;</span>
<span class="w">    </span><span class="nt">&lt;subtype&gt;</span>_universal._sub._ipp._tcp<span class="nt">&lt;/subtype&gt;</span>
<span class="w">    </span><span class="nt">&lt;port&gt;</span>631<span class="nt">&lt;/port&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>txtver=1<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>qtotal=1<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>rp=printers/Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>ty=Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>adminurl=http://yourip:631/printers/Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>note=Ricoh_MP_4055<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>priority=0<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>product=(GPL<span class="w"> </span>Ghostscript)<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>printer-state=3<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>printer-type=0x801046<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Transparent=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Binary=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Fax=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Color=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Duplex=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Staple=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Copies=T<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Collate=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Punch=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Bind=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Sort=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>Scan=F<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>pdl=application/octet-stream,application/pdf,application/postscript,image/jpeg,image/png,image/urf<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">    </span><span class="nt">&lt;txt-record&gt;</span>URF=W8,SRGB24,CP1,RS600<span class="nt">&lt;/txt-record&gt;</span>
<span class="w">  </span><span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/service-group&gt;</span>
</code></pre></div>
根据情况修改一下内容，就完成了, 亲测iphone可以使用这个服务打印</p>
<h3 id="_5"><a class="toclink" href="../../../../%E4%BD%BF%E7%94%A8avahi%E5%B0%86%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%AF%E6%8C%81%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0/#_5">注意</a></h3>
<p>上面的情况假设防火墙处于关闭状态，如果启用防火墙的情况下，需要开放avahi、ssh以及ipp服务</p>
<div class="highlight"><pre><span></span><code>sudo firewall-cmd --add-service ssh ipp --permanent
sudo firewall-cmd --add-port=5353/tcp --permanent
sudo firewall-cmd --reload
</code></pre></div>
    
    
  </div>
</article>
      
      
        
          



<nav class="md-pagination">
  <a class="md-pagination__link" href="../../">1</a> <a class="md-pagination__link" href="../2/">2</a> <span class="md-pagination__current">3</span> <a class="md-pagination__link" href="../4/">4</a>
</nav>
        
      
    </div>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../../../2022/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 2022">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                2022
              </div>
            </div>
          </a>
        
        
          
          <a href="../../../2020/" class="md-footer__link md-footer__link--next" aria-label="下一页: 2020">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                2020
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../../../..", "features": ["content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "content.tooltips", "navigation.footer", "navigation.indexes", "navigation.sections", "navigation.tabs", "navigation.top", "navigation.tracking"], "search": "../../../../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="../../../../../js/tex-mml-chtml.js"></script>
      
        <script src="../../../../../js/mermaid.min.js"></script>
      
    
  </body>
</html>